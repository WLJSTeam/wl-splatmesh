const loadSplat=async()=>{await interpretate.shared.THREE.load();const n=interpretate.shared.THREE.THREE,{Mesh:t,OrthographicCamera:e,BufferGeometry:A,Float32BufferAttribute:s,Loader:a,FileLoader:r,Quaternion:i,Vector3:o,Color:c,Matrix4:l}=interpretate.shared.THREE.THREE,u=new e(-1,1,1,-1,0,1);const g=new class extends A{constructor(){super(),this.setAttribute("position",new s([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new s([0,2,0,0,2,0],2))}};class h{constructor(n){this._mesh=new t(g,n)}dispose(){this._mesh.geometry.dispose()}render(n){n.render(this._mesh,u)}get material(){return this._mesh.material}set material(n){this._mesh.material=n}}var p=Uint8Array,I=Uint16Array,d=Int32Array,C=new p([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),B=new p([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),f=new p([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),E=function(n,t){for(var e=new I(31),A=0;A<31;++A)e[A]=t+=1<<n[A-1];var s=new d(e[30]);for(A=1;A<30;++A)for(var a=e[A];a<e[A+1];++a)s[a]=a-e[A]<<5|A;return{b:e,r:s}},m=E(C,2),Q=m.b,y=m.r;Q[28]=258,y[258]=28;for(var x=E(B,0).b,w=new I(32768),b=0;b<32768;++b){var v=(43690&b)>>1|(21845&b)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,w[b]=((65280&v)>>8|(255&v)<<8)>>1}var S=function(n,t,e){for(var A=n.length,s=0,a=new I(t);s<A;++s)n[s]&&++a[n[s]-1];var r,i=new I(t);for(s=1;s<t;++s)i[s]=i[s-1]+a[s-1]<<1;if(e){r=new I(1<<t);var o=15-t;for(s=0;s<A;++s)if(n[s])for(var c=s<<4|n[s],l=t-n[s],u=i[n[s]-1]++<<l,g=u|(1<<l)-1;u<=g;++u)r[w[u]>>o]=c}else for(r=new I(A),s=0;s<A;++s)n[s]&&(r[s]=w[i[n[s]-1]++]>>15-n[s]);return r},D=new p(288);for(b=0;b<144;++b)D[b]=8;for(b=144;b<256;++b)D[b]=9;for(b=256;b<280;++b)D[b]=7;for(b=280;b<288;++b)D[b]=8;var M=new p(32);for(b=0;b<32;++b)M[b]=5;var k=S(D,9,1),_=S(M,5,1),T=function(n){for(var t=n[0],e=1;e<n.length;++e)n[e]>t&&(t=n[e]);return t},F=function(n,t,e){var A=t/8|0;return(n[A]|n[A+1]<<8)>>(7&t)&e},N=function(n,t){var e=t/8|0;return(n[e]|n[e+1]<<8|n[e+2]<<16)>>(7&t)},R=function(n){return(n+7)/8|0},G=function(n,t,e){return(null==t||t<0)&&(t=0),(null==e||e>n.length)&&(e=n.length),new p(n.subarray(t,e))},U=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Y=function(n,t,e){var A=new Error(t||U[n]);if(A.code=n,Error.captureStackTrace&&Error.captureStackTrace(A,Y),!e)throw A;return A},q=function(n,t,e,A){var s=n.length,a=A?A.length:0;if(!s||t.f&&!t.l)return e||new p(0);var r=!e,i=r||2!=t.i,o=t.i;r&&(e=new p(3*s));var c=function(n){var t=e.length;if(n>t){var A=new p(Math.max(2*t,n));A.set(e),e=A}},l=t.f||0,u=t.p||0,g=t.b||0,h=t.l,I=t.d,d=t.m,E=t.n,m=8*s;do{if(!h){l=F(n,u,1);var y=F(n,u+1,3);if(u+=3,!y){var w=n[(K=R(u)+4)-4]|n[K-3]<<8,b=K+w;if(b>s){o&&Y(0);break}i&&c(g+w),e.set(n.subarray(K,b),g),t.b=g+=w,t.p=u=8*b,t.f=l;continue}if(1==y)h=k,I=_,d=9,E=5;else if(2==y){var v=F(n,u,31)+257,D=F(n,u+10,15)+4,M=v+F(n,u+5,31)+1;u+=14;for(var U=new p(M),q=new p(19),z=0;z<D;++z)q[f[z]]=F(n,u+3*z,7);u+=3*D;var L=T(q),J=(1<<L)-1,H=S(q,L,1);for(z=0;z<M;){var K,V=H[F(n,u,J)];if(u+=15&V,(K=V>>4)<16)U[z++]=K;else{var $=0,j=0;for(16==K?(j=3+F(n,u,3),u+=2,$=U[z-1]):17==K?(j=3+F(n,u,7),u+=3):18==K&&(j=11+F(n,u,127),u+=7);j--;)U[z++]=$}}var Z=U.subarray(0,v),X=U.subarray(v);d=T(Z),E=T(X),h=S(Z,d,1),I=S(X,E,1)}else Y(1);if(u>m){o&&Y(0);break}}i&&c(g+131072);for(var O=(1<<d)-1,P=(1<<E)-1,W=u;;W=u){var nn=($=h[N(n,u)&O])>>4;if((u+=15&$)>m){o&&Y(0);break}if($||Y(2),nn<256)e[g++]=nn;else{if(256==nn){W=u,h=null;break}var tn=nn-254;if(nn>264){var en=C[z=nn-257];tn=F(n,u,(1<<en)-1)+Q[z],u+=en}var An=I[N(n,u)&P],sn=An>>4;An||Y(3),u+=15&An;X=x[sn];if(sn>3){en=B[sn];X+=N(n,u)&(1<<en)-1,u+=en}if(u>m){o&&Y(0);break}i&&c(g+131072);var an=g+tn;if(g<X){var rn=a-X,on=Math.min(X,an);for(rn+g<0&&Y(3);g<on;++g)e[g]=A[rn+g]}for(;g<an;++g)e[g]=e[g-X]}}t.l=h,t.p=W,t.b=g,t.f=l,h&&(l=1,t.m=d,t.d=I,t.n=E)}while(!l);return g!=e.length&&r?G(e,0,g):e.subarray(0,g)},z=new p(0),L=function(n,t){return n[t]|n[t+1]<<8},J=function(n,t){return(n[t]|n[t+1]<<8|n[t+2]<<16|n[t+3]<<24)>>>0},H=function(n,t){return J(n,t)+4294967296*J(n,t+4)},K=function(){function n(n,t){"function"==typeof n&&(t=n,n={}),this.ondata=t;var e=n&&n.dictionary&&n.dictionary.subarray(-32768);this.s={i:0,b:e?e.length:0},this.o=new p(32768),this.p=new p(0),e&&this.o.set(e)}return n.prototype.e=function(n){if(this.ondata||Y(5),this.d&&Y(4),this.p.length){if(n.length){var t=new p(this.p.length+n.length);t.set(this.p),t.set(n,this.p.length),this.p=t}}else this.p=n},n.prototype.c=function(n){this.s.i=+(this.d=n||!1);var t=this.s.b,e=q(this.p,this.s,this.o);this.ondata(G(e,t,this.s.b),this.d),this.o=G(e,this.s.b-32768),this.s.b=this.o.length,this.p=G(this.p,this.s.p/8|0),this.s.p&=7},n.prototype.push=function(n,t){this.e(n),this.c(t)},n}();function V(n,t){return q(n,{i:2},t&&t.out,t&&t.dictionary)}var $=function(){function n(n,t){this.v=1,this.r=0,K.call(this,n,t)}return n.prototype.push=function(n,t){if(K.prototype.e.call(this,n),this.r+=n.length,this.v){var e=this.p.subarray(this.v-1),A=e.length>3?function(n){31==n[0]&&139==n[1]&&8==n[2]||Y(6,"invalid gzip data");var t=n[3],e=10;4&t&&(e+=2+(n[10]|n[11]<<8));for(var A=(t>>3&1)+(t>>4&1);A>0;A-=!n[e++]);return e+(2&t)}(e):4;if(A>e.length){if(!t)return}else this.v>1&&this.onmember&&this.onmember(this.r-e.length);this.p=e.subarray(A),this.v=0}K.prototype.c.call(this,t),!this.s.f||this.s.l||t||(this.v=R(this.s.p)+9,this.s={i:0},this.o=new p(0),this.push(new p(0),t))},n}(),j="undefined"!=typeof TextDecoder&&new TextDecoder;try{j.decode(z,{stream:!0}),1}catch(n){}function Z(n,t){if(t){for(var e="",A=0;A<n.length;A+=16384)e+=String.fromCharCode.apply(null,n.subarray(A,A+16384));return e}if(j)return j.decode(n);var s=function(n){for(var t="",e=0;;){var A=n[e++],s=(A>127)+(A>223)+(A>239);if(e+s>n.length)return{s:t,r:G(n,e-1)};s?3==s?(A=((15&A)<<18|(63&n[e++])<<12|(63&n[e++])<<6|63&n[e++])-65536,t+=String.fromCharCode(55296|A>>10,56320|1023&A)):t+=1&s?String.fromCharCode((31&A)<<6|63&n[e++]):String.fromCharCode((15&A)<<12|(63&n[e++])<<6|63&n[e++]):t+=String.fromCharCode(A)}}(n),a=s.s;return(e=s.r).length&&Y(8),a}var X=function(n,t){return t+30+L(n,t+26)+L(n,t+28)},O=function(n,t,e){var A=L(n,t+28),s=Z(n.subarray(t+46,t+46+A),!(2048&L(n,t+8))),a=t+46+A,r=J(n,t+20),i=e&&4294967295==r?P(n,a):[r,J(n,t+24),J(n,t+42)],o=i[0],c=i[1],l=i[2];return[L(n,t+10),o,c,s,a+L(n,t+30)+L(n,t+32),l]},P=function(n,t){for(;1!=L(n,t);t+=4+L(n,t+2));return[H(n,t+12),H(n,t+4),H(n,t+20)]};let W;const nn="undefined"!=typeof TextDecoder?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};"undefined"!=typeof TextDecoder&&nn.decode();let tn=null;function en(n,t){return n>>>=0,nn.decode((null!==tn&&0!==tn.byteLength||(tn=new Uint8Array(W.memory.buffer)),tn).subarray(n,n+t))}async function An(n){if(void 0!==W)return W;void 0!==n&&(Object.getPrototypeOf(n)===Object.prototype?({module_or_path:n}=n):console.warn("using deprecated parameters for the initialization function; pass a single object instead")),void 0===n&&(n=new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAN/f38AYAF/AX9gAX8AYANvf38Bb2AFf39/f38Bf2AFf39/f38AYAFvAW9gA29vfwBgAW8Bf2AAAGAAAX9gBH9/f38AYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAYDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABgN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAGA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAYDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADANeXQQAAQcFAgMCEwEBAA0BAwEAAA0BAwgIAwEBBRQBAw4AAwEDAgwMAgABAQcDABUBFhcIGRsH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QYGABGxBEHYgBGohBCAHRQ0ACwJ/IAMgBkH8AXFBAnRqIgAoAgAiAUF/c0EHdiABQQZ2ckGBgoQIcSIBIAdBAUYNABogASAAKAIEIgFBf3NBB3YgAUEGdnJBgYKECHFqIgEgB0ECRg0AGiAAKAIIIgBBf3NBB3YgAEEGdnJBgYKECHEgAWoLIgFBCHZB/4EccSABQf+B/AdxakGBgARsQRB2IARqDwsgAUUEQEEADwsgAUEDcSEDAkAgAUEESQRADAELIAFBfHEhBQNAIAQgACACaiIBLAAAQb9/SmogAUEBaiwAAEG/f0pqIAFBAmosAABBv39KaiABQQNqLAAAQb9/SmohBCAFIAJBBGoiAkcNAAsLIANFDQAgACACaiEBA0AgBCABLAAAQb9/SmohBCABQQFqIQEgA0EBayIDDQALCyAEC4oGAQZ/IAAoAggiAyABSQRAIAEgAyICayIEIAAoAgAgAmtLBEAgACACIARBBEEEECYgACgCCCECCyAAKAIEIgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AggLIAAoAhQiAyABSQRAIAEgAyICayIEIAAoAgwgAmtLBEAgAEEMaiACIARBBEEEECYgACgCFCECCyAAKAIQIgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AhQLIAAoAjgiAyABSQRAIAEgAyICayIEIAAoAjAgAmtLBEAgAEEwaiACIARBBEEEECYgACgCOCECCyAAKAI0IgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AjgLIAAoAiAiA0H//wNNBEAgAyEBQYCABCADayICIAAoAhggA2tLBEAgAEEYaiADIAJBBEEEECYgACgCICEBCyAAKAIcIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQAgB/wLAAsgBCAGayAFakH8/w9qIQIgASADa0H//wNqIQELIAJBADYCACAAIAFBAWo2AiALIAAoAiwiA0H//wNNBEAgAyEBQYCABCADayICIAAoAiQgA2tLBEAgAEEkaiADIAJBBEEEECYgACgCLCEBCyAAKAIoIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQAgB/wLAAsgBCAGayAFakH8/w9qIQIgASADa0H//wNqIQELIAJBADYCACAAIAFBAWo2AiwLC7AFAgh/AX5BK0GAgMQAIAAoAggiCEGAgIABcSIGGyELIAZBFXYgBGohBgJAIAhBgICABHFFBEBBACEBDAELAkAgAkEQTwRAIAEgAhASIQUMAQsgAkUEQAwBCyACQQNxIQkCQCACQQRJBEAMAQsgAkEMcSEMA0AgBSABIAdqIgosAABBv39KaiAKQQFqLAAAQb9/SmogCkECaiwAAEG/f0pqIApBA2osAABBv39KaiEFIAwgB0EEaiIHRw0ACwsgCUUNACABIAdqIQcDQCAFIAcsAABBv39KaiEFIAdBAWohByAJQQFrIgkNAAsLIAUgBmohBgsCQCAALwEMIgkgBksEQAJAAkAgCEGAgIAIcUUEQCAJIAZrIQlBACEFQQAhBgJAAkACQCAIQR12QQNxQQFrDgMAAQACCyAJIQYMAQsgCUH+/wNxQQF2IQYLIAhB////AHEhCiAAKAIEIQggACgCACEAA0AgBUH//wNxIAZB//8DcU8NAkEBIQcgBUEBaiEFIAAgCiAIKAIQEQAARQ0ACwwECyAAIAApAggiDadBgICA/3lxQbCAgIACcjYCCEEBIQcgACgCACIIIAAoAgQiCiALIAEgAhA7DQNBACEFIAkgBmtB//8DcSEBA0AgBUH//wNxIAFPDQIgBUEBaiEFIAhBMCAKKAIQEQAARQ0ACwwDC0EBIQcgACAIIAsgASACEDsNAiAAIAMgBCAIKAIMEQIADQJBACEFIAkgBmtB//8DcSEBA0AgBUH//wNxIgIgAUkhByABIAJNDQMgBUEBaiEFIAAgCiAIKAIQEQAARQ0ACwwCCyAIIAMgBCAKKAIMEQIADQEgACANNwIIQQAPC0EBIQcgACgCACIGIAAoAgQiACALIAEgAhA7DQAgBiADIAQgACgCDBECACEHCyAHC/4FAQV/IABBCGsiASAAQQRrKAIAIgNBeHEiAGohAgJAAkAgA0EBcQ0AIANBAnFFDQEgASgCACIDIABqIQAgASADayIBQcyZwAAoAgBGBEAgAigCBEEDcUEDRw0BQcSZwAAgADYCACACIAIoAgRBfnE2AgQgASAAQQFyNgIEIAIgADYCAA8LIAEgAxAeCwJAAkACQAJAAkAgAigCBCIDQQJxRQRAIAJB0JnAACgCAEYNAiACQcyZwAAoAgBGDQMgAiADQXhxIgIQHiABIAAgAmoiAEEBcjYCBCAAIAFqIAA2AgAgAUHMmcAAKAIARw0BQcSZwAAgADYCAA8LIAIgA0F+cTYCBCABIABBAXI2AgQgACABaiAANgIACyAAQYACSQ0CIAEgABAgQQAhAUHkmcAAQeSZwAAoAgBBAWsiADYCACAADQRBrJfAACgCACIABEADQCABQQFqIQEgACgCCCIADQALC0HkmcAAQf8fIAEgAUH/H00bNgIADwtB0JnAACABNgIAQciZwABByJnAACgCACAAaiIANgIAIAEgAEEBcjYCBEHMmcAAKAIAIAFGBEBBxJnAAEEANgIAQcyZwABBADYCAAsgAEHcmcAAKAIAIgNNDQNB0JnAACgCACICRQ0DQQAhAEHImcAAKAIAIgRBKUkNAkGkl8AAIQEDQCACIAEoAgAiBU8EQCACIAUgASgCBGpJDQQLIAEoAgghAQwACwALQcyZwAAgATYCAEHEmcAAQcSZwAAoAgAgAGoiADYCACABIABBAXI2AgQgACABaiAANgIADwsgAEH4AXFBtJfAAGohAgJ/QbyZwAAoAgAiA0EBIABBA3Z0IgBxRQRAQbyZwAAgACADcjYCACACDAELIAIoAggLIQAgAiABNgIIIAAgATYCDCABIAI2AgwgASAANgIIDwtBrJfAACgCACIBBEADQCAAQQFqIQAgASgCCCIBDQALC0HkmcAAQf8fIAAgAEH/H00bNgIAIAMgBE8NAEHcmcAAQX82AgALC98EAQZ/AkACQCAAKAIIIgdBgICAwAFxRQ0AAkACQAJAAkAgB0GAgICAAXEEQCAALwEOIgMNAUEAIQIMAgsgAkEQTwRAIAEgAhASIQMMBAsgAkUEQEEAIQIMBAsgAkEDcSEGAkAgAkEESQRADAELIAJBDHEhCANAIAMgASAFaiIELAAAQb9/SmogBEEBaiwAAEG/f0pqIARBAmosAABBv39KaiAEQQNqLAAAQb9/SmohAyAIIAVBBGoiBUcNAAsLIAZFDQMgASAFaiEEA0AgAyAELAAAQb9/SmohAyAEQQFqIQQgBkEBayIGDQALDAMLIAEgAmohCEEAIQIgASEEIAMhBQNAIAQiBiAIRg0CAn8gBkEBaiAGLAAAIgRBAE4NABogBkECaiAEQWBJDQAaIAZBA2ogBEFwSQ0AGiAGQQRqCyIEIAZrIAJqIQIgBUEBayIFDQALC0EAIQULIAMgBWshAwsgAyAALwEMIgRPDQAgBCADayEGQQAhA0EAIQUCQAJAAkAgB0EddkEDcUEBaw4CAAECCyAGIQUMAQsgBkH+/wNxQQF2IQULIAdB////AHEhCCAAKAIEIQcgACgCACEAA0AgA0H//wNxIAVB//8DcUkEQEEBIQQgA0EBaiEDIAAgCCAHKAIQEQAARQ0BDAMLC0EBIQQgACABIAIgBygCDBECAA0BQQAhAyAGIAVrQf//A3EhAQNAIANB//8DcSICIAFJIQQgASACTQ0CIANBAWohAyAAIAggBygCEBEAAEUNAAsMAQsgACgCACABIAIgACgCBCgCDBECACEECyAEC+kEAQV/An8CQCACQQJPBEAgASgCBCIEQf//AXFFBEAgBEEQdAwDCyAEQf8HcSEFIARBgIACcSEDIARBgPgBcSIGQYD4AUYEQCADQRB0IQMgA0GAgID8B3IgBUUNAxogAyAFQQ10ckGAgID+B3IMAwsgA0EQdCEDIAZFDQEgBkENdEGAgID8AHEgBUENdHJBgICAwANqIANyDAILQQFBAUHkhsAAEDEACyAFIAVnQRBrIgVB//8DcUEIanRB////A3EgA0GAgIDYA3IgBUEXdGtyCyEFAn8gBEGAgHxxIARBEHYiA0H//wFxRQ0AGiADQf8HcSEEIANBgIACcSEGIANBgPgBcSIHQYD4AUYEQCAGQRB0IQYgBkGAgID8B3IgBEUNARogBiADQQ10ckGAgID+B3IMAQsgBkEQdCEDIAdBDXRBgICA/ABxIARBDXRyQYCAgMADaiADciAHDQAaIAQgBGdBEGsiBEH//wNxQQhqdEH///8DcSADQYCAgNgDciAEQRd0a3ILIQQgAAJ/AkAgAkECRwRAIAEoAggiAkH//wFxRQRAIAJBEHQMAwsgAkH/B3EhASACQYCAAnEhAyACQYD4AXEiAkGA+AFGBEAgA0EQdCECIAJBgICA/AdyIAFFDQMaIAIgAUENdHJBgICA/gdyDAMLIANBEHQhAyACRQ0BIAJBDXRBgICA/ABxIAFBDXRyQYCAgMADaiADcgwCC0ECQQJB9IbAABAxAAsgASABZ0EQayIBQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAFBF3Rrcgs2AgggACAENgIEIAAgBTYCAAu6BAEIfyMAQRBrIgMkACADIAE2AgQgAyAANgIAIANCoICAgA43AggCfwJAAkACQCACKAIQIgkEQCACKAIUIgANAQwCCyACKAIMIgBFDQEgAigCCCIBIABBA3RqIQQgAEEBa0H/////AXFBAWohBiACKAIAIQADQAJAIABBBGooAgAiBUUNACADKAIAIAAoAgAgBSADKAIEKAIMEQIARQ0AQQEMBQtBASABKAIAIAMgAUEEaigCABEAAA0EGiAAQQhqIQAgBCABQQhqIgFHDQALDAILIABBGGwhCiAAQQFrQf////8BcUEBaiEGIAIoAgghBCACKAIAIQADQAJAIABBBGooAgAiAUUNACADKAIAIAAoAgAgASADKAIEKAIMEQIARQ0AQQEMBAtBACEHQQAhCAJAAkACQCAFIAlqIgFBCGovAQBBAWsOAgECAAsgAUEKai8BACEIDAELIAQgAUEMaigCAEEDdGovAQQhCAsCQAJAAkAgAS8BAEEBaw4CAQIACyABQQJqLwEAIQcMAQsgBCABQQRqKAIAQQN0ai8BBCEHCyADIAc7AQ4gAyAIOwEMIAMgAUEUaigCADYCCEEBIAQgAUEQaigCAEEDdGoiASgCACADIAEoAgQRAAANAxogAEEIaiEAIAVBGGoiBSAKRw0ACwwBCwsCQCAGIAIoAgRPDQAgAygCACACKAIAIAZBA3RqIgAoAgAgACgCBCADKAIEKAIMEQIARQ0AQQEMAQtBAAsgA0EQaiQAC/cDAgR/An0jAEEQayECIAC8IgNBH3YhBAJAAn0gAAJ/AkACQAJAAkAgA0H/////B3EiAUHQ2LqVBE8EQCABQYCAgPwHSwRAIAAPCyADQQBIIgNFIAFBl+TFlQRLcQ0CIANFDQEgAkMAAICAIACVOAIIIAIqAggaIAFBtOO/lgRNDQEMBwsgAUGY5MX1A00EQCABQYCAgMgDTQ0DQQAhASAADAYLIAFBkquU/ANNDQMLIABDO6q4P5QgBEECdEHclMAAaioCAJL8AAwDCyAAQwAAAH+UDwsgAiAAQwAAAH+SOAIMIAIqAgwaIABDAACAP5IPCyAERSAEawsiAbIiBUMAcjG/lJIiACAFQ46+vzWUIgaTCyEFIAAgBSAFIAUgBZQiACAAQxVSNbuUQ4+qKj6SlJMiAJRDAAAAQCAAk5UgBpOSQwAAgD+SIQUgAUUNAAJAAkACQCABQf8ATARAIAFBgn9ODQMgBUMAAIAMlCEFIAFBm35NDQEgAUHmAGohAQwDCyAFQwAAAH+UIQUgAUH+AUsNASABQf8AayEBDAILIAVDAACADJQhBUG2fSABIAFBtn1NG0HMAWohAQwBCyAFQwAAAH+UIQVB/QIgASABQf0CTxtB/gFrIQELIAUgAUEXdEGAgID8A2pBgICA/AdxvpQhBQsgBQv5AwECfyAAIAFqIQICQAJAIAAoAgQiA0EBcQ0AIANBAnFFDQEgACgCACIDIAFqIQEgACADayIAQcyZwAAoAgBGBEAgAigCBEEDcUEDRw0BQcSZwAAgATYCACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAIgATYCAAwCCyAAIAMQHgsCQAJAAkAgAigCBCIDQQJxRQRAIAJB0JnAACgCAEYNAiACQcyZwAAoAgBGDQMgAiADQXhxIgIQHiAAIAEgAmoiAUEBcjYCBCAAIAFqIAE2AgAgAEHMmcAAKAIARw0BQcSZwAAgATYCAA8LIAIgA0F+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACyABQYACTwRAIAAgARAgDwsgAUH4AXFBtJfAAGohAgJ/QbyZwAAoAgAiA0EBIAFBA3Z0IgFxRQRAQbyZwAAgASADcjYCACACDAELIAIoAggLIQEgAiAANgIIIAEgADYCDCAAIAI2AgwgACABNgIIDwtB0JnAACAANgIAQciZwABByJnAACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQcyZwAAoAgBHDQFBxJnAAEEANgIAQcyZwABBADYCAA8LQcyZwAAgADYCAEHEmcAAQcSZwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIACwvuAwEHfyMAQRBrIgQkAAJAAkACQAJAIAEoAgQiAgRAIAEoAgAhBiACQQNxIQUCQCACQQRJBEBBACECDAELIAZBHGohAyACQXxxIQhBACECA0AgAygCACADQQhrKAIAIANBEGsoAgAgA0EYaygCACACampqaiECIANBIGohAyAIIAdBBGoiB0cNAAsLIAUEQCAHQQN0IAZqQQRqIQMDQCADKAIAIAJqIQIgA0EIaiEDIAVBAWsiBQ0ACwsgASgCDEUNAiACQQ9LDQEgBigCBA0BDAMLQQAhAiABKAIMRQ0CCyACQQAgAkEAShtBAXQhAgtBACEFIAJBAE4EQCACRQ0BQQEhBSACQQEQWCIDDQILIAUgAkGUj8AAEEwAC0EBIQNBACECCyAEQQA2AgggBCADNgIEIAQgAjYCACAEQdCOwAAgARAYRQRAIAAgBCkCADcCACAAQQhqIARBCGooAgA2AgAgBEEQaiQADwsjAEFAaiIAJAAgAEHWADYCDCAAQbSPwAA2AgggAEGkj8AANgIUIAAgBEEPajYCECAAQQI2AhwgAEGkksAANgIYIABCAjcCJCAAIABBEGqtQoCAgICgBYQ3AzggACAAQQhqrUKAgICAsAWENwMwIAAgAEEwajYCICAAQRhqQYyQwAAQPwAL5wIBBX8CQCABQc3/e0EQIAAgAEEQTRsiAGtPDQAgAEEQIAFBC2pBeHEgAUELSRsiBGpBDGoQESICRQ0AIAJBCGshAQJAIABBAWsiAyACcUUEQCABIQAMAQsgAkEEayIFKAIAIgZBeHEgAiADakEAIABrcUEIayICIABBACACIAFrQRBNG2oiACABayICayEDIAZBA3EEQCAAIAMgACgCBEEBcXJBAnI2AgQgACADaiIDIAMoAgRBAXI2AgQgBSACIAUoAgBBAXFyQQJyNgIAIAEgAmoiAyADKAIEQQFyNgIEIAEgAhAaDAELIAEoAgAhASAAIAM2AgQgACABIAJqNgIACwJAIAAoAgQiAUEDcUUNACABQXhxIgIgBEEQak0NACAAIAQgAUEBcXJBAnI2AgQgACAEaiIBIAIgBGsiBEEDcjYCBCAAIAJqIgIgAigCBEEBcjYCBCABIAQQGgsgAEEIaiEDCyADC5sEAQt/IwBBIGsiBCQAECMiASgCECEIIAEoAgwhCSABQgA3AgwgASgCBCECIAEoAgghBSABQgQ3AgQgASgCACEAIAFBADYCAAJAAkAgBSAJRgRAAkAgACAFRgRA0G9BgAEgACAAQYABTRsiA/wPASIGQX9GDQQCQCAIRQRAIAYhCAwBCyAAIAhqIAZHDQULIAAgA2oiBkH/////AUsNBCAEIAAEfyAEIAI2AhQgBCAAQQJ0NgIcQQQFQQALNgIYIARBCGohACAEQRRqIQMCQCAGQQJ0IgJBAE4EQAJ/AkACfwJAIAMoAgQEQCADKAIIIgcNASACRQ0DIAJBBBBYDAILIAJFDQIgAkEEEFgMAQsgAygCACAHQQQgAhBQCyEDIABBBGohByAAQQhqIgogAw0BGiAKIAI2AgAgB0EENgIAIABBATYCAAwDC0EEIQMgAEEEaiEHIABBCGoLIAI2AgAgByADNgIAIABBADYCAAwBCyAAQQA2AgQgAEEBNgIACyAEKAIIQQFGDQQgBCgCDCECIAYhAAwBCyAAIAVNDQMLIAIgBUECdGogBUEBaiIFNgIAIAEoAgQhBiABKAIAIQMMAQtBBCEGIAUgCU0NAQsgAiAJQQJ0aigCACEHIAEgCDYCECABIAc2AgwgASAFNgIIIAEgAjYCBCABIAA2AgAgAwRAIAYgA0ECdBBgCyAEQSBqJAAgCCAJag8LAAuCAwEEfyAAKAIMIQICQAJAAkAgAUGAAk8EQCAAKAIYIQMCQAJAIAAgAkYEQCAAQRRBECAAKAIUIgIbaigCACIBDQFBACECDAILIAAoAggiASACNgIMIAIgATYCCAwBCyAAQRRqIABBEGogAhshBANAIAQhBSABIgJBFGogAkEQaiACKAIUIgEbIQQgAkEUQRAgARtqKAIAIgENAAsgBUEANgIACyADRQ0CAkAgACgCHEECdEGklsAAaiIBKAIAIABHBEAgAygCECAARg0BIAMgAjYCFCACDQMMBAsgASACNgIAIAJFDQQMAgsgAyACNgIQIAINAQwCCyAAKAIIIgAgAkcEQCAAIAI2AgwgAiAANgIIDwtBvJnAAEG8mcAAKAIAQX4gAUEDdndxNgIADwsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIAAoAhQiAEUNACACIAA2AhQgACACNgIYDwsPC0HAmcAAQcCZwAAoAgBBfiAAKAIcd3E2AgALzgIBCH9BCiEDIAEiBEHoB08EQCACQQRrIQggBCEFA0AgAyAIaiIGQQFqIAUgBUGQzgBuIgRBkM4AbGsiB0H//wNxQeQAbiIJQQF0IgpBupLAAGotAAA6AAAgBiAKQbmSwABqLQAAOgAAIAZBA2ogByAJQeQAbGtB//8DcUEBdCIHQbqSwABqLQAAOgAAIAZBAmogB0G5ksAAai0AADoAACADQQRrIQMgBUH/rOIESyAEIQUNAAsLAkAgBEEJTQRAIAQhBQwBCyACIANqQQFrIAQgBEH//wNxQeQAbiIFQeQAbGtB//8DcUEBdCIEQbqSwABqLQAAOgAAIAIgA0ECayIDaiAEQbmSwABqLQAAOgAAC0EAIAEgBRtFBEAgAiADQQFrIgNqIAVBAXRBHnFBupLAAGotAAA6AAALIABBCiADazYCBCAAIAIgA2o2AgALxAIBBH8gAEIANwIQIAACf0EAIAFBgAJJDQAaQR8gAUH///8HSw0AGiABQQYgAUEIdmciA2t2QQFxIANBAXRrQT5qCyICNgIcIAJBAnRBpJbAAGohBEEBIAJ0IgNBwJnAACgCAHFFBEAgBCAANgIAIAAgBDYCGCAAIAA2AgwgACAANgIIQcCZwABBwJnAACgCACADcjYCAA8LAkACQCABIAQoAgAiAygCBEF4cUYEQCADIQIMAQsgAUEZIAJBAXZrQQAgAkEfRxt0IQUDQCADIAVBHXZBBHFqIgQoAhAiAkUNAiAFQQF0IQUgAiEDIAIoAgRBeHEgAUcNAAsLIAIoAggiASAANgIMIAIgADYCCCAAQQA2AhggACACNgIMIAAgATYCCA8LIARBEGogADYCACAAIAM2AhggACAANgIMIAAgADYCCAuZAgEDfyAAKAIIIgMhAgJ/QQEgAUGAAUkNABpBAiABQYAQSQ0AGkEDQQQgAUGAgARJGwsiBCAAKAIAIANrSwR/IAAgAyAEECUgACgCCAUgAgsgACgCBGohAgJAAkAgAUGAAU8EQCABQYAQSQ0BIAFBgIAETwRAIAIgAUE/cUGAAXI6AAMgAiABQRJ2QfABcjoAACACIAFBBnZBP3FBgAFyOgACIAIgAUEMdkE/cUGAAXI6AAEMAwsgAiABQT9xQYABcjoAAiACIAFBDHZB4AFyOgAAIAIgAUEGdkE/cUGAAXI6AAEMAgsgAiABOgAADAELIAIgAUE/cUGAAXI6AAEgAiABQQZ2QcABcjoAAAsgACADIARqNgIIQQALmQIBA38gACgCCCIDIQICf0EBIAFBgAFJDQAaQQIgAUGAEEkNABpBA0EEIAFBgIAESRsLIgQgACgCACADa0sEfyAAIAMgBBAoIAAoAggFIAILIAAoAgRqIQICQAJAIAFBgAFPBEAgAUGAEEkNASABQYCABE8EQCACIAFBP3FBgAFyOgADIAIgAUESdkHwAXI6AAAgAiABQQZ2QT9xQYABcjoAAiACIAFBDHZBP3FBgAFyOgABDAMLIAIgAUE/cUGAAXI6AAIgAiABQQx2QeABcjoAACACIAFBBnZBP3FBgAFyOgABDAILIAIgAToAAAwBCyACIAFBP3FBgAFyOgABIAIgAUEGdkHAAXI6AAALIAAgAyAEajYCCEEAC/MCAQR/IwBBMGsiACQAAkACQEHklMAAKAIARQRAQfyUwAAoAgAhAUH8lMAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUHklMAAKAIAIgMNAgJAIANFDQBB6JTAACgCACICRQ0AQeyUwAAoAgAgAkECdBBgC0HolMAAIAE2AgBB5JTAAEEBNgIAQeyUwAAgACkDCDcCAEH0lMAAIABBEGopAwA3AgALIABBMGokAEHolMAADwsgAEEANgIoIABBATYCHCAAQeiKwAA2AhggAEIENwIgIABBGGpB8IrAABA/AAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQYAsgAEEANgIoIABBATYCHCAAQZCLwAA2AhggAEIENwIgIAFBmIvAABA/AAufAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQbiLwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCACACIAU3AwBBDEEEEFgiAUUEQEEEQQwQaAALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHwjcAANgIEIAAgATYCACACQUBrJAAL1AECBH8BfiMAQSBrIgMkAAJAAkAgASABIAJqIgJLBEBBACEBDAELQQAhAUEIIAIgACgCACIFQQF0IgQgAiAESxsiAiACQQhNGyIErSIHQiCIUEUNACAHpyIGQf////8HSw0AIAMgBQR/IAMgBTYCHCADIAAoAgQ2AhRBAQVBAAs2AhggA0EIakEBIAYgA0EUahAvIAMoAghBAUcNASADKAIQIQIgAygCDCEBCyABIAJBqIvAABBMAAsgAygCDCEBIAAgBDYCACAAIAE2AgQgA0EgaiQAC+4BAgR/AX4jAEEgayIFJAACQAJAIAEgASACaiICSwRAQQAhAQwBC0EAIQEgAyAEakEBa0EAIANrca1BBCACIAAoAgAiB0EBdCIGIAIgBksbIgIgAkEETRsiBq1+IglCIIhQRQ0AIAmnIghBgICAgHggA2tLDQBBACECIAUgBwR/IAUgBCAHbDYCHCAFIAAoAgQ2AhQgAwUgAgs2AhggBUEIaiADIAggBUEUahAvIAUoAghBAUcNASAFKAIQIQIgBSgCDCEBCyABIAJB6IXAABBMAAsgBSgCDCEBIAAgBjYCACAAIAE2AgQgBUEgaiQAC5UCAQJ/IwBBIGsiBSQAQaCWwABBoJbAACgCACIGQQFqNgIAAn9BACAGQQBIDQAaQQFB7JnAAC0AAA0AGkHsmcAAQQE6AABB6JnAAEHomcAAKAIAQQFqNgIAQQILQf8BcSIGQQJHBEAgBkEBcQRAIAVBCGogACABKAIYEQEACwALAkBBlJbAACgCACIGQQBOBEBBlJbAACAGQQFqNgIAQZiWwAAoAgAEQCAFIAAgASgCFBEBACAFIAQ6AB0gBSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBmJbAACgCACAFQRBqQZyWwAAoAgAoAhQRAQALQZSWwABBlJbAACgCAEEBazYCAEHsmcAAQQA6AAAgA0UNAQALAAsAC7oBAQJ/IwBBIGsiAyQAAkACf0EAIAEgASACaiICSw0AGkEAQQggAiAAKAIAIgFBAXQiBCACIARLGyICIAJBCE0bIgRBAEgNABpBACECIAMgAQR/IAMgATYCHCADIAAoAgQ2AhRBAQUgAgs2AhggA0EIakEBIAQgA0EUahAvIAMoAghBAUcNASADKAIQIQAgAygCDAsgAEGEj8AAEEwACyADKAIMIQEgACAENgIAIAAgATYCBCADQSBqJAALuQEBBX8jAEEgayICJAAgACgCACIEQf////8BSwRAQQBBACABEEwACwJAQQQgBEEBdCIFIAVBBE0bIgVBAnQiBkH8////B00EfyACIAQEfyACIARBAnQ2AhwgAiAAKAIENgIUQQQFIAMLNgIYIAJBCGpBBCAGIAJBFGoQLyACKAIIQQFHDQEgAigCECEDIAIoAgwFIAMLIAMgARBMAAsgAigCDCEBIAAgBTYCACAAIAE2AgQgAkEgaiQAC8EBAgN/AX4jAEEwayICJAAgASgCAEGAgICAeEYEQCABKAIMIQMgAkEUaiIEQQA2AgAgAkKAgICAEDcCDCACQSBqIAMoAgAiA0EIaikCADcDACACQShqIANBEGopAgA3AwAgAiADKQIANwMYIAJBDGpBuIvAACACQRhqEBgaIAJBCGogBCgCACIDNgIAIAIgAikCDCIFNwMAIAFBCGogAzYCACABIAU3AgALIABB8I3AADYCBCAAIAE2AgAgAkEwaiQAC68BAQZ/AkACQCAAQYQBSQ0AIADQbyYBECMiASgCDCEFIAEoAhAhAiABQgA3AgwgASgCCCEDIAEoAgQhBCABQgQ3AgQgASgCACEGIAFBADYCACAAIAJJDQEgACACayIAIANPDQEgBCAAQQJ0aiAFNgIAIAEgAjYCECABIAA2AgwgASADNgIIIAEoAgQgASAENgIEIAEoAgAhACABIAY2AgAgAEUNACAAQQJ0EGALDwsAC6gBAQF/IwBBEGsiBiQAAkAgAQRAIAZBBGogASADIAQgBSACKAIQEQgAAkAgBigCBCICIAYoAgwiAU0EQCAGKAIIIQUMAQsgAkECdCECIAYoAgghAyABRQRAQQQhBSADIAIQYAwBCyADIAJBBCABQQJ0IgIQUCIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQYyKwABBMhBjAAtBBCACQfyJwAAQTAALrQEBA38gASgCDCECAkACQAJAAkACQAJAIAEoAgQOAgABAgsgAg0BQQEhA0EAIQFBASECDAMLIAJFDQELIAAgARAbDwsgASgCACICKAIEIgFBAEgNASACKAIAIQMgAUUEQEEB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A0EAIAD8CwALIAsoAighFAJAIAsoAiwiEEUNACAQQQJ0IgBFDQAgFEEAIAD8CwALIBNBAnQhCSATBEAgCSEEIAohAANAAkAgACgCACIGQYCAgPwHTw0AIAwgBkF/cyIFQf//A3EiBksEQCADIAZBAnRqIgYgBigCAEEBajYCACAQIAVBEHYiBksEQCAUIAZBAnRqIgYgBigCAEEBajYCAAwCCyAGIBBB3InAABAxAAsgBiAMQcyJwAAQMQALIABBBGohACAEQQRrIgQNAAsLAkAgDEUEQEEAIQQMAQsgDEEBa0H/////A3EiAEEBaiIEQQdxIQUCQCAAQQdJBEBBACEEIAMhAAwBCyAEQfj///8HcSEGQQAhBCADIQADQCAAKAIAIQcgACAENgIAIABBBGoiESgCACESIBEgBCAHaiIENgIAIABBCGoiBygCACERIAcgBCASaiIENgIAIABBDGoiBygCACESIAcgBCARaiIENgIAIABBEGoiBygCACERIAcgBCASaiIENgIAIABBFGoiBygCACESIAcgBCARaiIENgIAIABBGGoiBygCACERIAcgBCASaiIENgIAIABBHGoiBygCACESIAcgBCARaiIENgIAIAQgEmohBCAAQSBqIQAgBkEIayIGDQALCyAFRQ0AA0AgACgCACEGIAAgBDYCACAAQQRqIQAgBCAGaiEEIAVBAWsiBQ0ACwsgDiAENgIEIBMEQCAJIApqIREgCkEEaiEGIBNBAWtB/////wNxQQFqIRIgCygCNCEXIAsoAjghB0EAIQUgCiEJA0AgBiEAAkAgCSgCACIJQYCAgPwHTw0AAkAgDCAJQX9zQf//A3EiCUsEQCADIAlBAnRqIgkoAgAiBiAHTw0BIBcgBkECdGogBTYCACAJIAkoAgBBAWo2AgAMAgsgCSAMQayJwAAQMQALIAYgB0G8icAAEDEACyAAIAAgEUdBAnRqIQYgACEJIBIgBUEBaiIFRw0ACwsCQCAQRQ0AIBBBAWtB/////wNxIgNBAWoiCUEHcSEGQQAhBSAUIQAgA0EHTwRAIAlB+P///wdxIQkDQCAAKAIAIQMgACAFNgIAIABBBGoiDCgCACEHIAwgAyAFaiIDNgIAIABBCGoiBSgCACEMIAUgAyAHaiIDNgIAIABBDGoiBSgCACEHIAUgAyAMaiIDNgIAIABB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uIvAACABEBgLDAAgACABKQIANwMACw0AIABB0I7AACABEBgLDQAgAUHIjsAAQQUQUQsZACAAIAFBkJbAACgCACIAQRQgABsRAQAACw0AIAFBpJDAAEEYEBYLoAIBA38gACgCACEAIwBBkAFrIgMkAAJ/AkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASADQQhqIAAoAgAgA0EQahAfIAFBAUEAIAMoAgggAygCDBAUDAILIAAoAgAhAkEAIQADQCAAIANqQY8BaiACQQ9xIgRBMHIgBEHXAGogBEEKSRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAwBCyAAKAIAIQJBACEAA0AgACADakGPAWogAkEPcSIEQTByIARBN2ogBEEKSRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAsgA0GQAWokAAsJACAAQQA2AgALCAAgACUBEAMLCAAgACUBEAcLC/UUAwBBgIDAAAuhD3NwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9zb3J0LnJzAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjEwMC9zcmMvY29udmVydC9zbGljZXMucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy9tb2QucnMAL3J1c3QvZGVwcy9kbG1hbGxv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dGAgZmFpbGVkOiAKICBsZWZ0OiAAAACbCBAAEAAAAOQIEAAQAAAA9AgQAAkAAADCCBAACQAAADogAAABAAAAAAAAACAJEAACAAAAfSB9MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OSBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCByYW5nZSBlbmQgaW5kZXggACMKEAAQAAAAAQoQACIAAACQCBAAkggQAJQIEAACAAAAAgAAAAcAAAAAAAA/AAAAvwBB/JTAAAsBEgB8CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44OS4wICgyOTQ4Mzg4M2UgMjAyNS0wOC0wNCkGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4TMC4yLjEwMCAoMjQwNWVjMmI0KQBrD3RhcmdldF9mZWF0dXJlcwYrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsLYnVsay1tZW1vcnkrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU="));const t=function(){const n={wbg:{}};return n.wbg.__wbg_buffer_609cc3eee51ed158=function(n){return n.buffer},n.wbg.__wbg_length_3b4f022188ae8db6=function(n){return n.length},n.wbg.__wbg_length_6ca527665d89694d=function(n){return n.length},n.wbg.__wbg_length_8cfd2c6409af88ad=function(n){return n.length},n.wbg.__wbg_new_9fee97a409b32b68=function(n){return new Uint16Array(n)},n.wbg.__wbg_new_e3b321dcfef89fc7=function(n){return new Uint32Array(n)},n.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(n,t,e){return new Float32Array(n,t>>>0,e>>>0)},n.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(n,t,e){return new Uint32Array(n,t>>>0,e>>>0)},n.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(n){return new Float32Array(n>>>0)},n.wbg.__wbg_set_10bad9bee0e9c58b=function(n,t,e){n.set(t,e>>>0)},n.wbg.__wbg_set_d23661d19148b229=function(n,t,e){n.set(t,e>>>0)},n.wbg.__wbg_set_f4f1f0daa30696fc=function(n,t,e){n.set(t,e>>>0)},n.wbg.__wbg_subarray_3aaeec89bb2544f0=function(n,t,e){return n.subarray(t>>>0,e>>>0)},n.wbg.__wbg_subarray_769e1e0f81bb259b=function(n,t,e){return n.subarray(t>>>0,e>>>0)},n.wbg.__wbindgen_init_externref_table=function(){const n=W.__wbindgen_export_0,t=n.grow(4);n.set(0,void 0),n.set(t+0,void 0),n.set(t+1,null),n.set(t+2,!0),n.set(t+3,!1)},n.wbg.__wbindgen_memory=function(){return W.memory},n.wbg.__wbindgen_throw=function(n,t){throw new Error(en(n,t))},n}();("string"==typeof n||"function"==typeof Request&&n instanceof Request||"function"==typeof URL&&n instanceof URL)&&(n=fetch(n));const{instance:e,module:A}=await async function(n,t){if("function"==typeof Response&&n instanceof Response){if("function"==typeof WebAssembly.instantiateStreaming)try{return await WebAssembly.instantiateStreaming(n,t)}catch(t){if("application/wasm"==n.headers.get("Content-Type"))throw t;console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",t)}const e=await n.arrayBuffer();return await WebAssembly.instantiate(e,t)}{const e=await WebAssembly.instantiate(n,t);return e instanceof WebAssembly.Instance?{instance:e,module:n}:e}}(await n,t);return function(n,t){return W=n.exports,An.__wbindgen_wasm_module=t,tn=null,W.__wbindgen_start(),W}(e,A)}const sn=-12,an=Math.exp(sn),rn=Math.exp(9),on=Math.exp(-30),cn=2048,ln=2048,un=1,gn=cn-1,hn=ln-1;Symbol.toStringTag;function pn(n){return"bool"===n||"bvec2"===n||"bvec3"===n||"bvec4"===n}function In(n){return"int"===n||"uint"===n||"float"===n}function dn(n){return"int"===n||"ivec2"===n||"ivec3"===n||"ivec4"===n}function Cn(n){return"uint"===n||"uvec2"===n||"uvec3"===n||"uvec4"===n}function Bn(n){return"float"===n||"vec2"===n||"vec3"===n||"vec4"===n}function fn(n){return"mat2"===n||"mat2x2"===n||"mat2x3"===n||"mat2x4"===n||"mat3"===n||"mat3x2"===n||"mat3x3"===n||"mat3x4"===n||"mat4"===n||"mat4x2"===n||"mat4x3"===n||"mat4x4"===n}function En(n){return Bn(n)||fn(n)}function mn(n){return"vec2"===n||"ivec2"===n||"uvec2"===n}function Qn(n){return"vec3"===n||"ivec3"===n||"uvec3"===n}function yn(n){return"vec4"===n||"ivec4"===n||"uvec4"===n}function xn(n){return"mat2"===n||"mat2x2"===n}function wn(n){return"mat3"===n||"mat3x3"===n}function bn(n){return"mat4"===n||"mat4x4"===n}function vn(n){switch(n){case"vec2":case"vec3":case"vec4":return"float";case"ivec2":case"ivec3":case"ivec4":return"int";case"uvec2":case"uvec3":case"uvec4":return"uint";default:throw new Error(`Invalid vector type: ${n}`)}}function Sn(n){switch(n){case"vec2":case"ivec2":case"uvec2":return 2;case"vec3":case"ivec3":case"uvec3":return 3;case"vec4":case"ivec4":case"uvec4":return 4;default:throw new Error(`Invalid vector type: ${n}`)}}function Dn(n){if(In(n))return"uint";if(mn(n))return"uvec2";if(Qn(n))return"uvec3";if(yn(n))return"uvec4";throw new Error(`Invalid vector type: ${n}`)}function Mn(n){if("string"==typeof n)return n;if("object"==typeof n&&n.type)return n.type;throw new Error(`Invalid DynoType: ${String(n)}`)}function kn(n){return Math.trunc(n).toString()}function _n(n){return`${Math.max(0,Math.trunc(n)).toString()}u`}function Tn(n){return n===Number.POSITIVE_INFINITY?"INFINITY":n===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(n)?n.toFixed(1):n.toString()}function Fn(n){if(n instanceof Nn)return n.type;return n.dynoOut().type}class Nn{constructor(n){this.__isDynoValue=!0,this.type=n}}class Rn extends Nn{constructor(n,t){super(n.outTypes[t]),this.dyno=n,this.key=t}}class Gn extends Nn{constructor(n,t){super(n),this.literal=t}getLiteral(){return this.literal}}function Un(n,t){return new Gn(n,t)}class Yn extends Gn{constructor(n,t){super(n,""),this.value=t}getLiteral(){const{type:t,value:e}=this;switch(t){case"bool":return e?"true":"false";case"uint":return _n(e);case"int":return kn(e);case"float":return Tn(e);case"bvec2":{const n=e;return`bvec2(${n[0]}, ${n[1]})`}case"uvec2":{if(e instanceof n.Vector2)return`uvec2(${_n(e.x)}, ${_n(e.y)})`;const t=e;return`uvec2(${_n(t[0])}, ${_n(t[1])})`}case"ivec2":{if(e instanceof n.Vector2)return`ivec2(${kn(e.x)}, ${kn(e.y)})`;const t=e;return`ivec2(${kn(t[0])}, ${kn(t[1])})`}case"vec2":{if(e instanceof n.Vector2)return`vec2(${Tn(e.x)}, ${Tn(e.y)})`;const t=e;return`vec2(${Tn(t[0])}, ${Tn(t[1])})`}case"bvec3":{const n=e;return`bvec3(${n[0]}, ${n[1]}, ${n[2]})`}case"uvec3":{if(e instanceof n.Vector3)return`uvec3(${_n(e.x)}, ${_n(e.y)}, ${_n(e.z)})`;const t=e;return`uvec3(${_n(t[0])}, ${_n(t[1])}, ${_n(t[2])})`}case"ivec3":{if(e instanceof n.Vector3)return`ivec3(${kn(e.x)}, ${kn(e.y)}, ${kn(e.z)})`;const t=e;return`ivec3(${kn(t[0])}, ${kn(t[1])}, ${kn(t[2])})`}case"vec3":{if(e instanceof n.Vector3)return`vec3(${Tn(e.x)}, ${Tn(e.y)}, ${Tn(e.z)})`;const t=e;return`vec3(${Tn(t[0])}, ${Tn(t[1])}, ${Tn(t[2])})`}case"bvec4":{const n=e;return`bvec4(${n[0]}, ${n[1]}, ${n[2]}, ${n[3]})`}case"uvec4":{if(e instanceof n.Vector4)return`uvec4(${_n(e.x)}, ${_n(e.y)}, ${_n(e.z)}, ${_n(e.w)})`;const t=e;return`uvec4(${_n(t[0])}, ${_n(t[1])}, ${_n(t[2])}, ${_n(t[3])})`}case"ivec4":{if(e instanceof n.Vector4)return`ivec4(${kn(e.x)}, ${kn(e.y)}, ${kn(e.z)}, ${kn(e.w)})`;const t=e;return`ivec4(${kn(t[0])}, ${kn(t[1])}, ${kn(t[2])}, ${kn(t[3])})`}case"vec4":{if(e instanceof n.Vector4)return`vec4(${Tn(e.x)}, ${Tn(e.y)}, ${Tn(e.z)}, ${Tn(e.w)})`;if(e instanceof n.Quaternion)return`vec4(${Tn(e.x)}, ${Tn(e.y)}, ${Tn(e.z)}, ${Tn(e.w)})`;const t=e;return`vec4(${Tn(t[0])}, ${Tn(t[1])}, ${Tn(t[2])}, ${Tn(t[3])})`}case"mat2":case"mat2x2":{const A=e,s=A instanceof n.Matrix2?A.elements:e,a=new Array(4).fill(0).map(((n,t)=>Tn(s[t])));return`${t}(${a.join(", ")})`}case"mat2x3":{const n=e,A=new Array(6).fill(0).map(((t,e)=>Tn(n[e])));return`${t}(${A.join(", ")})`}case"mat2x4":{const n=e,A=new Array(8).fill(0).map(((t,e)=>Tn(n[e])));return`${t}(${A.join(", ")})`}case"mat3":case"mat3x3":{const A=e,s=A instanceof n.Matrix3?A.elements:e,a=new Array(9).fill(0).map(((n,t)=>Tn(s[t])));return`${t}(${a.join(", ")})`}case"mat3x2":{const n=e,A=new Array(6).fill(0).map(((t,e)=>Tn(n[e])));return`${t}(${A.join(", ")})`}case"mat3x4":{const n=e,A=new Array(12).fill(0).map(((t,e)=>Tn(n[e])));return`${t}(${A.join(", ")})`}case"mat4":case"mat4x4":{const A=e,s=A instanceof n.Matrix4?A.elements:e,a=new Array(16).fill(0).map(((n,t)=>Tn(s[t])));return`${t}(${a.join(", ")})`}case"mat4x2":{const n=e,A=new Array(8).fill(0).map(((t,e)=>Tn(n[e])));return`${t}(${A.join(", ")})`}case"mat4x3":{const n=e,A=new Array(12).fill(0).map(((t,e)=>Tn(n[e])));return`${t}(${A.join(", ")})`}default:throw new Error(`Type not implemented: ${String(t)}`)}}}function qn(n,t){return new Yn(n,t)}function zn(n){const t=String(n);if(pn(n))return`${t}(false)`;if(En(n))return`${t}(0.0)`;if(dn(n))return`${t}(0)`;if(Cn(n))return`${t}(0u)`;throw new Error(`Type not implemented: ${t}`)}const Ln="    ";class Jn{constructor({indent:n}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=Ln,this.indent=n??Ln}nextSequence(){return this.sequence++}}class Hn{constructor({inTypes:n,outTypes:t,inputs:e,update:A,globals:s,statements:a,generate:r}){this.inTypes=n??{},this.outTypes=t??{},this.inputs=e??{},this.update=A,this.globals=s,this.statements=a,this.generate=r??(({inputs:n,outputs:t,compile:e})=>{var A,s;return{globals:null==(A=this.globals)?void 0:A.call(this,{inputs:n,outputs:t,compile:e}),statements:null==(s=this.statements)?void 0:s.call(this,{inputs:n,outputs:t,compile:e})}})}get outputs(){const n={};for(const t in this.outTypes)n[t]=new Rn(this,t);return n}apply(n){return Object.assign(this.inputs,n),this.outputs}compile({inputs:n,outputs:t,compile:e}){const A=[`// ${this.constructor.name}(${Object.values(n).join(", ")}) => (${Object.values(t).join(", ")})`],s=[];for(const n in t){const A=t[n];A&&!e.declares.has(A)&&(e.declares.add(A),s.push(n))}const{globals:a,statements:r,uniforms:i}=this.generate({inputs:n,outputs:t,compile:e});for(const n of a??[])e.globals.add(n);for(const n in i)e.uniforms[n]=i[n];this.update&&e.updaters.push(this.update);for(const n of s){const s=t[n];s&&(e.uniforms[s]||A.push(`${jn(s,this.outTypes[n])};`))}return(null==r?void 0:r.length)&&(A.push("{"),A.push(...r.map((n=>e.indent+n))),A.push("}")),A}}class Kn extends Hn{constructor({inTypes:n,outTypes:t,inputs:e,update:A,globals:s,construct:a}){super({inTypes:n,outTypes:t,inputs:e,update:A,globals:s,generate:n=>this.generateBlock(n)}),this.construct=a}generateBlock({inputs:n,outputs:t,compile:e}){var A,s;const a={},r={};for(const t in n)null!=n[t]&&(a[t]=new Gn(this.inTypes[t],n[t]));for(const n in t)null!=t[n]&&(r[n]=new Nn(this.outTypes[n]));const i={roots:[]},o=this.construct(a,r,i);for(const s of(null==(A=this.globals)?void 0:A.call(this,{inputs:n,outputs:t,compile:e}))??[])e.globals.add(s);const c=[],l=new Map;function u(n,t,A){let s=l.get(n);if(!s){s={sequence:e.nextSequence(),outNames:new Map,newOuts:new Set},l.set(n,s);for(const t in n.inputs){let e=n.inputs[t];for(;e;){if(e instanceof Nn){e instanceof Rn&&u(e.dyno,e.key);break}e=e.dynoOut()}}c.push(n)}t&&(A||s.newOuts.add(t),s.outNames.set(t,A??`${t}_${s.sequence}`))}for(const n of i.roots)u(n);for(const n in r){let e=(null==o?void 0:o[n])??r[n];for(;e;){if(e instanceof Nn){e instanceof Rn&&u(e.dyno,e.key,t[n]);break}e=e.dynoOut()}r[n]=e}const g=[];for(const n of c){const t={},A={};for(const e in n.inputs){let A=n.inputs[e];for(;A;){if(A instanceof Nn){if(A instanceof Gn)t[e]=A.getLiteral();else if(A instanceof Rn){const n=null==(s=l.get(A.dyno))?void 0:s.outNames.get(A.key);if(!n)throw new Error(`Source not found for ${A.dyno.constructor.name}.${A.key}`);t[e]=n}break}A=A.dynoOut()}}const a=l.get(n)??{outNames:new Map};for(const[n,t]of a.outNames.entries())A[n]=t;const r=n.compile({inputs:t,outputs:A,compile:e});g.push(r)}const h=[];for(const n in t)r[n]instanceof Gn&&h.push(`${t[n]} = ${r[n].getLiteral()};`);h.length>0&&g.push(h);return{statements:g.flatMap(((n,t)=>0===t?n:["",...n]))}}}function Vn(n,t,e,{update:A,globals:s}={}){return new Kn({inTypes:n,outTypes:t,construct:e,update:A,globals:s})}function $n({inTypes:n,outTypes:t,inputs:e,update:A,globals:s,statements:a,generate:r}){return new Hn({inTypes:n,outTypes:t,inputs:e,update:A,globals:s,statements:a,generate:r})}function jn(n,t,e){const A="string"==typeof t?t:t.type;if(!A)throw new Error(`Invalid DynoType: ${String(t)}`);return`${A} ${n}${null!=e?`[${e}]`:""}`}function Zn(n){var t;let e=!1;const A=n.split("\n").map((n=>{const t=n.trimEnd();return e?t:t.length>0?(e=!0,t):null})).filter((n=>null!=n));for(;A.length>0&&0===A[A.length-1].length;)A.pop();if(0===A.length)return[];const s=null==(t=A[0].match(/^\s*/))?void 0:t[0];if(!s)return A;const a=new RegExp(`^${s}`);return A.map((n=>n.replace(a,"")))}function Xn(n){return Zn(n).join("\n")}class On extends Hn{constructor({a:n,outKey:t,outTypeFunc:e}){super({inTypes:{a:Fn(n)},outTypes:{[t]:e(Fn(n))},inputs:{a:n}}),this.outKey=t}dynoOut(){return new Rn(this,this.outKey)}}class Pn extends Hn{constructor({a:n,b:t,outKey:e,outTypeFunc:A}){super({inTypes:{a:Fn(n),b:Fn(t)},outTypes:{[e]:A(Fn(n),Fn(t))},inputs:{a:n,b:t}}),this.outKey=e}dynoOut(){return new Rn(this,this.outKey)}}class Wn extends Hn{constructor({a:n,b:t,c:e,outKey:A,outTypeFunc:s}){super({inTypes:{a:Fn(n),b:Fn(t),c:Fn(e)},outTypes:{[A]:s(Fn(n),Fn(t),Fn(e))},inputs:{a:n,b:t,c:e}}),this.outKey=A}dynoOut(){return new Rn(this,this.outKey)}}const nt={type:"Gsplat"},tt={type:"PackedSplats"},et=(n,t)=>new gt({packedSplats:n,index:t}),At=(n,t,e,A)=>new ht({packedSplats:n,index:t,base:e,count:A}),st=n=>new pt({gsplat:n}),at=({gsplat:n,flags:t,index:e,center:A,scales:s,quaternion:a,rgba:r,rgb:i,opacity:o,x:c,y:l,z:u,r:g,g:h,b:p})=>new It({gsplat:n,flags:t,index:e,center:A,scales:s,quaternion:a,rgba:r,rgb:i,opacity:o,x:c,y:l,z:u,r:g,g:h,b:p}),rt=n=>new Ct({gsplat:n}),it=(n,{scale:t,rotate:e,translate:A,recolor:s})=>new Bt({gsplat:n,scale:t,rotate:e,translate:A,recolor:s}),ot=Xn("\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n"),ct=Xn("\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n    vec4 rgbMinMaxLnScaleMinMax;\n  };\n");class lt extends On{constructor({packedSplats:n}){super({a:n,outKey:"numSplats",outTypeFunc:()=>"int"}),this.statements=({inputs:n,outputs:t})=>[`${t.numSplats} = ${n.a}.numSplats;`]}}const ut=Xn("\n  bool readPackedSplat(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);\n      return true;\n    } else {\n      return false;\n    }\n  }\n");class gt extends Hn{constructor({packedSplats:n,index:t}){super({inTypes:{packedSplats:tt,index:"int"},outTypes:{gsplat:nt},inputs:{packedSplats:n,index:t},globals:()=>[ot,ct,ut],statements:({inputs:n,outputs:t})=>{const{gsplat:e}=t;if(!e)return[];const{packedSplats:A,index:s}=n;let a;return a=A&&s?Zn(`\n            if (readPackedSplat(${A}.texture, ${A}.numSplats, ${A}.rgbMinMaxLnScaleMinMax, ${s}, ${e})) {\n              bool zeroSize = all(equal(${e}.scales, vec3(0.0, 0.0, 0.0)));\n              ${e}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${e}.flags = 0u;\n            }\n          `):[`${e}.flags = 0u;`],a.push(`${e}.index = ${s??"0"};`),a}})}dynoOut(){return new Rn(this,"gsplat")}}class ht extends Hn{constructor({packedSplats:n,index:t,base:e,count:A}){super({inTypes:{packedSplats:tt,index:"int",base:"int",count:"int"},outTypes:{gsplat:nt},inputs:{packedSplats:n,index:t,base:e,count:A},globals:()=>[ot,ct,ut],statements:({inputs:n,outputs:t})=>{const{gsplat:e}=t;if(!e)return[];const{packedSplats:A,index:s,base:a,count:r}=n;let i;return i=A&&s&&a&&r?Zn(`\n            ${e}.flags = 0u;\n            if ((${s} >= ${a}) && (${s} < (${a} + ${r}))) {\n              if (readPackedSplat(${A}.texture, ${A}.numSplats, ${A}.rgbMinMaxLnScaleMinMax, ${s}, ${e})) {\n                bool zeroSize = all(equal(${e}.scales, vec3(0.0, 0.0, 0.0)));\n                ${e}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `):[`${e}.flags = 0u;`],i.push(`${e}.index = ${s??"0"};`),i}})}dynoOut(){return new Rn(this,"gsplat")}}class pt extends Hn{constructor({gsplat:n}){super({inTypes:{gsplat:nt},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:n},globals:()=>[ot],statements:({inputs:n,outputs:t})=>{const{gsplat:e}=n,{flags:A,active:s,index:a,center:r,scales:i,quaternion:o,rgba:c,rgb:l,opacity:u,x:g,y:h,z:p,r:I,g:d,b:C}=t;return[A?`${A} = ${e?`${e}.flags`:"0u"};`:null,s?`${s} = isGsplatActive(${e?`${e}.flags`:"0u"});`:null,a?`${a} = ${e?`${e}.index`:"0"};`:null,r?`${r} = ${e?`${e}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,i?`${i} = ${e?`${e}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,o?`${o} = ${e?`${e}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,c?`${c} = ${e?`${e}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,l?`${l} = ${e?`${e}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,u?`${u} = ${e?`${e}.rgba.a`:"0.0"};`:null,g?`${g} = ${e?`${e}.center.x`:"0.0"};`:null,h?`${h} = ${e?`${e}.center.y`:"0.0"};`:null,p?`${p} = ${e?`${e}.center.z`:"0.0"};`:null,I?`${I} = ${e?`${e}.rgba.r`:"0.0"};`:null,d?`${d} = ${e?`${e}.rgba.g`:"0.0"};`:null,C?`${C} = ${e?`${e}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class It extends Hn{constructor({gsplat:n,flags:t,index:e,center:A,scales:s,quaternion:a,rgba:r,rgb:i,opacity:o,x:c,y:l,z:u,r:g,g:h,b:p}){super({inTypes:{gsplat:nt,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:nt},inputs:{gsplat:n,flags:t,index:e,center:A,scales:s,quaternion:a,rgba:r,rgb:i,opacity:o,x:c,y:l,z:u,r:g,g:h,b:p},globals:()=>[ot],statements:({inputs:n,outputs:t})=>{const{gsplat:e}=t;if(!e)return[];const{gsplat:A,flags:s,index:a,center:r,scales:i,quaternion:o,rgba:c,rgb:l,opacity:u,x:g,y:h,z:p,r:I,g:d,b:C}=n;return[`${e}.flags = ${s??(A?`${A}.flags`:"0u")};`,`${e}.index = ${a??(A?`${A}.index`:"0")};`,`${e}.center = ${r??(A?`${A}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${e}.scales = ${i??(A?`${A}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${e}.quaternion = ${o??(A?`${A}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${e}.rgba = ${c??(A?`${A}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,l?`${e}.rgba.rgb = ${l};`:null,u?`${e}.rgba.a = ${u};`:null,g?`${e}.center.x = ${g};`:null,h?`${e}.center.y = ${h};`:null,p?`${e}.center.z = ${p};`:null,I?`${e}.rgba.r = ${I};`:null,d?`${e}.rgba.g = ${d};`:null,C?`${e}.rgba.b = ${C};`:null].filter(Boolean)}})}dynoOut(){return new Rn(this,"gsplat")}}const dt=Xn("\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n");class Ct extends On{constructor({gsplat:n}){super({a:n,outKey:"normal",outTypeFunc:()=>"vec3"}),this.globals=()=>[ot,dt],this.statements=({inputs:n,outputs:t})=>[`${t.normal} = gsplatNormal(${n.a}.scales, ${n.a}.quaternion);`]}}class Bt extends Hn{constructor({gsplat:n,scale:t,rotate:e,translate:A,recolor:s}){super({inTypes:{gsplat:nt,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:nt},inputs:{gsplat:n,scale:t,rotate:e,translate:A,recolor:s},globals:()=>[ot],statements:({inputs:n,outputs:t,compile:e})=>{const{gsplat:A}=t;if(!A||!n.gsplat)return[];const{scale:s,rotate:a,translate:r,recolor:i}=n,o=e.indent;return[`${A} = ${n.gsplat};`,`if (isGsplatActive(${A}.flags)) {`,s?`${o}${A}.center *= ${s};`:null,a?`${o}${A}.center = quatVec(${a}, ${A}.center);`:null,r?`${o}${A}.center += ${r};`:null,s?`${o}${A}.scales *= ${s};`:null,a?`${o}${A}.quaternion = quatQuat(${a}, ${A}.quaternion);`:null,i?`${o}${A}.rgba *= ${i};`:null,"}"].filter(Boolean)}})}dynoOut(){return new Rn(this,"gsplat")}}const ft=(n,t)=>new Et({gsplat:n,rgbMinMaxLnScaleMinMax:t});class Et extends Hn{constructor({gsplat:n,rgbMinMaxLnScaleMinMax:t}){super({inTypes:{gsplat:nt,rgbMinMaxLnScaleMinMax:"vec4"},inputs:{gsplat:n,rgbMinMaxLnScaleMinMax:t},globals:()=>[ot],statements:({inputs:n,outputs:t})=>{const{output:e}=t;if(!e)return[];const{gsplat:A,rgbMinMaxLnScaleMinMax:s}=n;return A?Zn(`\n            if (isGsplatActive(${A}.flags)) {\n              ${e} = packSplatEncoding(${A}.center, ${A}.scales, ${A}.quaternion, ${A}.rgba, ${s});\n            } else {\n              ${e} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `):[`${e} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new Rn(this,"output")}}class mt extends Hn{constructor({rgba8:n}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:n},statements:({inputs:n,outputs:t})=>[`target = ${n.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new Rn(this,"rgba8")}}const Qt=(n=0,t)=>new St({key:t,value:n}),yt=(n,t)=>new Rt({key:t,value:n});class xt extends Hn{constructor({key:n,type:t,count:e,value:A,update:s,globals:a}){super({outTypes:{[n=n??"value"]:t},update:()=>{if(s){const n=s(this.value);void 0!==n&&(this.value=n)}this.uniform.value=this.value},generate:({inputs:A,outputs:s})=>{const r=(null==a?void 0:a({inputs:A,outputs:s}))??[],i={},o=s[n];return o&&(r.push(`uniform ${jn(o,t,e)};`),i[o]=this.uniform),{globals:r,uniforms:i}}}),this.type=t,this.count=e,this.value=A,this.uniform={value:A},this.outKey=n}dynoOut(){return new Rn(this,this.outKey)}}class wt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"bool",value:t,update:e})}}class bt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"uint",value:t,update:e})}}class vt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"int",value:t,update:e})}}class St extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"float",value:t,update:e})}}class Dt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"bvec2",value:t,update:e})}}class Mt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"uvec2",value:t,update:e})}}class kt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"ivec2",value:t,update:e})}}class _t extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"vec2",value:t,update:e})}}class Tt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"bvec3",value:t,update:e})}}class Ft extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"uvec3",value:t,update:e})}}class Nt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"ivec3",value:t,update:e})}}class Rt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"vec3",value:t,update:e})}}class Gt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"bvec4",value:t,update:e})}}class Ut extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"uvec4",value:t,update:e})}}class Yt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"ivec4",value:t,update:e})}}class qt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"vec4",value:t,update:e})}}class zt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat2",value:t,update:e})}}class Lt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat2x2",value:t,update:e})}}class Jt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat2x3",value:t,update:e})}}class Ht extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat2x4",value:t,update:e})}}class Kt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat3",value:t,update:e})}}class Vt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat3x2",value:t,update:e})}}class $t extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat3x3",value:t,update:e})}}class jt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat3x4",value:t,update:e})}}class Zt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat4",value:t,update:e})}}class Xt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat4x2",value:t,update:e})}}class Ot extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat4x3",value:t,update:e})}}class Pt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"mat4x4",value:t,update:e})}}class Wt extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"usampler2D",value:t,update:e})}}class ne extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"isampler2D",value:t,update:e})}}class te extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"sampler2D",value:t,update:e})}}class ee extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"usampler2DArray",value:t,update:e})}}class Ae extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"isampler2DArray",value:t,update:e})}}class se extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"sampler2DArray",value:t,update:e})}}class ae extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"usampler3D",value:t,update:e})}}class re extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"isampler3D",value:t,update:e})}}class ie extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"sampler3D",value:t,update:e})}}class oe extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"usamplerCube",value:t,update:e})}}class ce extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"isamplerCube",value:t,update:e})}}class le extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"samplerCube",value:t,update:e})}}class ue extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"sampler2DShadow",value:t,update:e})}}class ge extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"sampler2DArrayShadow",value:t,update:e})}}class he extends xt{constructor({key:n,value:t,update:e}){super({key:n,type:"samplerCubeShadow",value:t,update:e})}}const pe=new Float32Array(1),Ie=new Uint32Array(pe.buffer),de="Float16Array"in globalThis,Ce=de?new globalThis.Float16Array(1):null,Be=new Uint16Array(null==Ce?void 0:Ce.buffer);function fe(n){const t=Math.sqrt(n.reduce(((n,t)=>n+t*t),0));return n.map((n=>n/t))}const Ee=de?function(n){return Ce[0]=n,Be[0]}:function(n){pe[0]=n;const t=Ie[0],e=t>>23&255,A=8388607&t,s=(t>>31&1)<<15;if(255===e)return 0!==A?32767|s:31744|s;const a=e-127+15;if(a>=31)return 31744|s;if(a<=0){if(a<-10)return s;return s|(8388608|A)>>1-a+13}return s|a<<10|A>>13},me=de?function(n){return Be[0]=n,Ce[0]}:function(n){const t=n>>15&1,e=n>>10&31,A=1023&n;let s;if(0===e)if(0===A)s=t<<31;else{let n=A,e=-14;for(;0==(1024&n);)n<<=1,e--;n&=1023;s=t<<31|e+127<<23|n<<13}else if(31===e)s=0===A?t<<31|2139095040:t<<31|2143289344;else{s=t<<31|e-15+127<<23|A<<13}return Ie[0]=s,pe[0]};function Qe(n){return Math.max(0,Math.min(255,Math.round(255*n)))}function ye(n){return Math.max(-127,Math.min(127,Math.round(127*n)))}function xe(n){const t=[],e=new Set;return function n(A){A&&"object"==typeof A&&!e.has(A)&&(e.add(A),A instanceof ArrayBuffer?t.push(A):ArrayBuffer.isView(A)?t.push(A.buffer):Array.isArray(A)?A.forEach(n):Object.values(A).forEach(n))}(n),t}class we{constructor({allocate:n,dispose:t,valid:e}){this.items=[],this.allocate=n,this.dispose=t,this.valid=e}alloc(n){for(;;){const t=this.items.pop();if(!t)break;if(this.valid(t,n))return t;this.dispose&&this.dispose(t)}return this.allocate(n)}free(n){this.items.push(n)}disposeAll(){let n;for(n=this.items.pop();n;)this.dispose&&this.dispose(n),n=this.items.pop()}}function be(n,t,e,A,s,a,r,i,o,c,l,u,g,h,p,I,d){const C=(null==d?void 0:d.rgbMin)??0,B=((null==d?void 0:d.rgbMax)??1)-C,f=Qe((h-C)/B),E=Qe((p-C)/B),m=Qe((I-C)/B),Q=Qe(g),y=qe(ve.set(o,c,l,u)),x=255&y,w=y>>>8&255,b=y>>>16&255,v=(null==d?void 0:d.lnScaleMin)??sn,S=254/(((null==d?void 0:d.lnScaleMax)??9)-v),D=a<on?0:Math.min(255,Math.max(1,Math.round((Math.log(a)-v)*S)+1)),M=r<on?0:Math.min(255,Math.max(1,Math.round((Math.log(r)-v)*S)+1)),k=i<on?0:Math.min(255,Math.max(1,Math.round((Math.log(i)-v)*S)+1)),_=Ee(e),T=Ee(A),F=Ee(s),N=4*t;n[N]=f|E<<8|m<<16|Q<<24,n[N+1]=_|T<<16,n[N+2]=F|x<<16|w<<24,n[N+3]=D|M<<8|k<<16|b<<24}const ve=new n.Quaternion;const Se={center:new n.Vector3,scales:new n.Vector3,quaternion:new n.Quaternion,color:new n.Color,opacity:0};function De(n,t,e){const A=Se,s=4*t,a=n[s],r=n[s+1],i=n[s+2],o=n[s+3],c=(null==e?void 0:e.rgbMin)??0,l=((null==e?void 0:e.rgbMax)??1)-c;A.color.set(c+(255&a)/255*l,c+(a>>>8&255)/255*l,c+(a>>>16&255)/255*l),A.opacity=(a>>>24&255)/255,A.center.set(me(65535&r),me(r>>>16&65535),me(65535&i));const u=(null==e?void 0:e.lnScaleMin)??sn,g=(((null==e?void 0:e.lnScaleMax)??9)-u)/254,h=255&o;A.scales.x=0===h?0:Math.exp(u+(h-1)*g);const p=o>>>8&255;A.scales.y=0===p?0:Math.exp(u+(p-1)*g);const I=o>>>16&255;A.scales.z=0===I?0:Math.exp(u+(I-1)*g);return ze(i>>>16&65535|o>>>8&16711680,A.quaternion),A}function Me(n){const t=cn,e=Math.max(un,Math.min(ln,Math.ceil(n/t))),A=Math.ceil(n/(t*e));return{width:t,height:e,depth:A,maxSplats:t*e*A}}function ke(t){const e=new n.Clock(t.autoStart);return e.startTime=t.startTime,e.oldTime=t.oldTime,e.elapsedTime=t.elapsedTime,e.running=t.running,e}const _e=Xn("\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n");function Te(t){const e=new n.Vector3;for(const n of t)e.add(n);return e.divideScalar(t.length)}function Fe(t){if(0===t.length)return new n.Quaternion;const e=t[0].clone();for(let n=1;n<t.length;n++)t[n].dot(t[0])<0?(e.x-=t[n].x,e.y-=t[n].y,e.z-=t[n].z,e.w-=t[n].w):(e.x+=t[n].x,e.y+=t[n].y,e.z+=t[n].z,e.w+=t[n].w);return e.normalize()}function Ne(t,e){const A=new n.Vector3(0,0,0).applyMatrix4(t),s=new n.Vector3(0,0,0).applyMatrix4(e),a=new n.Vector3(0,0,-1).applyMatrix4(t).sub(A).normalize(),r=new n.Vector3(0,0,-1).applyMatrix4(e).sub(s).normalize();return{distance:A.distanceTo(s),coincidence:a.dot(r)}}function Re(t,e){const[A,s]=[new n.Vector3,new n.Quaternion],[a,r]=[new n.Vector3,new n.Quaternion];t.decompose(A,s,new n.Vector3),e.decompose(a,r,new n.Vector3);return{distance:A.distanceTo(a),coorient:Math.abs(s.dot(r))}}function Ge({matrix1:n,matrix2:t,maxDistance:e,minCoorient:A}){const{distance:s,coorient:a}=Re(n,t);return s<=e&&(null==A||a>=A)}const Ue=new n.Quaternion,Ye=new n.Vector3;function qe(n){const t=Ue.copy(n).normalize();t.w<0&&t.set(-t.x,-t.y,-t.z,-t.w);const e=2*Math.acos(t.w),A=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z),s=A<1e-6?Ye.set(1,0,0):Ye.set(t.x,t.y,t.z).divideScalar(A),a=Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z);let r=s.x/a,i=s.y/a;if(s.z<0){const n=r;r=(1-Math.abs(i))*(r>=0?1:-1),i=(1-Math.abs(n))*(i>=0?1:-1)}const o=.5*r+.5,c=.5*i+.5,l=Math.round(255*o),u=Math.round(255*c);return Math.round(e*(255/Math.PI))<<16|u<<8|l}function ze(n,t){const e=n>>>16&255;let A=2*((255&n)/255-.5),s=2*((n>>>8&255)/255-.5);const a=1-(Math.abs(A)+Math.abs(s)),r=Math.max(-a,0);A+=A>=0?-r:r,s+=s>=0?-r:r;const i=Ye.set(A,s,a).normalize(),o=.5*(e/255*Math.PI),c=Math.sin(o),l=Math.cos(o);return t.set(i.x*c,i.y*c,i.z*c,l),t}function Le(n,t,e,A){return 255&Math.max(-127,Math.min(127,127*n))|(255&Math.max(-127,Math.min(127,127*t)))<<8|(255&Math.max(-127,Math.min(127,127*e)))<<16|(255&Math.max(-127,Math.min(127,127*A)))<<24}function Je(n,t){const e=[];let A=0,s=null;const a=new $(((n,a)=>{if(e.push(n),A+=n.length,a||A>=t){const n=new Uint8Array(A);let a=0;for(const t of e)n.set(t,a),a+=t.length;s=n.slice(0,t)}}));let r=0;for(;null==s&&r<n.length;){const t=n.slice(r,r+1024);a.push(t,!1),r+=1024}if(null==s&&(a.push(new Uint8Array,!0),null==s))throw new Error("Failed to decompress partial gzip");return s}class He{constructor({fileBytes:n,chunkBytes:t=65536}){this.fileBytes=n,this.chunkBytes=t,this.chunks=[],this.totalBytes=0;const e=new DecompressionStream("gzip"),A=new Blob([n]).stream().pipeThrough(e);this.reader=A.getReader()}async read(n){for(;this.totalBytes<n;){const{value:n,done:t}=await this.reader.read();if(t)break;this.chunks.push(n),this.totalBytes+=n.length}if(this.totalBytes<n)throw new Error(`Unexpected EOF: needed ${n}, got ${this.totalBytes}`);const t=new Uint8Array(this.totalBytes);let e=0;for(const n of this.chunks)t.set(n,e),e+=n.length;const A=t.subarray(0,n);return this.chunks=[t.subarray(n)],this.totalBytes-=n,A}}Symbol.toStringTag;class Ke{constructor({graph:n,inputs:t,outputs:e,template:A}){this.graph=n,this.template=A,this.inputs=t??{},this.outputs=e??{};const s=new Jn({indent:this.template.indent});for(const n in this.outputs)this.outputs[n]&&s.declares.add(this.outputs[n]);const a=n.compile({inputs:this.inputs,outputs:this.outputs,compile:s});this.shader=A.generate({globals:s.globals,statements:a}),this.uniforms=s.uniforms,this.updaters=s.updaters}prepareMaterial(){return function(t){let e=$e.get(t);if(e)return e;return e=new n.RawShaderMaterial({glslVersion:n.GLSL3,vertexShader:_e,fragmentShader:t.shader,uniforms:t.uniforms}),$e.set(t,e),e}(this)}update(){for(const n of this.updaters)n()}}class Ve{constructor(n){const t=n.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m),e=n.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);if(!t||!e)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=n.substring(0,t.index),this.between=n.substring(t.index+t[0].length,e.index),this.after=n.substring(e.index+e[0].length),this.indent=e[1]}generate({globals:n,statements:t}){return this.before+Array.from(n).join("\n\n")+this.between+t.map((n=>this.indent+n)).join("\n")+this.after}}const $e=new Map;function je(n,t,e="add"){const A=()=>{throw new Error(`Invalid ${e} types: ${n}, ${t}`)};if(n===t)return n;if("int"===n){if(dn(t))return t;A()}if("int"===t){if(dn(n))return n;A()}if("uint"===n){if(Cn(t))return t;A()}if("uint"===t){if(Cn(n))return n;A()}if("float"===n){if(En(t))return t;A()}if("float"===t){if(En(n))return n;A()}throw new Error(`Invalid ${e} types: ${n}, ${t}`)}function Ze(n,t){return je(n,t,"sub")}function Xe(n,t){const e=()=>{throw new Error(`Invalid mul types: ${n}, ${t}`)};if("int"===n){if(dn(t))return t;e()}if("int"===t){if(dn(n))return n;e()}if("uint"===n){if(Cn(t))return t;e()}if("uint"===t){if(Cn(n))return n;e()}if("float"===n){if(En(t))return t;e()}if("float"===t){if(En(n))return n;e()}if(dn(n)||Cn(n)||dn(t)||Cn(t)){if(n===t)return n;e()}if("vec2"===n){if("vec2"===t||xn(t))return"vec2";if("mat3x2"===t)return"vec3";if("mat4x2"===t)return"vec4";e()}if("vec3"===n){if("mat2x3"===t)return"vec2";if("vec3"===t||wn(t))return"vec3";if("mat4x3"===t)return"vec4";e()}if("vec4"===n){if("mat2x4"===t)return"vec2";if("mat3x4"===t)return"vec3";if("vec4"===t||bn(t))return"vec4";e()}if("vec2"===t){if(xn(n))return"vec2";if("mat2x3"===n)return"vec3";if("mat2x4"===n)return"vec4";e()}if("vec3"===t){if("mat3x2"===n)return"vec2";if(wn(n))return"vec3";if("mat3x4"===n)return"vec4";e()}if("vec4"===t){if("mat4x2"===n)return"vec2";if("mat4x3"===n)return"vec3";if(bn(n))return"vec4";e()}if(xn(n)){if(xn(t))return"mat2";if("mat3x2"===t)return"mat3x2";if("mat4x2"===t)return"mat4x2";e()}if("mat2x3"===n){if(xn(t))return"mat2x3";if("mat3x2"===t)return"mat3";if("mat4x2"===t)return"mat4x3";e()}if("mat2x4"===n){if(xn(t))return"mat2x4";if("mat3x2"===t)return"mat3x4";if("mat4x2"===t)return"mat4";e()}if("mat3x2"===n){if("mat2x3"===t)return"mat2";if(wn(t))return"mat3x2";if("mat4x3"===t)return"mat4x2";e()}if(wn(n)){if("mat2x3"===t)return"mat2x3";if(wn(t))return"mat3";if("mat4x3"===t)return"mat4x3";e()}if("mat3x4"===n){if("mat2x3"===t)return"mat2x4";if(wn(t))return"mat3x4";if("mat4x3"===t)return"mat4";e()}if("mat4x2"===n){if("mat2x4"===t)return"mat2";if("mat3x4"===t)return"mat3x2";if(bn(t))return"mat4x2";e()}if("mat4x3"===n){if("mat2x4"===t)return"mat2x3";if("mat3x4"===t)return"mat3";if(bn(t))return"mat4x3";e()}if(bn(n)){if("mat2x4"===t)return"mat2x4";if("mat3x4"===t)return"mat3x4";if(bn(t))return"mat4";e()}throw new Error(`Invalid mul types: ${n}, ${t}`)}function Oe(n,t){return je(n,t,"div")}function Pe(n,t){if(n===t)return n;if("int"===n){if(dn(t))return t}else if("int"===t){if(dn(n))return n}else if("uint"===n){if(Cn(t))return t}else if("uint"===t&&Cn(n))return n;throw new Error(`Invalid imod types: ${n}, ${t}`)}function We(n,t){if(n===t||"float"===t)return n;throw new Error(`Invalid mod types: ${n}, ${t}`)}function nA(n){return n}function tA(n){return n}function eA(n){return n}function AA(n){return n}function sA(n){return n}function aA(n){return n}function rA(n){return n}function iA(n){return n}function oA(n){return n}function cA(n){return n}function lA(n){return n}function uA(n){return n}function gA(n){return n}function hA(n){return n}function pA(n){return n}function IA(n){return n}function dA(n,t,e="min"){if(n===t)return n;if("float"===t){if(Bn(n))return n}else if("int"===t){if(dn(n))return n}else if("uint"===t&&Cn(n))return n;throw new Error(`Invalid ${e} types: ${n}, ${t}`)}function CA(n,t){return dA(n,t,"max")}function BA(n,t,e){if("float"===t){if(Bn(n))return n}else if("int"===t){if(dn(n))return n}else if("uint"===t&&Cn(n))return n;throw new Error(`Invalid clamp types: ${n}, ${t}`)}function fA(n,t,e){if(e===n)return n;if("float"===e)return n;if("bool"===e&&"float"===n)return n;if("bvec2"===e&&"vec2"===n)return n;if("bvec3"===e&&"vec3"===n)return n;if("bvec4"===e&&"vec4"===n)return n;throw new Error(`Invalid mix types: ${n}, ${t}, ${e}`)}function EA(n,t){if(n===t||"float"===t)return t;throw new Error(`Invalid step types: ${n}, ${t}`)}function mA(n,t,e){if(n===t&&(n===e||"float"===n))return e;throw new Error(`Invalid smoothstep types: ${n}, ${t}, ${e}`)}function QA(n,t="isNan"){if("float"===n)return"bool";if("vec2"===n)return"bvec2";if("vec3"===n)return"bvec3";if("vec4"===n)return"bvec4";throw new Error(`Invalid ${t} types: ${n}`)}function yA(n){return QA(n,"isInf")}const xA=(n,t)=>new FA({a:n,b:t}),wA=(n,t)=>new NA({a:n,b:t}),bA=(n,t)=>new RA({a:n,b:t}),vA=(n,t)=>new GA({a:n,b:t}),SA=(n,t)=>new UA({a:n,b:t}),DA=(n,t)=>new YA({a:n,b:t}),MA=n=>new zA({a:n}),kA=n=>new jA({a:n}),_A=(n,t)=>new ss({a:n,b:t}),TA=(n,t,e)=>new rs({a:n,b:t,t:e});class FA extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"sum",outTypeFunc:je}),this.statements=({inputs:n,outputs:t})=>[`${t.sum} = ${n.a} + ${n.b};`]}}class NA extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"difference",outTypeFunc:Ze}),this.statements=({inputs:n,outputs:t})=>[`${t.difference} = ${n.a} - ${n.b};`]}}class RA extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"product",outTypeFunc:Xe}),this.statements=({inputs:n,outputs:t})=>[`${t.product} = ${n.a} * ${n.b};`]}}class GA extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"quotient",outTypeFunc:Oe}),this.statements=({inputs:n,outputs:t})=>[`${t.quotient} = ${n.a} / ${n.b};`]}}class UA extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"remainder",outTypeFunc:Pe}),this.statements=({inputs:n,outputs:t})=>[`${t.remainder} = ${n.a} % ${n.b};`]}}class YA extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"remainder",outTypeFunc:We}),this.statements=({inputs:n,outputs:t})=>[`${t.remainder} = mod(${n.a}, ${n.b});`]}}class qA extends Hn{constructor({a:n}){const t={a:Fn(n)},e=t.a;super({inTypes:t,outTypes:{fract:e,integer:e},inputs:{a:n}}),this.statements=({inputs:n,outputs:t})=>[`${t.fract} = modf(${n.a}, ${t.integer});`]}}class zA extends On{constructor({a:n}){super({a:n,outKey:"neg",outTypeFunc:nA}),this.statements=({inputs:n,outputs:t})=>[`${t.neg} = -${n.a};`]}}class LA extends On{constructor({a:n}){super({a:n,outKey:"abs",outTypeFunc:tA}),this.statements=({inputs:n,outputs:t})=>[`${t.abs} = abs(${n.a});`]}}class JA extends On{constructor({a:n}){super({a:n,outKey:"sign",outTypeFunc:eA}),this.statements=({inputs:n,outputs:t})=>[`${t.sign} = sign(${n.a});`]}}class HA extends On{constructor({a:n}){super({a:n,outKey:"floor",outTypeFunc:AA}),this.statements=({inputs:n,outputs:t})=>[`${t.floor} = floor(${n.a});`]}}class KA extends On{constructor({a:n}){super({a:n,outKey:"ceil",outTypeFunc:sA}),this.statements=({inputs:n,outputs:t})=>[`${t.ceil} = ceil(${n.a});`]}}class VA extends On{constructor({a:n}){super({a:n,outKey:"trunc",outTypeFunc:aA}),this.statements=({inputs:n,outputs:t})=>[`${t.trunc} = trunc(${n.a});`]}}class $A extends On{constructor({a:n}){super({a:n,outKey:"round",outTypeFunc:rA}),this.statements=({inputs:n,outputs:t})=>[`${t.round} = round(${n.a});`]}}class jA extends On{constructor({a:n}){super({a:n,outKey:"fract",outTypeFunc:iA}),this.statements=({inputs:n,outputs:t})=>[`${t.fract} = fract(${n.a});`]}}class ZA extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"power",outTypeFunc:oA}),this.statements=({inputs:n,outputs:t})=>[`${t.power} = pow(${n.a}, ${n.b});`]}}class XA extends On{constructor({a:n}){super({a:n,outKey:"exp",outTypeFunc:cA}),this.statements=({inputs:n,outputs:t})=>[`${t.exp} = exp(${n.a});`]}}class OA extends On{constructor({a:n}){super({a:n,outKey:"exp2",outTypeFunc:lA}),this.statements=({inputs:n,outputs:t})=>[`${t.exp2} = exp2(${n.a});`]}}class PA extends On{constructor({a:n}){super({a:n,outKey:"log",outTypeFunc:uA}),this.statements=({inputs:n,outputs:t})=>[`${t.log} = log(${n.a});`]}}class WA extends On{constructor({a:n}){super({a:n,outKey:"log2",outTypeFunc:gA}),this.statements=({inputs:n,outputs:t})=>[`${t.log2} = log2(${n.a});`]}}class ns extends On{constructor({a:n}){super({a:n,outKey:"sqr",outTypeFunc:hA}),this.statements=({inputs:n,outputs:t})=>[`${t.sqr} = ${n.a} * ${n.a};`]}}class ts extends On{constructor({a:n}){super({a:n,outKey:"sqrt",outTypeFunc:pA}),this.statements=({inputs:n,outputs:t})=>[`${t.sqrt} = sqrt(${n.a});`]}}class es extends On{constructor({a:n}){super({a:n,outKey:"inversesqrt",outTypeFunc:IA}),this.statements=({inputs:n,outputs:t})=>[`${t.inversesqrt} = inversesqrt(${n.a});`]}}class As extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"min",outTypeFunc:dA}),this.statements=({inputs:n,outputs:t})=>[`${t.min} = min(${n.a}, ${n.b});`]}}class ss extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"max",outTypeFunc:CA}),this.statements=({inputs:n,outputs:t})=>[`${t.max} = max(${n.a}, ${n.b});`]}}class as extends Wn{constructor({a:n,min:t,max:e}){super({a:n,b:t,c:e,outKey:"clamp",outTypeFunc:BA}),this.statements=({inputs:n,outputs:t})=>{const{a:e,b:A,c:s}=n;return[`${t.clamp} = clamp(${e}, ${A}, ${s});`]}}}class rs extends Wn{constructor({a:n,b:t,t:e}){super({a:n,b:t,c:e,outKey:"mix",outTypeFunc:fA}),this.statements=({inputs:n,outputs:t})=>{const{a:e,b:A,c:s}=n;return[`${t.mix} = mix(${e}, ${A}, ${s});`]}}}class is extends Pn{constructor({edge:n,x:t}){super({a:n,b:t,outKey:"step",outTypeFunc:EA}),this.statements=({inputs:n,outputs:t})=>{const{a:e,b:A}=n;return[`${t.step} = step(${e}, ${A});`]}}}class os extends Wn{constructor({edge0:n,edge1:t,x:e}){super({a:n,b:t,c:e,outKey:"smoothstep",outTypeFunc:mA}),this.statements=({inputs:n,outputs:t})=>{const{a:e,b:A,c:s}=n;return[`${t.smoothstep} = smoothstep(${e}, ${A}, ${s});`]}}}class cs extends On{constructor({a:n}){super({a:n,outKey:"isNan",outTypeFunc:QA}),this.statements=({inputs:n,outputs:t})=>[`${t.isNan} = isNan(${n.a});`]}}class ls extends On{constructor({a:n}){super({a:n,outKey:"isInf",outTypeFunc:yA}),this.statements=({inputs:n,outputs:t})=>[`${t.isInf} = isInf(${n.a});`]}}const us=(n,t)=>new Es({a:n,b:t}),gs=(n,t,e)=>new ws({cond:n,t:t,f:e});class hs extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:(n,t)=>n,outKey:"and"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.and?[`${t.and} = ${n.a} && ${n.b};`]:[`${t.and} = ${n.a} & ${n.b};`]}}class ps extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:(n,t)=>n,outKey:"or"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.or?[`${t.or} = ${n.a} || ${n.b};`]:[`${t.or} = ${n.a} | ${n.b};`]}}class Is extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:(n,t)=>n,outKey:"xor"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.xor?[`${t.xor} = ${n.a} ^^ ${n.b};`]:[`${t.xor} = ${n.a} ^ ${n.b};`]}}class ds extends On{constructor({a:n}){super({a:n,outTypeFunc:n=>n,outKey:"not"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.not?[`${t.not} = !${n.a};`]:[`${t.not} = not(${n.a});`]}}class Cs extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:(n,t)=>bs(n,"lessThan"),outKey:"lessThan"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.lessThan?[`${t.lessThan} = ${n.a} < ${n.b};`]:[`${t.lessThan} = lessThan(${n.a}, ${n.b});`]}}class Bs extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:(n,t)=>bs(n,"lessThanEqual"),outKey:"lessThanEqual"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.lessThanEqual?[`${t.lessThanEqual} = ${n.a} <= ${n.b};`]:[`${t.lessThanEqual} = lessThanEqual(${n.a}, ${n.b});`]}}class fs extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:(n,t)=>bs(n,"greaterThan"),outKey:"greaterThan"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.greaterThan?[`${t.greaterThan} = ${n.a} > ${n.b};`]:[`${t.greaterThan} = greaterThan(${n.a}, ${n.b});`]}}class Es extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:(n,t)=>bs(n,"greaterThanEqual"),outKey:"greaterThanEqual"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.greaterThanEqual?[`${t.greaterThanEqual} = ${n.a} >= ${n.b};`]:[`${t.greaterThanEqual} = greaterThanEqual(${n.a}, ${n.b});`]}}class ms extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:vs,outKey:"equal"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.equal?[`${t.equal} = ${n.a} == ${n.b};`]:[`${t.equal} = equal(${n.a}, ${n.b});`]}}class Qs extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outTypeFunc:Ss,outKey:"notEqual"}),this.statements=({inputs:n,outputs:t})=>"bool"===this.outTypes.notEqual?[`${t.notEqual} = ${n.a} != ${n.b};`]:[`${t.notEqual} = notEqual(${n.a}, ${n.b});`]}}class ys extends On{constructor({a:n}){super({a:n,outTypeFunc:n=>"bool",outKey:"any"}),this.statements=({inputs:n,outputs:t})=>[`${t.any} = any(${n.a});`]}}class xs extends On{constructor({a:n}){super({a:n,outTypeFunc:n=>"bool",outKey:"all"}),this.statements=({inputs:n,outputs:t})=>[`${t.all} = all(${n.a});`]}}class ws extends Wn{constructor({cond:n,t:t,f:e}){super({a:n,b:t,c:e,outKey:"select",outTypeFunc:(n,t,e)=>t}),this.statements=({inputs:n,outputs:t})=>{const{a:e,b:A,c:s}=n;return[`${t.select} = (${e}) ? (${A}) : (${s});`]}}}function bs(n,t){if(In(n))return"bool";if("ivec2"===n||"uvec2"===n||"vec2"===n)return"bvec2";if("ivec3"===n||"uvec3"===n||"vec3"===n)return"bvec3";if("ivec4"===n||"uvec4"===n||"vec4"===n)return"bvec4";throw new Error(`Invalid ${t} type: ${n}`)}function vs(n,t="equal"){if(In(n))return"bool";if(pn(n))return n;if("ivec2"===n||"uvec2"===n||"vec2"===n)return"bvec2";if("ivec3"===n||"uvec3"===n||"vec3"===n)return"bvec3";if("ivec4"===n||"uvec4"===n||"vec4"===n)return"bvec4";throw new Error(`Invalid ${t} type: ${n}`)}function Ss(n){return vs(n,"notEqual")}class Ds extends On{constructor({a:n}){const t=function(n){if(pn(n))return"bool";if(dn(n))return"int";if(Cn(n))return"uint";throw new Error(`Invalid compXor type: ${n}`)}(Fn(n));super({a:n,outTypeFunc:n=>t,outKey:"compXor"}),this.statements=({inputs:n,outputs:e})=>{if(In(this.outTypes.compXor))return[`${e.compXor} = ${n.a};`];const A=(mn(t)?["x","y"]:Qn(t)?["x","y","z"]:["x","y","z","w"]).map((t=>`${n.a}.${t}`)),s=pn(t)?"^^":"^";return[`${e.compXor} = ${A.join(` ${s} `)};`]}}}const Ms=n=>new Ls({value:n}),ks=n=>new Ps({value:n}),_s=n=>new Ws({value:n}),Ts=n=>new na({value:n}),Fs=n=>new sa({value:n}),Ns=n=>new aa({value:n}),Rs=n=>new ga({value:n}),Gs=n=>new pa({value:n});class Us extends On{constructor({value:n,outType:t,outKey:e}){super({a:n,outTypeFunc:()=>t,outKey:e}),this.statements=({inputs:n,outputs:A})=>[`${A[e]} = ${Mn(t)}(${n.a});`]}}class Ys extends Us{constructor({value:n}){super({value:n,outType:"bool",outKey:"bool"})}}class qs extends Us{constructor({value:n}){super({value:n,outType:"int",outKey:"int"})}}class zs extends Us{constructor({value:n}){super({value:n,outType:"uint",outKey:"uint"})}}class Ls extends Us{constructor({value:n}){super({value:n,outType:"float",outKey:"float"})}}class Js extends Us{constructor({value:n}){super({value:n,outType:"bvec2",outKey:"bvec2"})}}class Hs extends Us{constructor({value:n}){super({value:n,outType:"bvec3",outKey:"bvec3"})}}class Ks extends Us{constructor({value:n}){super({value:n,outType:"bvec4",outKey:"bvec4"})}}class Vs extends Us{constructor({value:n}){super({value:n,outType:"ivec2",outKey:"ivec2"})}}class $s extends Us{constructor({value:n}){super({value:n,outType:"ivec3",outKey:"ivec3"})}}class js extends Us{constructor({value:n}){super({value:n,outType:"ivec4",outKey:"ivec4"})}}class Zs extends Us{constructor({value:n}){super({value:n,outType:"uvec2",outKey:"uvec2"})}}class Xs extends Us{constructor({value:n}){super({value:n,outType:"uvec3",outKey:"uvec3"})}}class Os extends Us{constructor({value:n}){super({value:n,outType:"uvec4",outKey:"uvec4"})}}class Ps extends Us{constructor({value:n}){super({value:n,outType:"vec2",outKey:"vec2"})}}class Ws extends Us{constructor({value:n}){super({value:n,outType:"vec3",outKey:"vec3"})}}class na extends Us{constructor({value:n}){super({value:n,outType:"vec4",outKey:"vec4"})}}class ta extends Us{constructor({value:n}){super({value:n,outType:"mat2",outKey:"mat2"})}}class ea extends Us{constructor({value:n}){super({value:n,outType:"mat3",outKey:"mat3"})}}class Aa extends Us{constructor({value:n}){super({value:n,outType:"mat4",outKey:"mat4"})}}class sa extends On{constructor({value:n}){super({a:n,outKey:"int",outTypeFunc:()=>"int"}),this.statements=({inputs:n,outputs:t})=>[`${t.int} = floatBitsToInt(${n.a});`]}}class aa extends On{constructor({value:n}){super({a:n,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:n,outputs:t})=>[`${t.uint} = floatBitsToUint(${n.a});`]}}class ra extends On{constructor({value:n}){super({a:n,outKey:"float",outTypeFunc:()=>"float"}),this.statements=({inputs:n,outputs:t})=>[`${t.float} = intBitsToFloat(${n.a});`]}}class ia extends On{constructor({value:n}){super({a:n,outKey:"float",outTypeFunc:()=>"float"}),this.statements=({inputs:n,outputs:t})=>[`${t.float} = uintBitsToFloat(${n.a});`]}}class oa extends On{constructor({value:n}){super({a:n,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:n,outputs:t})=>[`${t.uint} = packSnorm2x16(${n.a});`]}}class ca extends On{constructor({value:n}){super({a:n,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:n,outputs:t})=>[`${t.vec2} = unpackSnorm2x16(${n.a});`]}}class la extends On{constructor({value:n}){super({a:n,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:n,outputs:t})=>[`${t.uint} = packUnorm2x16(${n.a});`]}}class ua extends On{constructor({value:n}){super({a:n,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:n,outputs:t})=>[`${t.vec2} = unpackUnorm2x16(${n.a});`]}}class ga extends On{constructor({value:n}){super({a:n,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:n,outputs:t})=>[`${t.uint} = packHalf2x16(${n.a});`]}}class ha extends On{constructor({value:n}){super({a:n,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:n,outputs:t})=>[`${t.vec2} = unpackHalf2x16(${n.a});`]}}class pa extends On{constructor({value:n}){super({a:n,outKey:"rgba8",outTypeFunc:()=>"vec4"}),this.statements=({inputs:n,outputs:t})=>[`uvec4 uRgba = uvec4(${n.a} & 0xffu, (${n.a} >> 8u) & 0xffu, (${n.a} >> 16u) & 0xffu, (${n.a} >> 24u) & 0xffu);`,`${t.rgba8} = vec4(uRgba) / 255.0;`]}}const Ia=(n,t)=>new Qa({a:n,b:t}),da=n=>new xa({a:n}),Ca=n=>new Ga({vector:n}),Ba=({vector:n,vectorType:t,x:e,y:A,z:s,w:a,r:r,g:i,b:o,a:c})=>new Ua({vector:n,vectorType:t,x:e,y:A,z:s,w:a,r:r,g:i,b:o,a:c}),fa=(n,t)=>new ba({a:n,b:t});class Ea extends On{constructor({a:n}){super({a:n,outTypeFunc:n=>"float",outKey:"length"}),this.statements=({inputs:n,outputs:t})=>[`${t.length} = length(${n.a});`]}}class ma extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"distance",outTypeFunc:(n,t)=>"float"}),this.statements=({inputs:n,outputs:t})=>[`${t.distance} = distance(${n.a}, ${n.b});`]}}class Qa extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"dot",outTypeFunc:(n,t)=>"float"}),this.statements=({inputs:n,outputs:t})=>[`${t.dot} = dot(${n.a}, ${n.b});`]}}class ya extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"cross",outTypeFunc:(n,t)=>"vec3"}),this.statements=({inputs:n,outputs:t})=>[`${t.cross} = cross(${n.a}, ${n.b});`]}}class xa extends On{constructor({a:n}){super({a:n,outTypeFunc:n=>n,outKey:"normalize"}),this.statements=({inputs:n,outputs:t})=>[`${t.normalize} = normalize(${n.a});`]}}class wa extends On{constructor({a:n}){super({a:n,outTypeFunc:n=>function(n){if("vec3"===n)return"vec2";if("vec4"===n)return"vec3";throw new Error("Invalid type")}(n),outKey:"projected"}),this.statements=({inputs:n,outputs:t})=>{if("vec3"===this.inTypes.a)return[`${t.projected} = ${n.a}.xy / ${n.a}.z;`];if("vec4"===this.inTypes.a)return[`${t.projected} = ${n.a}.xyz / ${n.a}.w;`];throw new Error("Invalid type")}}}class ba extends Pn{constructor({a:n,b:t}){const e=function(n){if("float"===n)return"vec2";if("vec2"===n)return"vec3";if("vec3"===n)return"vec4";throw new Error("Invalid type")}(Fn(n));super({a:n,b:t,outKey:"extend",outTypeFunc:()=>e}),this.statements=({inputs:n,outputs:t})=>[`${t.extend} = ${e}(${n.a}, ${n.b});`]}}class va extends Wn{constructor({a:n,b:t,c:e}){super({a:n,b:t,c:e,outKey:"forward",outTypeFunc:(n,t,e)=>n}),this.statements=({inputs:n,outputs:t})=>[`${t.forward} = faceforward(${n.a}, ${n.b}, ${n.c});`]}}class Sa extends Pn{constructor({incident:n,normal:t}){super({a:n,b:t,outKey:"reflection",outTypeFunc:(n,t)=>n}),this.statements=({inputs:n,outputs:t})=>[`${t.reflection} = reflect(${n.a}, ${n.b});`]}}class Da extends Wn{constructor({incident:n,normal:t,eta:e}){super({a:n,b:t,c:e,outKey:"refraction",outTypeFunc:(n,t,e)=>n}),this.statements=({inputs:n,outputs:t})=>[`${t.refraction} = refract(${n.a}, ${n.b}, ${n.c});`]}}class Ma extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"product",outTypeFunc:(n,t)=>n}),this.statements=({inputs:e,outputs:A})=>[`${A.product} = matrixCompMult(${n}, ${t});`]}}function ka(n,t){if("vec2"===n){if("vec2"===t)return"mat2";if("vec3"===t)return"mat3x2";if("vec4"===t)return"mat4x2"}if("vec3"===n){if("vec2"===t)return"mat2x3";if("vec3"===t)return"mat3";if("vec4"===t)return"mat4x3"}if("vec4"===n){if("vec2"===t)return"mat2x4";if("vec3"===t)return"mat3x4";if("vec4"===t)return"mat4"}throw new Error(`Invalid outer type: ${n}, ${t}`)}class _a extends Pn{constructor({a:n,b:t}){super({a:n,b:t,outKey:"outer",outTypeFunc:ka}),this.statements=({inputs:n,outputs:t})=>[`${t.outer} = outerProduct(${n.a}, ${n.b});`]}}function Ta(n){if("mat2"===n)return"mat2";if("mat3"===n)return"mat3";if("mat4"===n)return"mat4";if("mat2x2"===n)return"mat2x2";if("mat2x3"===n)return"mat3x2";if("mat2x4"===n)return"mat4x2";if("mat3x2"===n)return"mat2x3";if("mat3x3"===n)return"mat3x3";if("mat3x4"===n)return"mat4x3";if("mat4x2"===n)return"mat2x4";if("mat4x3"===n)return"mat3x4";if("mat4x4"===n)return"mat4x4";throw new Error(`Invalid transpose type: ${n}`)}class Fa extends On{constructor({a:n}){super({a:n,outKey:"transpose",outTypeFunc:Ta}),this.statements=({inputs:n,outputs:t})=>[`${t.transpose} = transpose(${n.a});`]}}class Na extends On{constructor({a:n}){super({a:n,outKey:"det",outTypeFunc:n=>"float"}),this.statements=({inputs:n,outputs:t})=>[`${t.det} = determinant(${n.a});`]}}class Ra extends On{constructor({a:n}){super({a:n,outKey:"inverse",outTypeFunc:n=>n}),this.statements=({inputs:t,outputs:e})=>[`${e.inverse} = inverse(${n});`]}}class Ga extends Hn{constructor({vector:n}){const t={vector:Fn(n)},e=function(n){switch(n){case"vec2":return{x:"float",y:"float",r:"float",g:"float"};case"vec3":return{x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"};case"vec4":return{x:"float",y:"float",z:"float",w:"float",r:"float",g:"float",b:"float",a:"float"};case"ivec2":return{x:"int",y:"int",r:"int",g:"int"};case"ivec3":return{x:"int",y:"int",z:"int",r:"int",g:"int",b:"int"};case"ivec4":return{x:"int",y:"int",z:"int",w:"int",r:"int",g:"int",b:"int",a:"int"};case"uvec2":return{x:"uint",y:"uint",r:"uint",g:"uint"};case"uvec3":return{x:"uint",y:"uint",z:"uint",r:"uint",g:"uint",b:"uint"};case"uvec4":return{x:"uint",y:"uint",z:"uint",w:"uint",r:"uint",g:"uint",b:"uint",a:"uint"};default:throw new Error(`Invalid vector type: ${n}`)}}(t.vector);super({inTypes:t,outTypes:e,inputs:{vector:n}}),this.statements=({inputs:n,outputs:t})=>{const{x:e,y:A,z:s,w:a,r:r,g:i,b:o,a:c}=t,{vector:l}=n;return[e?`${e} = ${l}.x;`:null,A?`${A} = ${l}.y;`:null,s?`${s} = ${l}.z;`:null,a?`${a} = ${l}.w;`:null,r?`${r} = ${l}.r;`:null,i?`${i} = ${l}.g;`:null,o?`${o} = ${l}.b;`:null,c?`${c} = ${l}.a;`:null].filter(Boolean)}}}class Ua extends Hn{constructor({vector:n,vectorType:t,x:e,y:A,z:s,w:a,r:r,g:i,b:o,a:c}){if(!n&&!t)throw new Error("Either vector or vectorType must be provided");const l=t??Fn(n),u=vn(l),g=Sn(l),h={vector:l,x:u,y:u,r:u,g:u},p={vector:n,x:e,y:A,r:r,g:i};g>=3&&(Object.assign(h,{z:u,b:u}),Object.assign(p,{z:s,b:o})),g>=4&&(Object.assign(h,{w:u,a:u}),Object.assign(p,{w:a,a:c})),super({inTypes:h,outTypes:{vector:l},inputs:p}),this.statements=({inputs:n,outputs:t})=>{const{vector:e}=t,{vector:A,x:s,y:a,z:r,w:i,r:o,g:c,b:l,a:h}=n,p=[`${e}.x = ${s??o??(A?`${A}.x`:zn(u))};`,`${e}.y = ${a??c??(A?`${A}.y`:zn(u))};`];return g>=3&&p.push(`${e}.z = ${r??l??(A?`${A}.z`:zn(u))};`),g>=4&&p.push(`${e}.w = ${i??h??(A?`${A}.w`:zn(u))};`),p}}dynoOut(){return new Rn(this,"vector")}}class Ya extends On{constructor({vector:n,select:t}){super({a:n,outKey:"swizzle",outTypeFunc:n=>function(n,t){let e=null;if(Bn(n)?e=1===t.length?"float":2===t.length?"vec2":3===t.length?"vec3":4===t.length?"vec4":null:dn(n)?e=1===t.length?"int":2===t.length?"ivec2":3===t.length?"ivec3":4===t.length?"ivec4":null:Cn(n)&&(e=1===t.length?"uint":2===t.length?"uvec2":3===t.length?"uvec3":4===t.length?"uvec4":null),null==e)throw new Error(`Invalid swizzle: ${t}`);return e}(n,t)}),this.statements=({inputs:n,outputs:e})=>[`${e.swizzle} = ${n.a}.${t};`]}}const qa=n=>new Oa({value:n}),za=n=>new Pa({value:n}),La=n=>new Wa({value:n}),Ja=n=>new nr({value:n}),Ha=n=>new Ar({value:n}),Ka=n=>new sr({value:n}),Va=(n,t,e)=>new ar({z:n,zNear:t,zFar:e}).outputs.depth;class $a extends Hn{constructor({from:n,to:t,index:e}){super({inTypes:{from:"int",to:"int",index:"int"},outTypes:{index:"int"},inputs:{from:n,to:t,index:e},statements:({inputs:n,outputs:t})=>[`${t.index} = ${n.index} - ${n.from} + ${n.to};`]})}dynoOut(){return new Rn(this,"index")}}class ja extends Hn{constructor({state:n}){const t=Fn(n);super({inTypes:{state:t},outTypes:{state:"uint"},inputs:{state:n},globals:()=>[Xn("\n          uint pcg_next(uint state) {\n            return state * 747796405u + 2891336453u;\n          }\n        ")],statements:({inputs:n,outputs:e})=>{const A="uint"===t?`${n.state}`:"int"===t?`uint(${n.state})`:`floatBitsToUint(${n.state})`;return[`${e.state} = pcg_next(${A});`]}})}dynoOut(){return new Rn(this,"state")}}class Za extends Hn{constructor({state:n}){super({inTypes:{state:"uint"},outTypes:{hash:"uint"},inputs:{state:n},globals:()=>[Xn("\n          uint pcg_hash(uint state) {\n            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n            return (hash >> 22u) ^ hash;\n          }\n        ")],statements:({inputs:n,outputs:t})=>[`${t.hash} = pcg_hash(${n.state});`]})}dynoOut(){return new Rn(this,"hash")}}class Xa extends Hn{constructor({value:n}){const t=Fn(n),e=Dn(t);super({inTypes:{value:t},outTypes:{state:"uint"},inputs:{value:n},globals:()=>[Xn("\n          uint pcg_mix(uint value) {\n            return value;\n          }\n          uint pcg_mix(uvec2 value) {\n            return value.x + 0x9e3779b9u * value.y;\n          }\n          uint pcg_mix(uvec3 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;\n          }\n          uint pcg_mix(uvec4 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;\n          }\n        ")],statements:({inputs:n,outputs:A})=>{const s=Cn(t)?`${n.value}`:dn(t)?`${e}(${n.value})`:`floatBitsToUint(${n.value})`;return[`${e} bits = ${s};`,`${A.state} = pcg_mix(bits);`]}})}dynoOut(){return new Rn(this,"state")}}class Oa extends Kn{constructor({value:n}){super({inTypes:{value:Fn(n)},outTypes:{hash:"uint"},inputs:{value:n},construct:({value:n})=>{if(!n)throw new Error("value is required");let t=new Xa({value:n}).outputs.state;return t=new ja({state:t}).outputs.state,new Za({state:t}).outputs}})}dynoOut(){return new Rn(this,"hash")}}class Pa extends Kn{constructor({value:n}){super({inTypes:{value:Fn(n)},outTypes:{hash:"uvec2"},inputs:{value:n},construct:({value:n})=>{if(!n)throw new Error("value is required");let t=new Xa({value:n}).outputs.state;t=new ja({state:t}).outputs.state;const e=new Za({state:t}).outputs.hash;t=new ja({state:t}).outputs.state;const A=new Za({state:t}).outputs.hash;return{hash:Ba({vectorType:"uvec2",x:e,y:A})}}})}dynoOut(){return new Rn(this,"hash")}}class Wa extends Kn{constructor({value:n}){super({inTypes:{value:Fn(n)},outTypes:{hash:"uvec3"},inputs:{value:n},construct:({value:n})=>{if(!n)throw new Error("value is required");let t=new Xa({value:n}).outputs.state;t=new ja({state:t}).outputs.state;const e=new Za({state:t}).outputs.hash;t=new ja({state:t}).outputs.state;const A=new Za({state:t}).outputs.hash;t=new ja({state:t}).outputs.state;const s=new Za({state:t}).outputs.hash;return{hash:Ba({vectorType:"uvec3",x:e,y:A,z:s})}}})}dynoOut(){return new Rn(this,"hash")}}class nr extends Kn{constructor({value:n}){super({inTypes:{value:Fn(n)},outTypes:{hash:"uvec4"},inputs:{value:n},construct:({value:n})=>{if(!n)throw new Error("value is required");let t=new Xa({value:n}).outputs.state;t=new ja({state:t}).outputs.state;const e=new Za({state:t}).outputs.hash;t=new ja({state:t}).outputs.state;const A=new Za({state:t}).outputs.hash;t=new ja({state:t}).outputs.state;const s=new Za({state:t}).outputs.hash;t=new ja({state:t}).outputs.state;const a=new Za({state:t}).outputs.hash;return{hash:Ba({vectorType:"uvec4",x:e,y:A,z:s,w:a})}}})}dynoOut(){return new Rn(this,"hash")}}class tr extends Kn{constructor({value:n}){super({inTypes:{value:Fn(n)},outTypes:{hash:"float"},inputs:{value:n},construct:({value:n})=>{if(!n)throw new Error("value is required");const t=qa(n);return{hash:bA(Ms(t),qn("float",1/2**32))}}})}dynoOut(){return new Rn(this,"hash")}}class er extends Kn{constructor({value:n}){super({inTypes:{value:Fn(n)},outTypes:{hash:"vec2"},inputs:{value:n},construct:({value:n})=>{if(!n)throw new Error("value is required");const t=za(n);return{hash:bA(ks(t),qn("float",1/2**32))}}})}dynoOut(){return new Rn(this,"hash")}}class Ar extends Kn{constructor({value:n}){super({inTypes:{value:Fn(n)},outTypes:{hash:"vec3"},inputs:{value:n},construct:({value:n})=>{if(!n)throw new Error("value is required");const t=La(n);return{hash:bA(_s(t),qn("float",1/2**32))}}})}dynoOut(){return new Rn(this,"hash")}}class sr extends Kn{constructor({value:n}){super({inTypes:{value:Fn(n)},outTypes:{hash:"vec4"},inputs:{value:n},construct:({value:n})=>{if(!n)throw new Error("value is required");const t=Ja(n);return{hash:bA(Ts(t),qn("float",1/2**32))}}})}dynoOut(){return new Rn(this,"hash")}}class ar extends Hn{constructor({z:n,zNear:t,zFar:e}){super({inTypes:{z:"float",zNear:"float",zFar:"float"},outTypes:{depth:"float"},inputs:{z:n,zNear:t,zFar:e},statements:({inputs:n,outputs:t})=>[`float clamped = clamp(${n.z}, ${n.zNear}, ${n.zFar});`,`${t.depth} = (log2(clamped + 1.0) - log2(${n.zNear} + 1.0)) / (log2(${n.zFar} + 1.0) - log2(${n.zNear} + 1.0));`]})}dynoOut(){return new Rn(this,"depth")}}const rr=(n,{scale:t,scales:e,rotate:A,translate:s})=>new or({position:n,scale:t,scales:e,rotate:A,translate:s}).outputs.position,ir=(n,{scale:t,scales:e,rotate:A})=>new cr({dir:n,scale:t,scales:e,rotate:A}).outputs.dir;class or extends Hn{constructor({position:n,scale:t,scales:e,rotate:A,translate:s}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:n,scale:t,scales:e,rotate:A,translate:s},statements:({inputs:n,outputs:t})=>{const{position:e}=t;if(!e)return[];const{scale:A,scales:s,rotate:a,translate:r}=n;return[`${e} = ${n.position??"vec3(0.0, 0.0, 0.0)"};`,A?`${e} *= ${A};`:null,s?`${e} *= ${s};`:null,a?`${e} = quatVec(${a}, ${e});`:null,r?`${e} += ${r};`:null].filter(Boolean)}})}}class cr extends Hn{constructor({dir:n,scale:t,scales:e,rotate:A}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:n,scale:t,scales:e,rotate:A},statements:({inputs:n,outputs:t})=>{const{dir:e}=t;if(!e)return[];const{scale:A,scales:s,rotate:a}=n;return[`${e} = ${n.dir??"vec3(0.0, 0.0, 0.0)"};`,A?`${e} *= ${A};`:null,s?`${e} *= ${s};`:null,a?`${e} = quatVec(${a}, ${e});`:null].filter(Boolean)}})}}class lr extends Hn{constructor({quaternion:n,rotate:t}){super({inTypes:{quaternion:"vec4",rotate:"vec4"},outTypes:{quaternion:"vec4"},inputs:{quaternion:n,rotate:t},statements:({inputs:n,outputs:e})=>{const{quaternion:A}=e;return A?[`${A} = ${n.quaternion??"vec4(0.0, 0.0, 0.0, 1.0)"};`,t?`${A} = quatQuat(${n.rotate}, ${A});`:null].filter(Boolean):[]}})}}class ur extends Hn{constructor({texture:n,lod:t}){const e=Fn(n);super({inTypes:{texture:e,lod:"int"},outTypes:{size:pr(e)},inputs:{texture:n,lod:t},statements:({inputs:n,outputs:t})=>[`${t.size} = textureSize(${n.texture}, ${n.lod??"0"});`]})}dynoOut(){return new Rn(this,"size")}}class gr extends Hn{constructor({texture:n,coord:t,bias:e}){const A=Fn(n);super({inTypes:{texture:A,coord:Ir(A),bias:"float"},outTypes:{sample:dr(A)},inputs:{texture:n,coord:t,bias:e},statements:({inputs:n,outputs:t})=>[`${t.sample} = texture(${n.texture}, ${n.coord}${n.bias?`, ${n.bias}`:""});`]})}dynoOut(){return new Rn(this,"sample")}}class hr extends Hn{constructor({texture:n,coord:t,lod:e}){const A=Fn(n);super({inTypes:{texture:A,coord:pr(A),lod:"int"},outTypes:{texel:dr(A)},inputs:{texture:n,coord:t,lod:e},statements:({inputs:n,outputs:t})=>[`${t.texel} = texelFetch(${n.texture}, ${n.coord}, ${n.lod??"0"});`]})}dynoOut(){return new Rn(this,"texel")}}function pr(n){switch(n){case"sampler2D":case"usampler2D":case"isampler2D":case"samplerCube":case"usamplerCube":case"isamplerCube":case"sampler2DShadow":case"samplerCubeShadow":return"ivec2";case"sampler3D":case"usampler3D":case"isampler3D":case"sampler2DArray":case"usampler2DArray":case"isampler2DArray":case"sampler2DArrayShadow":return"ivec3";default:throw new Error(`Invalid texture type: ${n}`)}}function Ir(n){switch(n){case"sampler2D":case"usampler2D":case"isampler2D":return"vec2";case"sampler3D":case"usampler3D":case"isampler3D":case"samplerCube":case"usamplerCube":case"isamplerCube":case"sampler2DArray":case"usampler2DArray":case"isampler2DArray":case"sampler2DShadow":return"vec3";case"samplerCubeShadow":case"sampler2DArrayShadow":return"vec4";default:throw new Error(`Invalid texture type: ${n}`)}}function dr(n){switch(n){case"sampler2D":case"sampler2DArray":case"sampler3D":case"samplerCube":case"sampler2DShadow":return"vec4";case"usampler2D":case"usampler2DArray":case"usampler3D":case"usamplerCube":return"uvec4";case"isampler2D":case"isampler2DArray":case"isampler3D":case"isamplerCube":return"ivec4";case"samplerCubeShadow":case"sampler2DArrayShadow":return"float";default:throw new Error(`Invalid texture type: ${n}`)}}const Cr=n=>new Er({radians:n});class Br extends On{constructor({degrees:n}){super({a:n,outTypeFunc:n=>n,outKey:"radians"}),this.statements=({inputs:n,outputs:t})=>[`${t.radians} = radians(${n.a});`]}}class fr extends On{constructor({radians:n}){super({a:n,outTypeFunc:n=>n,outKey:"degrees"}),this.statements=({inputs:n,outputs:t})=>[`${t.degrees} = degrees(${n.a});`]}}class Er extends On{constructor({radians:n}){super({a:n,outTypeFunc:n=>n,outKey:"sin"}),this.statements=({inputs:n,outputs:t})=>[`${t.sin} = sin(${n.a});`]}}class mr extends On{constructor({radians:n}){super({a:n,outTypeFunc:n=>n,outKey:"cos"}),this.statements=({inputs:n,outputs:t})=>[`${t.cos} = cos(${n.a});`]}}class Qr extends On{constructor({radians:n}){super({a:n,outTypeFunc:n=>n,outKey:"tan"}),this.statements=({inputs:n,outputs:t})=>[`${t.tan} = tan(${n.a});`]}}class yr extends On{constructor({sin:n}){super({a:n,outTypeFunc:n=>n,outKey:"asin"}),this.statements=({inputs:n,outputs:t})=>[`${t.asin} = asin(${n.a});`]}}class xr extends On{constructor({cos:n}){super({a:n,outTypeFunc:n=>n,outKey:"acos"}),this.statements=({inputs:n,outputs:t})=>[`${t.acos} = acos(${n.a});`]}}class wr extends On{constructor({tan:n}){super({a:n,outTypeFunc:n=>n,outKey:"atan"}),this.statements=({inputs:n,outputs:t})=>[`${t.atan} = atan(${n.a});`]}}class br extends Pn{constructor({y:n,x:t}){super({a:n,b:t,outTypeFunc:(n,t)=>n,outKey:"atan2"}),this.statements=({inputs:n,outputs:t})=>[`${t.atan2} = atan2(${n.a}, ${n.b});`]}}class vr extends On{constructor({x:n}){super({a:n,outTypeFunc:n=>n,outKey:"sinh"}),this.statements=({inputs:n,outputs:t})=>[`${t.sinh} = sinh(${n.a});`]}}class Sr extends On{constructor({x:n}){super({a:n,outTypeFunc:n=>n,outKey:"cosh"}),this.statements=({inputs:n,outputs:t})=>[`${t.cosh} = cosh(${n.a});`]}}class Dr extends On{constructor({x:n}){super({a:n,outTypeFunc:n=>n,outKey:"tanh"}),this.statements=({inputs:n,outputs:t})=>[`${t.tanh} = tanh(${n.a});`]}}class Mr extends On{constructor({x:n}){super({a:n,outTypeFunc:n=>n,outKey:"asinh"}),this.statements=({inputs:n,outputs:t})=>[`${t.asinh} = asinh(${n.a});`]}}class kr extends On{constructor({x:n}){super({a:n,outTypeFunc:n=>n,outKey:"acosh"}),this.statements=({inputs:n,outputs:t})=>[`${t.acosh} = acosh(${n.a});`]}}class _r extends On{constructor({x:n}){super({a:n,outTypeFunc:n=>n,outKey:"atanh"}),this.statements=({inputs:n,outputs:t})=>[`${t.atanh} = atanh(${n.a});`]}}Symbol.toStringTag;const Tr=class t{constructor({renderer:n}={}){this.renderer=n,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(n,t){const e=4*(Math.ceil(Math.max(1,n)/cn)*cn);if(t.byteLength>=e)return t;const A=new ArrayBuffer(e);if(t instanceof ArrayBuffer)return A;return new(0,t.constructor)(A)}ensureCapacity(t){const{width:e,height:A,depth:s,maxSplats:a}=Me(t);(!this.target||a>this.capacity)&&(this.dispose(),this.capacity=a,this.target=new n.WebGLArrayRenderTarget(e,A,s,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:n.NearestFilter,minFilter:n.NearestFilter}),this.target.texture.format=n.RGBAFormat,this.target.texture.type=n.UnsignedByteType,this.target.texture.internalFormat="RGBA8",this.target.scissorTest=!0)}prepareProgramMaterial(n){let e=t.readbackProgram.get(n);if(!e){const A=Vn({index:"int"},{rgba8:"vec4"},(({index:t})=>{n.inputs.index=t;return{rgba8:new mt({rgba8:n.outputs.rgba8})}}));t.programTemplate||(t.programTemplate=new Ve("precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}")),e=new Ke({graph:A,inputs:{index:"index"},outputs:{rgba8:"target"},template:t.programTemplate}),Object.assign(e.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),t.readbackProgram.set(n,e)}const A=e.prepareMaterial();return t.fullScreenQuad.material=A,{program:e,material:A}}saveRenderState(n){return{xrEnabled:n.xr.enabled,autoClear:n.autoClear}}resetRenderState(n,t){n.setRenderTarget(null),n.xr.enabled=t.xrEnabled,n.autoClear=t.autoClear}process({count:n,material:e}){const A=this.renderer;if(!A)throw new Error("No renderer");if(!this.target)throw new Error("No target");const s=cn*ln;e.uniforms.targetBase.value=0,e.uniforms.targetCount.value=n;let a=0;for(;a<n;){const r=Math.floor(a/s),i=r*s,o=Math.min(ln,Math.ceil((n-i)/cn));e.uniforms.targetLayer.value=r,this.target.scissor.set(0,0,cn,o),A.setRenderTarget(this.target,r),A.xr.enabled=!1,A.autoClear=!1,t.fullScreenQuad.render(A),a+=cn*o}this.count=n}async read({readback:n}){const t=this.renderer;if(!t)throw new Error("No renderer");if(!this.target)throw new Error("No target");const e=Math.ceil(this.count/cn)*cn;if(n.byteLength<4*e)throw new Error(`Readback buffer too small: ${n.byteLength} < ${4*e}`);const A=new Uint8Array(n instanceof ArrayBuffer?n:n.buffer),s=cn*ln;let a=0;const r=[];for(;a<this.count;){const n=Math.floor(a/s),e=n*s,i=Math.min(ln,Math.ceil((this.count-e)/cn));t.setRenderTarget(this.target,n);const o=cn*i*4,c=A.subarray(4*e,4*e+o),l=null==t?void 0:t.readRenderTargetPixelsAsync(this.target,0,0,cn,i,c);r.push(l),a+=cn*i}return Promise.all(r).then((()=>n))}render({reader:n,count:t,renderer:e}){if(this.renderer=e||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(t);const{program:A,material:s}=this.prepareProgramMaterial(n);A.update();const a=this.saveRenderState(this.renderer);this.process({count:t,material:s}),this.resetRenderState(this.renderer,a)}async readback({readback:n}){if(!this.renderer)throw new Error("No renderer");const t=this.saveRenderState(this.renderer),e=this.read({readback:n});return this.resetRenderState(this.renderer,t),e}async renderReadback({reader:n,count:t,renderer:e,readback:A}){if(this.renderer=e||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(t);const{program:s,material:a}=this.prepareProgramMaterial(n);s.update();const r=this.saveRenderState(this.renderer);this.process({count:t,material:a});const i=this.read({readback:A});return this.resetRenderState(this.renderer,r),i}getTexture(){var n;return null==(n=this.target)?void 0:n.texture}};Tr.programTemplate=null,Tr.readbackProgram=new Map,Tr.fullScreenQuad=new h(new n.RawShaderMaterial({visible:!1}));let Fr=Tr;const Nr=class t{constructor(n={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new xt({key:"rgbaArray",type:Gr,globals:()=>[Ur],value:{texture:t.getEmpty(),count:0},update:n=>{var e;return n.texture=(null==(e=this.readback)?void 0:e.getTexture())??this.source??t.getEmpty(),n.count=this.count,n}}),n.array?(this.array=n.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/cn)*cn,this.count=Math.min(this.capacity,n.count??Number.POSITIVE_INFINITY)):(this.capacity=n.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(n){var t;if(!this.array||n>((null==(t=this.array)?void 0:t.length)??0)/4){this.capacity=Me(n).maxSplats;const t=new Uint8Array(4*this.capacity);this.array&&t.set(this.array),this.array=t}return this.array}getTexture(){var n;let e=null==(n=this.readback)?void 0:n.getTexture();return(this.source||this.array)&&(e=this.maybeUpdateSource()),e??t.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:n,height:t,depth:e}=this.source.image;this.capacity!==n*t*e&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:t,height:e,depth:A}=Me(this.capacity);this.source=new n.DataArrayTexture(this.array,t,e,A),this.source.format=n.RGBAFormat,this.source.type=n.UnsignedByteType,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:n,count:t,renderer:e}){this.readback||(this.readback=new Fr({renderer:e})),this.readback.render({reader:n,count:t,renderer:e}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:n,base:e,count:A,renderer:s}){const{dynoSplats:a,dynoBase:r,dynoCount:i,reader:o}=t.makeDynos();return a.packedSplats=n,r.value=e,i.value=A,this.render({reader:o,count:A,renderer:s}),this}async read(){if(!this.readback)throw new Error("No readback");(!this.array||this.array.length<4*this.count)&&(this.array=new Uint8Array(4*this.capacity));return(await this.readback.readback({readback:this.array})).subarray(0,4*this.count)}static getEmpty(){if(!t.emptySource){const e=new Uint8Array(4);t.emptySource=new n.DataArrayTexture(e,1,1,1),t.emptySource.format=n.RGBAFormat,t.emptySource.type=n.UnsignedByteType,t.emptySource.internalFormat="RGBA8",t.emptySource.needsUpdate=!0}return t.emptySource}static makeDynos(){if(!t.dynos){const n=new Yi,e=new vt({value:0}),A=new vt({value:0}),s=Vn({index:"int"},{rgba8:"vec4"},(({index:t})=>{if(!t)throw new Error("index is undefined");t=xA(t,e);const s=At(n,t,e,A);return{rgba8:st(s).outputs.rgba}}));t.dynos={dynoSplats:n,dynoBase:e,dynoCount:A,reader:s}}return t.dynos}};Nr.emptySource=null,Nr.dynos=null;let Rr=Nr;const Gr={type:"RgbaArray"},Ur=Xn("\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n");function Yr(n){switch(n){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${n}`)}}function qr(n){switch(n){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${n}`)}}class zr extends n.Object3D{constructor(t={}){super();const{type:e,invert:A,opacity:s,color:a,displace:r,radius:i}=t;this.type=e??"sphere",this.invert=A??!1,this.opacity=s??1,this.color=a??new n.Color(1,1,1),this.displace=r??new n.Vector3(0,0,0),this.radius=i??0}}const Lr=class t extends n.Object3D{constructor(n={}){const{name:e,rgbaBlendMode:A="multiply",sdfSmooth:s=0,softEdge:a=0,invert:r=!1,sdfs:i=null}=n;super(),this.rgbaBlendMode=A,this.sdfSmooth=s,this.softEdge=a,this.invert=r,this.sdfs=i,this.ordering=t.nextOrdering++,this.name=e??`Edit ${this.ordering}`}addSdf(n){null==this.sdfs&&(this.sdfs=[]),this.sdfs.includes(n)||this.sdfs.push(n)}removeSdf(n){null!=this.sdfs&&(this.sdfs=this.sdfs.filter((t=>t!==n)))}};Lr.nextOrdering=1;let Jr=Lr;class Hr{constructor({maxSdfs:n,maxEdits:t}){this.maxSdfs=Math.max(16,n??0),this.numSdfs=0,this.sdfData=new Uint32Array(8*this.maxSdfs*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new xt({key:"sdfArray",type:Kr,globals:()=>[Vr],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:n=>(n.numSdfs=this.numSdfs,n.sdfTexture=this.sdfTexture,n)}),this.maxEdits=Math.max(16,t??0),this.numEdits=0,this.editData=new Uint32Array(4*this.maxEdits),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new vt({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(t,e){const A=new n.DataTexture(t,8,e,n.RGBAIntegerFormat,n.UnsignedIntType);return A.internalFormat="RGBA32UI",A.needsUpdate=!0,A}newEdits(n,t){return new xt({key:"edits",type:"uvec4",count:t,globals:()=>[$r],value:n})}ensureCapacity({maxSdfs:n,maxEdits:t}){let e=!1;return n>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(2*this.maxSdfs,n),this.sdfData=new Uint32Array(8*this.maxSdfs*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),t>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(2*this.maxEdits,t),this.editData=new Uint32Array(4*this.maxEdits),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),e=!0),e}updateEditData(n,t){const e=this.editData[n]!==t;return this.editData[n]=t,e}updateEditFloatData(n,t){jr[0]=t;const e=this.editFloatData[n]!==jr[0];return e&&(this.editFloatData[n]=jr[0]),e}encodeEdit(n,{sdfFirst:t,sdfCount:e,invert:A,rgbaBlendMode:s,softEdge:a,sdfSmooth:r}){const i=4*n;let o=!1;return o=this.updateEditData(i+0,s|(A?256:0))||o,o=this.updateEditData(i+1,t|e<<16)||o,o=this.updateEditFloatData(i+2,a)||o,o=this.updateEditFloatData(i+3,r)||o,o}updateSdfData(n,t){const e=this.sdfData[n]!==t;return this.sdfData[n]=t,e}updateSdfFloatData(n,t){jr[0]=t;const e=this.sdfFloatData[n]!==jr[0];return e&&(this.sdfFloatData[n]=jr[0]),e}encodeSdf(n,{sdfType:t,invert:e,center:A,quaternion:s,scale:a,sizes:r},i){const o=32*n,c=t|(e?256:0);let l=!1;l=this.updateSdfFloatData(o+0,(null==A?void 0:A.x)??0)||l,l=this.updateSdfFloatData(o+1,(null==A?void 0:A.y)??0)||l,l=this.updateSdfFloatData(o+2,(null==A?void 0:A.z)??0)||l,l=this.updateSdfData(o+3,c)||l,l=this.updateSdfFloatData(o+4,(null==s?void 0:s.x)??0)||l,l=this.updateSdfFloatData(o+5,(null==s?void 0:s.y)??0)||l,l=this.updateSdfFloatData(o+6,(null==s?void 0:s.z)??0)||l,l=this.updateSdfFloatData(o+7,(null==s?void 0:s.w)??0)||l,l=this.updateSdfFloatData(o+8,(null==a?void 0:a.x)??0)||l,l=this.updateSdfFloatData(o+9,(null==a?void 0:a.y)??0)||l,l=this.updateSdfFloatData(o+10,(null==a?void 0:a.z)??0)||l,l=this.updateSdfData(o+11,0)||l,l=this.updateSdfFloatData(o+12,(null==r?void 0:r.x)??0)||l,l=this.updateSdfFloatData(o+13,(null==r?void 0:r.y)??0)||l,l=this.updateSdfFloatData(o+14,(null==r?void 0:r.z)??0)||l,l=this.updateSdfFloatData(o+15,(null==r?void 0:r.w)??0)||l;const u=Math.min(4,i.length);for(let n=0;n<u;++n){const t=o+16+4*n;l=this.updateSdfFloatData(t+0,i[n].x)||l,l=this.updateSdfFloatData(t+1,i[n].y)||l,l=this.updateSdfFloatData(t+2,i[n].z)||l,l=this.updateSdfFloatData(t+3,i[n].w)||l}return l}update(t){const e=t.reduce(((n,{sdfs:t})=>n+t.length),0),A=this.ensureCapacity({maxEdits:t.length,maxSdfs:e}),s=[new n.Vector4,new n.Vector4],a=new n.Vector3,r=new n.Quaternion,i=new n.Vector3,o=new n.Vector4;let c=0,l=A;t.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=t.length,this.numEdits=t.length,l=!0);for(const[n,{edit:e,sdfs:A}]of t.entries()){l=this.encodeEdit(n,{sdfFirst:c,sdfCount:A.length,invert:e.invert,rgbaBlendMode:qr(e.rgbaBlendMode),softEdge:e.softEdge,sdfSmooth:e.sdfSmooth})||l;let t=!1;for(const n of A){o.set(n.scale.x,n.scale.y,n.scale.z,n.radius),n.scale.setScalar(1),n.updateMatrixWorld();n.matrixWorld.clone().invert().decompose(a,r,i),n.scale.set(o.x,o.y,o.z),n.updateMatrixWorld(),s[0].set(n.color.r,n.color.g,n.color.b,n.opacity),s[1].set(n.displace.x,n.displace.y,n.displace.z,1),t=this.encodeSdf(c,{sdfType:Yr(n.type),invert:n.invert,center:a,quaternion:r,scale:i,sizes:o},s)||t,c+=1}this.numSdfs=c,t&&(this.sdfTexture.needsUpdate=!0),l||(l=t)}return{updated:l,dynoUpdated:A}}modify(n){return function(n,t,e,A){const s=new Hn({inTypes:{gsplat:nt,sdfArray:Kr,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:nt},globals:()=>[Vr,$r],inputs:{gsplat:n,sdfArray:t,numEdits:e,rgbaDisplaceEdits:A},statements:({inputs:n,outputs:t})=>{const{sdfArray:e,numEdits:A,rgbaDisplaceEdits:s}=n,{gsplat:a}=t;return Zn(`\n        ${a} = ${n.gsplat};\n        if (isGsplatActive(${a}.flags)) {\n          for (int editIndex = 0; editIndex < ${A}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${s}[editIndex], ${e}.sdfTexture, ${e}.numSdfs,\n              ${a}.center, ${a}.rgba\n            );\n          }\n        }\n      `)}});return s.outputs.gsplat}(n,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const Kr={type:"SdfArray"},Vr=Xn("\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n"),$r=Xn("\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n");const jr=new Float32Array(1);class Zr{constructor(n){this.modifier=n,this.cache=new Map}apply(n){let t=this.cache.get(n);return t||(t=Vn({index:"int"},{gsplat:nt},(({index:t})=>{const{gsplat:e}=n.apply({index:t});return this.modifier.apply({gsplat:e})})),this.cache.set(n,t)),t}}class Xr{constructor(){this.scale=new St({value:Number.NEGATIVE_INFINITY}),this.rotate=new qt({value:new n.Quaternion(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new Rt({value:new n.Vector3(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(n){return rr(n,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(n){return ir(n,{rotate:this.rotate})}applyGsplat(n){return it(n,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(t){const e=new n.Vector3,A=new n.Quaternion,s=new n.Vector3;t.decompose(s,A,e);const a=(e.x+e.y+e.z)/3;let r=!1;return a!==this.scale.value&&(this.scale.value=a,r=!0),s.equals(this.translate.value)||(this.translate.value.copy(s),r=!0),A.equals(this.rotate.value)||(this.rotate.value.copy(A),r=!0),r}update(n){return n.updateMatrixWorld(),this.updateFromMatrix(n.matrixWorld)}}class Or extends n.Object3D{constructor({numSplats:n,generator:t,construct:e,update:A}){if(super(),this.numSplats=n??0,this.generator=t,this.frameUpdate=A,this.version=0,e){const n=e(this);Object.assign(this,n)}}updateVersion(){this.version+=1}set needsUpdate(n){n&&this.updateVersion()}}const Pr=class t extends Or{constructor(t={}){const e={transform:new Xr,viewToWorld:new Xr,worldToView:new Xr,viewToObject:new Xr,recolor:new qt({value:new n.Vector4(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),time:new St({value:0}),deltaTime:new St({value:0})};if(super({update:({time:n,deltaTime:t,viewToWorld:e,globalEdits:A})=>this.update({time:n,deltaTime:t,viewToWorld:e,globalEdits:A})}),this.isInitialized=!1,this.recolor=new n.Color(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=t.packedSplats??new Ui,this.packedSplats.splatEncoding=t.splatEncoding??{...Ri},this.numSplats=this.packedSplats.numSplats,this.editable=t.editable??!0,this.onFrame=t.onFrame,this.context=e,this.objectModifier=t.objectModifier,this.worldModifier=t.worldModifier,this.updateGenerator(),t.url||t.fileBytes||t.constructSplats||t.packedSplats&&!t.packedSplats.isInitialized)this.initialized=this.asyncInitialize(t).then((async()=>{if(this.updateGenerator(),this.isInitialized=!0,t.onLoad){const n=t.onLoad(this);n instanceof Promise&&await n}return this}));else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),t.onLoad){const n=t.onLoad(this);n instanceof Promise&&(this.initialized=n.then((()=>this)))}this.add(function(){const t=new n.Mesh(Ai,si);return t.frustumCulled=!1,t.onBeforeRender=function(n,t){if(!t.isScene)return void this.removeFromParent();let e=!1;t.traverse((n=>{n instanceof Xi&&(e=!0)})),e||t.add(new Xi({renderer:n})),this.removeFromParent()},t}())}async asyncInitialize(n){const{url:t,fileBytes:e,fileType:A,fileName:s,maxSplats:a,constructSplats:r,splatEncoding:i}=n;if(t||e||r){const n={url:t,fileBytes:e,fileType:A,fileName:s,maxSplats:a,construct:r,splatEncoding:i};this.packedSplats.reinitialize(n)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await An(),t.isStaticInitialized=!0}pushSplat(n,t,e,A,s){this.packedSplats.pushSplat(n,t,e,A,s)}forEachSplat(n){this.packedSplats.forEachSplat(n)}dispose(){this.packedSplats.dispose()}getBoundingBox(t=!0){if(!this.initialized)throw new Error("Cannot get bounding box before SplatMesh is initialized");const e=new n.Vector3(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),A=new n.Vector3(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY),s=new n.Vector3,a=[-1,1];this.packedSplats.forEachSplat(((n,r,i,o,c,l)=>{if(t)e.min(r),A.max(r);else for(const n of a)for(const t of a)for(const c of a)s.set(n*i.x,t*i.y,c*i.z),s.applyQuaternion(o),s.add(r),e.min(s),A.max(s)}));return new n.Box3(e,A)}constructGenerator(n){const{transform:t,viewToObject:e,recolor:A}=n,s=Vn({index:"int"},{gsplat:nt},(({index:n})=>{if(!n)throw new Error("index is undefined");let s=et(this.packedSplats.dyno,n);if(this.maxSh>=1){const{sh1Texture:n,sh2Texture:t,sh3Texture:A}=this.ensureShTextures();if(n){let a=function(n,t){const{x:e,y:A}=Ca(t).outputs,s=bA(xA(e,A),qn("float",.5)),a=bA(wA(A,e),qn("float",.5));return xA(s,bA(n,a))};const r=e.translate,{center:i}=st(s).outputs,o=da(wA(i,r)),c=function(n,t,e){return $n({inTypes:{gsplat:nt,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh1:t,viewDir:e},globals:()=>[ot,ni],statements:({inputs:n,outputs:t})=>Zn(`\n        if (isGsplatActive(${n.gsplat}.flags)) {\n          ${t.rgb} = evaluateSH1(${n.gsplat}, ${n.sh1}, ${n.viewDir});\n        } else {\n          ${t.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(s,n,o);let l=a(c,this.packedSplats.dynoSh1MinMax);if(this.maxSh>=2&&t){const n=function(n,t,e){return $n({inTypes:{gsplat:nt,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh2:t,viewDir:e},globals:()=>[ot,ti],statements:({inputs:n,outputs:t})=>Zn(`\n        if (isGsplatActive(${n.gsplat}.flags)) {\n          ${t.rgb} = evaluateSH2(${n.gsplat}, ${n.sh2}, ${n.viewDir});\n        } else {\n          ${t.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(s,t,o);l=xA(l,a(n,this.packedSplats.dynoSh2MinMax))}if(this.maxSh>=3&&A){const n=function(n,t,e){return $n({inTypes:{gsplat:nt,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh3:t,viewDir:e},globals:()=>[ot,ei],statements:({inputs:n,outputs:t})=>Zn(`\n        if (isGsplatActive(${n.gsplat}.flags)) {\n          ${t.rgb} = evaluateSH3(${n.gsplat}, ${n.sh3}, ${n.viewDir});\n        } else {\n          ${t.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(s,A,o);l=xA(l,a(n,this.packedSplats.dynoSh3MinMax))}let{rgba:u}=st(s).outputs;u=xA(u,fa(l,qn("float",0))),s=at({gsplat:s,rgba:u})}}if(this.splatRgba){const t=function(n,t){return new Hn({inTypes:{rgba:Gr,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:n,index:t},globals:()=>[Ur],statements:({inputs:n,outputs:t})=>Zn(`\n        if ((index >= 0) && (index < ${n.rgba}.count)) {\n          ${t.rgba} = texelFetch(${n.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${t.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)}).outputs.rgba}(this.splatRgba.dyno,n);s=at({gsplat:s,rgba:t})}this.skinning&&(s=this.skinning.modify(s)),this.objectModifier&&(s=this.objectModifier.apply({gsplat:s}).gsplat),s=t.applyGsplat(s);const a=bA(A,st(s).outputs.rgba);return s=at({gsplat:s,rgba:a}),this.rgbaDisplaceEdits&&(s=this.rgbaDisplaceEdits.modify(s)),this.worldModifier&&(s=this.worldModifier.apply({gsplat:s}).gsplat),{gsplat:s}}));this.generator=s}updateGenerator(){this.constructGenerator(this.context)}update({time:e,viewToWorld:A,deltaTime:s,globalEdits:a}){var r;this.numSplats=this.packedSplats.numSplats,this.context.time.value=e,this.context.deltaTime.value=s,t.dynoTime.value=e;const{transform:i,viewToObject:o,recolor:c}=this.context;let l=i.update(this);this.context.viewToWorld.updateFromMatrix(A)&&this.enableViewToWorld&&(l=!0);const u=A.clone().invert();this.context.worldToView.updateFromMatrix(u)&&this.enableWorldToView&&(l=!0);const g=(new n.Matrix4).compose(i.translate.value,i.rotate.value,(new n.Vector3).setScalar(i.scale.value)).invert().multiply(A);o.updateFromMatrix(g)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(l=!0);const h=new n.Vector4(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);h.equals(c.value)||(c.value.copy(h),l=!0);const p=this.editable?(this.edits??[]).concat(a):[];this.editable&&!this.edits&&this.traverseVisible((n=>{n instanceof Jr&&p.push(n)})),p.sort(((n,t)=>n.ordering-t.ordering));const I=p.map((n=>{if(null!=n.sdfs)return{edit:n,sdfs:n.sdfs};const t=[];return n.traverseVisible((n=>{n instanceof zr&&t.push(n)})),{edit:n,sdfs:t}}));if(I.length>0&&!this.rgbaDisplaceEdits){const n=I.length,t=I.reduce(((n,t)=>n+t.sdfs.length),0);this.rgbaDisplaceEdits=new Hr({maxEdits:n,maxSdfs:t}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const n=this.rgbaDisplaceEdits.update(I);l||(l=n.updated),n.dynoUpdated&&this.updateGenerator()}l&&this.updateVersion(),null==(r=this.onFrame)||r.call(this,{mesh:this,time:e,deltaTime:s})}raycast(t,e){var A,s;if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:a,far:r,ray:i}=t,o=this.matrixWorld.clone().invert(),c=(new n.Matrix3).setFromMatrix4(o),l=i.origin.clone().applyMatrix4(o),u=i.direction.clone().applyMatrix3(c),g=new n.Vector3;o.decompose(new n.Vector3,new n.Quaternion,g),g.x,g.y,g.z;const h=function(n,t,e,A,s,a,r,i,o,c,l,u,g){return W.raycast_splats(n,t,e,A,s,a,r,i,o,c,l,u,g)}(l.x,l.y,l.z,u.x,u.y,u.z,a,r,this.packedSplats.numSplats,this.packedSplats.packedArray,!0,(null==(A=this.packedSplats.splatEncoding)?void 0:A.lnScaleMin)??sn,(null==(s=this.packedSplats.splatEncoding)?void 0:s.lnScaleMax)??9);for(const n of h){const t=i.direction.clone().multiplyScalar(n).add(i.origin);e.push({distance:n,point:t,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let t=this.packedSplats.extra.sh1Texture;if(!t){let e=this.packedSplats.extra.sh1;const{width:A,height:s,depth:a,maxSplats:r}=Me(e.length/2);if(e.length<2*r){const n=new Uint32Array(2*r);n.set(e),this.packedSplats.extra.sh1=n,e=n}const i=new n.DataArrayTexture(e,A,s,a);i.format=n.RGIntegerFormat,i.type=n.UnsignedIntType,i.internalFormat="RG32UI",i.needsUpdate=!0,t=new ee({value:i,key:"sh1"}),this.packedSplats.extra.sh1Texture=t}if(!this.packedSplats.extra.sh2)return{sh1Texture:t};let e=this.packedSplats.extra.sh2Texture;if(!e){let t=this.packedSplats.extra.sh2;const{width:A,height:s,depth:a,maxSplats:r}=Me(t.length/4);if(t.length<4*r){const n=new Uint32Array(4*r);n.set(t),this.packedSplats.extra.sh2=n,t=n}const i=new n.DataArrayTexture(t,A,s,a);i.format=n.RGBAIntegerFormat,i.type=n.UnsignedIntType,i.internalFormat="RGBA32UI",i.needsUpdate=!0,e=new ee({value:i,key:"sh2"}),this.packedSplats.extra.sh2Texture=e}if(!this.packedSplats.extra.sh3)return{sh1Texture:t,sh2Texture:e};let A=this.packedSplats.extra.sh3Texture;if(!A){let t=this.packedSplats.extra.sh3;const{width:e,height:s,depth:a,maxSplats:r}=Me(t.length/4);if(t.length<4*r){const n=new Uint32Array(4*r);n.set(t),this.packedSplats.extra.sh3=n,t=n}const i=new n.DataArrayTexture(t,e,s,a);i.format=n.RGBAIntegerFormat,i.type=n.UnsignedIntType,i.internalFormat="RGBA32UI",i.needsUpdate=!0,A=new ee({value:i,key:"sh3"}),this.packedSplats.extra.sh3Texture=A}return{sh1Texture:t,sh2Texture:e,sh3Texture:A}}};Pr.staticInitialized=Pr.staticInitialize(),Pr.isStaticInitialized=!1,Pr.dynoTime=new St({value:0});let Wr=Pr;const ni=Xn("\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n"),ti=Xn("\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n"),ei=Xn("\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n");const Ai=new n.BufferGeometry,si=new n.ShaderMaterial;const ai=["char","uchar","short","ushort","int","uint","float","double"],ri=class n{constructor({fileBytes:n}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=n instanceof ArrayBuffer?new Uint8Array(n):n}async parseHeader(){const n=new ReadableStream({start:n=>{n.enqueue(this.fileBytes.slice(0,65536)),n.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const t="end_header\n";for(;;){const{value:e,done:A}=await n.read();if(A)throw new Error("Failed to read header");this.header+=e;const s=this.header.indexOf(t);if(s>=0){this.header=this.header.slice(0,s+11);break}}const e=(new TextEncoder).encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,e),this.elements={};let A=null;this.comments=[],this.header.trim().split("\n").forEach(((n,t)=>{const e=n.trim();if(0===t){if("ply"!==e)throw new Error("Invalid PLY header");return}if(0===e.length)return;const s=e.split(" ");switch(s[0]){case"format":if("binary_little_endian"===s[1])this.littleEndian=!0;else{if("binary_big_endian"!==s[1])throw new Error(`Unsupported PLY format: ${s[1]}`);this.littleEndian=!1}if("1.0"!==s[2])throw new Error(`Unsupported PLY version: ${s[2]}`);break;case"end_header":break;case"comment":this.comments.push(e.slice(8));break;case"element":{const n=s[1];A={name:n,count:Number.parseInt(s[2]),properties:{}},this.elements[n]=A;break}case"property":if(null==A)throw new Error("Property must be inside an element");"list"===s[1]?A.properties[s[4]]={isList:!0,type:s[3],countType:s[2]}:A.properties[s[2]]={isList:!1,type:s[1]}}})),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(n){let t=0;const e=this.data;if(null==e)throw new Error("No data to parse");for(const A in this.elements){const s=this.elements[A],{count:a,properties:r}=s,i=di(r),o=Ci(r,this.littleEndian),c=n(s)??(()=>{});for(let n=0;n<a;n++)t=o(e,t,i),c(n,i)}}parseSplats(t,e){if(null==this.elements.vertex)throw new Error("No vertex element found");let A=!1;const s=[];let a,r,i,o=0,c=[],l=[],u=[];function g(){const n=pi[o];c=new Array(3).fill(null).flatMap(((t,e)=>[0,1,2].map(((t,A)=>e+A*n/3)))),l=new Array(5).fill(null).flatMap(((t,e)=>[0,1,2].map(((t,A)=>3+e+A*n/3)))),u=new Array(7).fill(null).flatMap(((t,e)=>[0,1,2].map(((t,A)=>8+e+A*n/3)))),a=o>=1?new Float32Array(9):void 0,r=o>=2?new Float32Array(15):void 0,i=o>=3?new Float32Array(21):void 0}function h(n,t){if(!a)throw new Error("Missing sh1");const A=t.f_rest;for(let n=0;n<c.length;n++)a[n]=8*A[c[n]]/255-4;if(r)for(let n=0;n<l.length;n++)r[n]=8*A[l[n]]/255-4;if(i)for(let n=0;n<u.length;n++)i[n]=8*A[u[n]]/255-4;null==e||e(n,a,r,i)}this.parseData((p=>{if("chunk"===p.name)return function(n){const{min_x:t,min_y:e,min_z:a,max_x:r,max_y:i,max_z:o,min_scale_x:c,min_scale_y:l,min_scale_z:u,max_scale_x:g,max_scale_y:h,max_scale_z:p}=n.properties;if(!(t&&e&&a&&r&&i&&o&&c&&l&&u&&g&&h&&p))throw new Error("Missing PLY chunk properties");return A=!0,(n,t)=>{const{min_x:e,min_y:A,min_z:a,max_x:r,max_y:i,max_z:o,min_scale_x:c,min_scale_y:l,min_scale_z:u,max_scale_x:g,max_scale_y:h,max_scale_z:p,min_r:I,min_g:d,min_b:C,max_r:B,max_g:f,max_b:E}=t;s.push({min_x:e,min_y:A,min_z:a,max_x:r,max_y:i,max_z:o,min_scale_x:c,min_scale_y:l,min_scale_z:u,max_scale_x:g,max_scale_y:h,max_scale_z:p,min_r:I,min_g:d,min_b:C,max_r:B,max_g:f,max_b:E})}}(p);if(A)return function(n){if(e&&"sh"===n.name)return o=Ei(n.properties),g(),h;if("vertex"!==n.name)return null;const{packed_position:A,packed_rotation:a,packed_scale:r,packed_color:i}=n.properties;if(!(A&&a&&r&&i))throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const c=Math.sqrt(2);return(n,e)=>{const A=s[n>>>8];if(null==A)throw new Error("Missing PLY chunk");const{min_x:a,min_y:r,min_z:i,max_x:o,max_y:l,max_z:u,min_scale_x:g,min_scale_y:h,min_scale_z:p,max_scale_x:I,max_scale_y:d,max_scale_z:C,min_r:B,min_g:f,min_b:E,max_r:m,max_g:Q,max_b:y}=A,{packed_position:x,packed_rotation:w,packed_scale:b,packed_color:v}=e,S=(x>>>21&2047)/2047*(o-a)+a,D=(x>>>11&1023)/1023*(l-r)+r,M=(2047&x)/2047*(u-i)+i,k=((w>>>20&1023)/1023-.5)*c,_=((w>>>10&1023)/1023-.5)*c,T=((1023&w)/1023-.5)*c,F=Math.sqrt(Math.max(0,1-k*k-_*_-T*T)),N=w>>>30,R=0===N?k:1===N?F:_,G=N<=1?_:2===N?F:T,U=N<=2?T:F,Y=0===N?F:k,q=Math.exp((b>>>21&2047)/2047*(I-g)+g),z=Math.exp((b>>>11&1023)/1023*(d-h)+h),L=Math.exp((2047&b)/2047*(C-p)+p);t(n,S,D,M,q,z,L,R,G,U,Y,(255&v)/255,(v>>>24&255)/255*((m??1)-(B??0))+(B??0),(v>>>16&255)/255*((Q??1)-(f??0))+(f??0),(v>>>8&255)/255*((y??1)-(E??0))+(E??0))}}(p);if("vertex"!==p.name)return null;const{x:I,y:d,z:C,scale_0:B,scale_1:f,scale_2:E,rot_0:m,rot_1:Q,rot_2:y,rot_3:x,opacity:w,f_dc_0:b,f_dc_1:v,f_dc_2:S,red:D,green:M,blue:k,alpha:_}=p.properties;if(!I||!d||!C)throw new Error("Missing PLY properties: x, y, z");const T=B&&f&&E,F=m&&Q&&y&&x,N=null!=_?gi[_.type]:1,R=null!=D?gi[D.type]:1,G=null!=M?gi[M.type]:1,U=null!=k?gi[k.type]:1;return o=Ei(p.properties),g(),(A,s)=>{const o=T?Math.exp(s.scale_0):n.defaultPointScale,g=T?Math.exp(s.scale_1):n.defaultPointScale,h=T?Math.exp(s.scale_2):n.defaultPointScale,p=F?s.rot_1:0,I=F?s.rot_2:0,d=F?s.rot_3:0,C=F?s.rot_0:1,B=null!=w?1/(1+Math.exp(-s.opacity)):null!=_?s.alpha/N:1,f=null!=b?s.f_dc_0*oi+.5:null!=D?s.red/R:1,E=null!=v?s.f_dc_1*oi+.5:null!=M?s.green/G:1,m=null!=S?s.f_dc_2*oi+.5:null!=k?s.blue/U:1;if(t(A,s.x,s.y,s.z,o,g,h,p,I,d,C,B,f,E,m),e&&a){const n=s.f_rest;if(a)for(let t=0;t<c.length;t++)a[t]=n[c[t]];if(r)for(let t=0;t<l.length;t++)r[t]=n[l[t]];if(i)for(let t=0;t<u.length;t++)i[t]=n[u[t]];e(A,a,r,i)}}}))}injectRgba(n){let t=0;const e=this.data;if(null==e)throw new Error("No parsed data");if(n.length!==4*this.numSplats)throw new Error("Invalid RGBA array length");for(const A in this.elements){const s=this.elements[A],{count:a,properties:r}=s,i=[];let o=0;const c="vertex"===A;if(c)for(const n of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!r[n]||"float"!==r[n].type)throw new Error(`Can't injectRgba due to property: ${n}`);for(const[A,s]of Object.entries(r))if(s.isList)i.push((()=>{const n=ci[s.countType](e,t,this.littleEndian);t+=ui[s.countType],t+=n*ui[s.type]}));else{if(c)if("f_dc_0"===A||"f_dc_1"===A||"f_dc_2"===A){const a=Number.parseInt(A.slice(5));i.push((()=>{const A=(n[o+a]/255-.5)/oi;li[s.type](e,t,this.littleEndian,A)}))}else"opacity"===A&&i.push((()=>{const A=Math.max(-100,Math.min(100,-Math.log(1/(n[o+3]/255)-1)));li[s.type](e,t,this.littleEndian,A)}));i.push((()=>{t+=ui[s.type]}))}for(let n=0;n<a;n++){for(const n of i)n();c&&(o+=4)}}}};ri.defaultPointScale=.001;let ii=ri;const oi=.28209479177387814,ci={char:(n,t,e)=>n.getInt8(t),uchar:(n,t,e)=>n.getUint8(t),short:(n,t,e)=>n.getInt16(t,e),ushort:(n,t,e)=>n.getUint16(t,e),int:(n,t,e)=>n.getInt32(t,e),uint:(n,t,e)=>n.getUint32(t,e),float:(n,t,e)=>n.getFloat32(t,e),double:(n,t,e)=>n.getFloat64(t,e)},li={char:(n,t,e,A)=>{n.setInt8(t,A)},uchar:(n,t,e,A)=>{n.setUint8(t,A)},short:(n,t,e,A)=>{n.setInt16(t,A,e)},ushort:(n,t,e,A)=>{n.setUint16(t,A,e)},int:(n,t,e,A)=>{n.setInt32(t,A,e)},uint:(n,t,e,A)=>{n.setUint32(t,A,e)},float:(n,t,e,A)=>{n.setFloat32(t,A,e)},double:(n,t,e,A)=>{n.setFloat64(t,A,e)}},ui={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},gi={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},hi={0:0,9:1,24:2,45:3},pi={0:0,1:9,2:24,3:45},Ii=/^f_rest_([0-9]{1,2})$/;function di(n){const t={};for(const[e,A]of Object.entries(n))Ii.test(e)?t.f_rest=new Array(Ei(n)):t[e]=A.isList?[]:0;return t}function Ci(n,t){return function(n){if(!Bi)return!1;for(const[t,e]of Object.entries(n)){if(!fi.test(t))return!1;if(e.isList&&!ai.includes(e.countType))return!1;if(!ai.includes(e.type))return!1}return!0}(n)?function(n,t){const e=["let list;"];for(const[A,s]of Object.entries(n)){const n=A.match(Ii);if(n){const A=+n[1];e.push(`\n        item.f_rest[${A}] = PARSE_FIELD['${s.type}'](data, offset, ${t});\n        offset += ${ui[s.type]};\n      `)}else s.isList?e.push(`\n        list = item['${A}'];\n        list.length = PARSE_FIELD['${s.countType}'](data, offset, ${t});\n        offset += ${ui[s.countType]};\n        for (let i = 0; i < list.length; i++) {\n          list[i] = PARSE_FIELD['${s.type}'](data, offset, ${t});\n          offset += ${ui[s.type]};\n        }\n      `):e.push(`\n        item['${A}'] = PARSE_FIELD['${s.type}'](data, offset, ${t});\n        offset += ${ui[s.type]};\n      `)}e.push("return offset;");const A=new Function("data","offset","item","PARSE_FIELD",e.join("\n"));return(n,t,e)=>A(n,t,e,ci)}(n,t):function(n,t){const e=[];for(const[A,s]of Object.entries(n)){const n=A.match(Ii);if(n){const A=+n[1];e.push(((n,e,a)=>(a.f_rest[A]=ci[s.type](n,e,t),e+ui[s.type])))}else s.isList?e.push(((n,e,a)=>{const r=a[A];r.length=ci[s.countType](n,e,t);let i=e+ui[s.countType];for(let e=0;e<r.length;e++)r[e]=ci[s.type](n,i,t),i+=ui[s.type];return i})):e.push(((n,e,a)=>(a[A]=ci[s.type](n,e,t),e+ui[s.type])))}return(n,t,A)=>{let s=t;for(let t=0;t<e.length;t++)s=e[t](n,s,A);return s}}(n,t)}const Bi=(()=>{try{new Function("return 42;")}catch(n){return!1}return!0})(),fi=/^[a-zA-Z0-9_]+$/;function Ei(n){let t=0;for(;n[`f_rest_${t}`];)t+=1;const e=hi[t];if(null==e)throw new Error(`Unsupported number of SH coefficients: ${t}`);return e}const mi='(function() {\n  "use strict";\n  let wasm;\n  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error("TextDecoder not available");\n  } };\n  if (typeof TextDecoder !== "undefined") {\n    cachedTextDecoder.decode();\n  }\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function sort32_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort32_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === "function" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === "function") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get("Content-Type") != "application/wasm") {\n            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_0;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== "undefined") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn("using deprecated parameters for the initialization function; pass a single object instead");\n      }\n    }\n    if (typeof module_or_path === "undefined") {\n      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAN/f38AYAF/AX9gAX8AYANvf38Bb2AFf39/f38Bf2AFf39/f38AYAFvAW9gA29vfwBgAW8Bf2AAAGAAAX9gBH9/f38AYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAYDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABgN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAGA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAYDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADANeXQQAAQcFAgMCEwEBAA0BAwEAAA0BAwgIAwEBBRQBAw4AAwEDAgwMAgABAQcDABUBFhcIGRsH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QYGABGxBEHYgBGohBCAHRQ0ACwJ/IAMgBkH8AXFBAnRqIgAoAgAiAUF/c0EHdiABQQZ2ckGBgoQIcSIBIAdBAUYNABogASAAKAIEIgFBf3NBB3YgAUEGdnJBgYKECHFqIgEgB0ECRg0AGiAAKAIIIgBBf3NBB3YgAEEGdnJBgYKECHEgAWoLIgFBCHZB/4EccSABQf+B/AdxakGBgARsQRB2IARqDwsgAUUEQEEADwsgAUEDcSEDAkAgAUEESQRADAELIAFBfHEhBQNAIAQgACACaiIBLAAAQb9/SmogAUEBaiwAAEG/f0pqIAFBAmosAABBv39KaiABQQNqLAAAQb9/SmohBCAFIAJBBGoiAkcNAAsLIANFDQAgACACaiEBA0AgBCABLAAAQb9/SmohBCABQQFqIQEgA0EBayIDDQALCyAEC4oGAQZ/IAAoAggiAyABSQRAIAEgAyICayIEIAAoAgAgAmtLBEAgACACIARBBEEEECYgACgCCCECCyAAKAIEIgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AggLIAAoAhQiAyABSQRAIAEgAyICayIEIAAoAgwgAmtLBEAgAEEMaiACIARBBEEEECYgACgCFCECCyAAKAIQIgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AhQLIAAoAjgiAyABSQRAIAEgAyICayIEIAAoAjAgAmtLBEAgAEEwaiACIARBBEEEECYgACgCOCECCyAAKAI0IgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AjgLIAAoAiAiA0H//wNNBEAgAyEBQYCABCADayICIAAoAhggA2tLBEAgAEEYaiADIAJBBEEEECYgACgCICEBCyAAKAIcIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQAgB/wLAAsg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IAQgA0EUahAvIAMoAghBAUcNASADKAIQIQAgAygCDAsgAEGEj8AAEEwACyADKAIMIQEgACAENgIAIAAgATYCBCADQSBqJAALuQEBBX8jAEEgayICJAAgACgCACIEQf////8BSwRAQQBBACABEEwACwJAQQQgBEEBdCIFIAVBBE0bIgVBAnQiBkH8////B00EfyACIAQEfyACIARBAnQ2AhwgAiAAKAIENgIUQQQFIAMLNgIYIAJBCGpBBCAGIAJBFGoQLyACKAIIQQFHDQEgAigCECEDIAIoAgwFIAMLIAMgARBMAAsgAigCDCEBIAAgBTYCACAAIAE2AgQgAkEgaiQAC8EBAgN/AX4jAEEwayICJAAgASgCAEGAgICAeEYEQCABKAIMIQMgAkEUaiIEQQA2AgAgAkKAgICAEDcCDCACQSBqIAMoAgAiA0EIaikCADcDACACQShqIANBEGopAgA3AwAgAiADKQIANwMYIAJBDGpBuIvAACACQRhqEBgaIAJBCGogBCgCACIDNgIAIAIgAikCDCIFNwMAIAFBCGogAzYCACABIAU3AgALIABB8I3AADYCBCAAIAE2AgAgAkEwaiQAC68BAQZ/AkACQCAAQYQBSQ0AIADQbyYBECMiASgCDCEFIAEoAhAhAiABQgA3AgwgASgCCCEDIAEoAgQhBCABQgQ3AgQgASgCACEGIAFBADYCACAAIAJJDQEgACACayIAIANPDQEgBCAAQQJ0aiAFNgIAIAEgAjYCECABIAA2AgwgASADNgIIIAEoAgQgASAENgIEIAEoAgAhACABIAY2AgAgAEUNACAAQQJ0EGALDwsAC6gBAQF/IwBBEGsiBiQAAkAgAQRAIAZBBGogASADIAQgBSACKAIQEQgAAkAgBigCBCICIAYoAgwiAU0EQCAGKAIIIQUMAQsgAkECdCECIAYoAgghAyABRQRAQQQhBSADIAIQYAwBCyADIAJBBCABQQJ0IgIQUCIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQYyKwABBMhBjAAtBBCACQfyJwAAQTAALrQEBA38gASgCDCECAkACQAJAAkACQAJAIAEoAgQOAgABAgsgAg0BQQEhA0EAIQFBASECDAMLIAJFDQELIAAgARAbDwsgASgCACICKAIEIgFBAEgNASACKAIAIQMgAUUEQEEB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A0EAIAD8CwALIAsoAighFAJAIAsoAiwiEEUNACAQQQJ0IgBFDQAgFEEAIAD8CwALIBNBAnQhCSATBEAgCSEEIAohAANAAkAgACgCACIGQYCAgPwHTw0AIAwgBkF/cyIFQf//A3EiBksEQCADIAZBAnRqIgYgBigCAEEBajYCACAQIAVBEHYiBksEQCAUIAZBAnRqIgYgBigCAEEBajYCAAwCCyAGIBBB3InAABAxAAsgBiAMQcyJwAAQMQALIABBBGohACAEQQRrIgQNAAsLAkAgDEUEQEEAIQQMAQsgDEEBa0H/////A3EiAEEBaiIEQQdxIQUCQCAAQQdJBEBBACEEIAMhAAwBCyAEQfj///8HcSEGQQAhBCADIQADQCAAKAIAIQcgACAENgIAIABBBGoiESgCACESIBEgBCAHaiIENgIAIABBCGoiBygCACERIAcgBCASaiIENgIAIABBDGoiBygCACESIAcgBCARaiIENgIAIABBEGoiBygCACERIAcgBCASaiIENgIAIABBFGoiBygCACESIAcgBCARaiIENgIAIABBGGoiBygCACERIAcgBCASaiIENgIAIABBHGoiBygCACESIAcgBCARaiIENgIAIAQgEmohBCAAQSBqIQAgBkEIayIGDQALCyAFRQ0AA0AgACgCACEGIAAgBDYCACAAQQRqIQAgBCAGaiEEIAVBAWsiBQ0ACwsgDiAENgIEIBMEQCAJIApqIREgCkEEaiEGIBNBAWtB/////wNxQQFqIRIgCygCNCEXIAsoAjghB0EAIQUgCiEJA0AgBiEAAkAgCSgCACIJQYCAgPwHTw0AAkAgDCAJQX9zQf//A3EiCUsEQCADIAlBAnRqIgkoAgAiBiAHTw0BIBcgBkECdGogBTYCACAJIAkoAgBBAWo2AgAMAgsgCSAMQayJwAAQMQALIAYgB0G8icAAEDEACyAAIAAgEUdBAnRqIQYgACEJIBIgBUEBaiIFRw0ACwsCQCAQRQ0AIBBBAWtB/////wNxIgNBAWoiCUEHcSEGQQAhBSAUIQAgA0EHTwRAIAlB+P///wdxIQkDQCAAKAIAIQMgACAFNgIAIABBBGoiDCgCACEHIAwgAyAFaiIDNgIAIABBCGoiBSgCACEMIAUgAyAHaiIDNgIAIABBDGoiBSgCACEHIAUgAyAMaiIDNgIAIABB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uIvAACABEBgLDAAgACABKQIANwMACw0AIABB0I7AACABEBgLDQAgAUHIjsAAQQUQUQsZACAAIAFBkJbAACgCACIAQRQgABsRAQAACw0AIAFBpJDAAEEYEBYLoAIBA38gACgCACEAIwBBkAFrIgMkAAJ/AkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASADQQhqIAAoAgAgA0EQahAfIAFBAUEAIAMoAgggAygCDBAUDAILIAAoAgAhAkEAIQADQCAAIANqQY8BaiACQQ9xIgRBMHIgBEHXAGogBEEKSRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAwBCyAAKAIAIQJBACEAA0AgACADakGPAWogAkEPcSIEQTByIARBN2ogBEEKSRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAsgA0GQAWokAAsJACAAQQA2AgALCAAgACUBEAMLCAAgACUBEAcLC/UUAwBBgIDAAAuhD3NwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9zb3J0LnJzAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjEwMC9zcmMvY29udmVydC9zbGljZXMucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy9tb2QucnMAL3J1c3QvZGVwcy9kbG1hbGxv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dGAgZmFpbGVkOiAKICBsZWZ0OiAAAACbCBAAEAAAAOQIEAAQAAAA9AgQAAkAAADCCBAACQAAADogAAABAAAAAAAAACAJEAACAAAAfSB9MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OSBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCByYW5nZSBlbmQgaW5kZXggACMKEAAQAAAAAQoQACIAAACQCBAAkggQAJQIEAACAAAAAgAAAAcAAAAAAAA/AAAAvwBB/JTAAAsBEgB8CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44OS4wICgyOTQ4Mzg4M2UgMjAyNS0wOC0wNCkGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4TMC4yLjEwMCAoMjQwNWVjMmI0KQBrD3RhcmdldF9mZWF0dXJlcwYrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsLYnVsay1tZW1vcnkrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU=", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  var ch2 = {};\n  var wk = function(c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n      c + \';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})\'\n    ], { type: "text/javascript" }))));\n    w.onmessage = function(e) {\n      var d = e.data, ed = d.$e$;\n      if (ed) {\n        var err2 = new Error(ed[0]);\n        err2["code"] = ed[1];\n        err2.stack = ed[2];\n        cb(err2, null);\n      } else\n        cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n  };\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n  var fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */\n    0,\n    0,\n    /* impossible */\n    0\n  ]);\n  var fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */\n    0,\n    0\n  ]);\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var freb = function(eb, start) {\n    var b = new u16(31);\n    for (var i2 = 0; i2 < 31; ++i2) {\n      b[i2] = start += 1 << eb[i2 - 1];\n    }\n    var r = new i32(b[30]);\n    for (var i2 = 1; i2 < 30; ++i2) {\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\n        r[j] = j - b[i2] << 5 | i2;\n      }\n    }\n    return { b, r };\n  };\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n  fl[28] = 258, revfl[258] = 28;\n  var _b = freb(fdeb, 0), fd = _b.b;\n  var rev = new u16(32768);\n  for (var i = 0; i < 32768; ++i) {\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n  }\n  var hMap = function(cd, mb, r) {\n    var s = cd.length;\n    var i2 = 0;\n    var l = new u16(mb);\n    for (; i2 < s; ++i2) {\n      if (cd[i2])\n        ++l[cd[i2] - 1];\n    }\n    var le = new u16(mb);\n    for (i2 = 1; i2 < mb; ++i2) {\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\n    }\n    var co;\n    if (r) {\n      co = new u16(1 << mb);\n      var rvb = 15 - mb;\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          var sv = i2 << 4 | cd[i2];\n          var r_1 = mb - cd[i2];\n          var v = le[cd[i2] - 1]++ << r_1;\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\n        }\n      }\n    }\n    return co;\n  };\n  var flt = new u8(288);\n  for (var i = 0; i < 144; ++i)\n    flt[i] = 8;\n  for (var i = 144; i < 256; ++i)\n    flt[i] = 9;\n  for (var i = 256; i < 280; ++i)\n    flt[i] = 7;\n  for (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n  var fdt = new u8(32);\n  for (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\n  var max = function(a) {\n    var m = a[0];\n    for (var i2 = 1; i2 < a.length; ++i2) {\n      if (a[i2] > m)\n        m = a[i2];\n    }\n    return m;\n  };\n  var bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  var bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  var shft = function(p) {\n    return (p + 7) / 8 | 0;\n  };\n  var slc = function(v, s, e) {\n    if (s == null || s < 0)\n      s = 0;\n    if (e == null || e > v.length)\n      e = v.length;\n    return new u8(v.subarray(s, e));\n  };\n  var ec = [\n    "unexpected EOF",\n    "invalid block type",\n    "invalid length/literal",\n    "invalid distance",\n    "stream finished",\n    "no stream handler",\n    ,\n    "no callback",\n    "invalid UTF-8 data",\n    "extra field too long",\n    "date not in range 1980-2099",\n    "filename too long",\n    "stream finishing",\n    "invalid zip data"\n    // determined by unknown compression method\n  ];\n  var err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(e, err);\n    if (!nt)\n      throw e;\n    return e;\n  };\n  var inflt = function(dat, st, buf, dict) {\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n      return buf || new u8(0);\n    var noBuf = !buf;\n    var resize = noBuf || st.i != 2;\n    var noSt = st.i;\n    if (noBuf)\n      buf = new u8(sl * 3);\n    var cbuf = function(l2) {\n      var bl = buf.length;\n      if (l2 > bl) {\n        var nbuf = new u8(Math.max(bl * 2, l2));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        final = bits(dat, pos, 1);\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n          if (t > sl) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + l);\n          buf.set(dat.subarray(s, t), bt);\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1)\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n        else if (type == 2) {\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          var ldt = new u8(tl);\n          var clt = new u8(19);\n          for (var i2 = 0; i2 < hcLen; ++i2) {\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n          }\n          pos += hcLen * 3;\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\n          var clm = hMap(clt, clb, 1);\n          for (var i2 = 0; i2 < tl; ) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            pos += r & 15;\n            var s = r >> 4;\n            if (s < 16) {\n              ldt[i2++] = s;\n            } else {\n              var c = 0, n = 0;\n              if (s == 16)\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\n              else if (s == 17)\n                n = 3 + bits(dat, pos, 7), pos += 3;\n              else if (s == 18)\n                n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--)\n                ldt[i2++] = c;\n            }\n          }\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n          lbt = max(lt);\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else\n          err(1);\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n      }\n      if (resize)\n        cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (; ; lpos = pos) {\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n        pos += c & 15;\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (!c)\n          err(2);\n        if (sym < 256)\n          buf[bt++] = sym;\n        else if (sym == 256) {\n          lpos = pos, lm = null;\n          break;\n        } else {\n          var add = sym - 254;\n          if (sym > 264) {\n            var i2 = sym - 257, b = fleb[i2];\n            add = bits(dat, pos, (1 << b) - 1) + fl[i2];\n            pos += b;\n          }\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n          if (!d)\n            err(3);\n          pos += d & 15;\n          var dt = fd[dsym];\n          if (dsym > 3) {\n            var b = fdeb[dsym];\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n          }\n          if (pos > tbts) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + 131072);\n          var end = bt + add;\n          if (bt < dt) {\n            var shift = dl - dt, dend = Math.min(dt, end);\n            if (shift + bt < 0)\n              err(3);\n            for (; bt < dend; ++bt)\n              buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt)\n            buf[bt] = buf[bt - dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm)\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  var et = /* @__PURE__ */ new u8(0);\n  var mrg = function(a, b) {\n    var o = {};\n    for (var k in a)\n      o[k] = a[k];\n    for (var k in b)\n      o[k] = b[k];\n    return o;\n  };\n  var wcln = function(fn, fnStr, td2) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\\s+/g, "").split(",");\n    for (var i2 = 0; i2 < dt.length; ++i2) {\n      var v = dt[i2], k = ks[i2];\n      if (typeof v == "function") {\n        fnStr += ";" + k + "=";\n        var st_1 = v.toString();\n        if (v.prototype) {\n          if (st_1.indexOf("[native code]") != -1) {\n            var spInd = st_1.indexOf(" ", 8) + 1;\n            fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));\n          } else {\n            fnStr += st_1;\n            for (var t in v.prototype)\n              fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();\n          }\n        } else\n          fnStr += st_1;\n      } else\n        td2[k] = v;\n    }\n    return fnStr;\n  };\n  var ch = [];\n  var cbfs = function(v) {\n    var tl = [];\n    for (var k in v) {\n      if (v[k].buffer) {\n        tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n      }\n    }\n    return tl;\n  };\n  var wrkr = function(fns, init, id, cb) {\n    if (!ch[id]) {\n      var fnStr = "", td_1 = {}, m = fns.length - 1;\n      for (var i2 = 0; i2 < m; ++i2)\n        fnStr = wcln(fns[i2], fnStr, td_1);\n      ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td2 = mrg({}, ch[id].e);\n    return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);\n  };\n  var bInflt = function() {\n    return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];\n  };\n  var pbf = function(msg) {\n    return postMessage(msg, [msg.buffer]);\n  };\n  var gopt = function(o) {\n    return o && {\n      out: o.size && new u8(o.size),\n      dictionary: o.dictionary\n    };\n  };\n  var cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err2, dat2) {\n      w.terminate();\n      cb(err2, dat2);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function() {\n      w.terminate();\n    };\n  };\n  var b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n  };\n  var b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n  };\n  var b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n  };\n  var gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n      err(6, "invalid gzip data");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n      st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n      ;\n    return st + (flg & 2);\n  };\n  var Inflate = /* @__PURE__ */ function() {\n    function Inflate2(opts, cb) {\n      if (typeof opts == "function")\n        cb = opts, opts = {};\n      this.ondata = cb;\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n      this.s = { i: 0, b: dict ? dict.length : 0 };\n      this.o = new u8(32768);\n      this.p = new u8(0);\n      if (dict)\n        this.o.set(dict);\n    }\n    Inflate2.prototype.e = function(c) {\n      if (!this.ondata)\n        err(5);\n      if (this.d)\n        err(4);\n      if (!this.p.length)\n        this.p = c;\n      else if (c.length) {\n        var n = new u8(this.p.length + c.length);\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\n      }\n    };\n    Inflate2.prototype.c = function(final) {\n      this.s.i = +(this.d = final || false);\n      var bts = this.s.b;\n      var dt = inflt(this.p, this.s, this.o);\n      this.ondata(slc(dt, bts, this.s.b), this.d);\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    Inflate2.prototype.push = function(chunk, final) {\n      this.e(chunk), this.c(final);\n    };\n    return Inflate2;\n  }();\n  function inflate(data, opts, cb) {\n    if (!cb)\n      cb = opts, opts = {};\n    if (typeof cb != "function")\n      err(7);\n    return cbify(data, opts, [\n      bInflt\n    ], function(ev) {\n      return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));\n    }, 1, cb);\n  }\n  function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n  }\n  var Gunzip = /* @__PURE__ */ function() {\n    function Gunzip2(opts, cb) {\n      this.v = 1;\n      this.r = 0;\n      Inflate.call(this, opts, cb);\n    }\n    Gunzip2.prototype.push = function(chunk, final) {\n      Inflate.prototype.e.call(this, chunk);\n      this.r += chunk.length;\n      if (this.v) {\n        var p = this.p.subarray(this.v - 1);\n        var s = p.length > 3 ? gzs(p) : 4;\n        if (s > p.length) {\n          if (!final)\n            return;\n        } else if (this.v > 1 && this.onmember) {\n          this.onmember(this.r - p.length);\n        }\n        this.p = p.subarray(s), this.v = 0;\n      }\n      Inflate.prototype.c.call(this, final);\n      if (this.s.f && !this.s.l && !final) {\n        this.v = shft(this.s.p) + 9;\n        this.s = { i: 0 };\n        this.o = new u8(0);\n        this.push(new u8(0), final);\n      }\n    };\n    return Gunzip2;\n  }();\n  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();\n  try {\n    td.decode(et, { stream: true });\n  } catch (e) {\n  }\n  var dutf8 = function(d) {\n    for (var r = "", i2 = 0; ; ) {\n      var c = d[i2++];\n      var eb = (c > 127) + (c > 223) + (c > 239);\n      if (i2 + eb > d.length)\n        return { s: r, r: slc(d, i2 - 1) };\n      if (!eb)\n        r += String.fromCharCode(c);\n      else if (eb == 3) {\n        c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n      } else if (eb & 1)\n        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);\n      else\n        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);\n    }\n  };\n  function strFromU8(dat, latin1) {\n    if (latin1) {\n      var r = "";\n      for (var i2 = 0; i2 < dat.length; i2 += 16384)\n        r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));\n      return r;\n    } else if (td) {\n      return td.decode(dat);\n    } else {\n      var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;\n      if (r.length)\n        err(8);\n      return s;\n    }\n  }\n  var slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n  };\n  var zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n  };\n  var z64e = function(d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n      ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n  };\n  var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {\n    fn();\n  };\n  function unzip(data, opts, cb) {\n    if (!cb)\n      cb = opts, opts = {};\n    if (typeof cb != "function")\n      err(7);\n    var term = [];\n    var tAll = function() {\n      for (var i3 = 0; i3 < term.length; ++i3)\n        term[i3]();\n    };\n    var files = {};\n    var cbd = function(a, b) {\n      mt(function() {\n        cb(a, b);\n      });\n    };\n    mt(function() {\n      cbd = cb;\n    });\n    var e = data.length - 22;\n    for (; b4(data, e) != 101010256; --e) {\n      if (!e || data.length - e > 65558) {\n        cbd(err(13, 0, 1), null);\n        return tAll;\n      }\n    }\n    var lft = b2(data, e + 8);\n    if (lft) {\n      var c = lft;\n      var o = b4(data, e + 16);\n      var z = o == 4294967295 || c == 65535;\n      if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 101075792;\n        if (z) {\n          c = lft = b4(data, ze + 32);\n          o = b4(data, ze + 48);\n        }\n      }\n      var fltr = opts && opts.filter;\n      var _loop_3 = function(i3) {\n        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e2, d) {\n          if (e2) {\n            tAll();\n            cbd(e2, null);\n          } else {\n            if (d)\n              files[fn] = d;\n            if (!--lft)\n              cbd(null, files);\n          }\n        };\n        if (!fltr || fltr({\n          name: fn,\n          size: sc,\n          originalSize: su,\n          compression: c_1\n        })) {\n          if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n          else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (su < 524288 || sc > 0.8 * su) {\n              try {\n                cbl(null, inflateSync(infl, { out: new u8(su) }));\n              } catch (e2) {\n                cbl(e2, null);\n              }\n            } else\n              term.push(inflate(infl, { size: su }, cbl));\n          } else\n            cbl(err(14, "unknown compression type " + c_1, 1), null);\n        } else\n          cbl(null, null);\n      };\n      for (var i2 = 0; i2 < c; ++i2) {\n        _loop_3(i2);\n      }\n    } else\n      cbd(null, {});\n    return tAll;\n  }\n  function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 101010256; --e) {\n      if (!e || data.length - e > 65558)\n        err(13);\n    }\n    var c = b2(data, e + 8);\n    if (!c)\n      return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n      var ze = b4(data, e - 12);\n      z = b4(data, ze) == 101075792;\n      if (z) {\n        c = b4(data, ze + 32);\n        o = b4(data, ze + 48);\n      }\n    }\n    var fltr = opts && opts.filter;\n    for (var i2 = 0; i2 < c; ++i2) {\n      var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n      o = no;\n      if (!fltr || fltr({\n        name: fn,\n        size: sc,\n        originalSize: su,\n        compression: c_2\n      })) {\n        if (!c_2)\n          files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n        else\n          err(14, "unknown compression type " + c_2);\n      }\n    }\n    return files;\n  }\n  /**\n   * @license\n   * Copyright 2010-2025 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   */\n  const REVISION = "178";\n  const NoColorSpace = "";\n  const SRGBColorSpace = "srgb";\n  const LinearSRGBColorSpace = "srgb-linear";\n  const LinearTransfer = "linear";\n  const SRGBTransfer = "srgb";\n  function clamp(value, min, max2) {\n    return Math.max(min, Math.min(max2, value));\n  }\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  function lerp(x2, y, t) {\n    return (1 - t) * x2 + t * y;\n  }\n  class Quaternion {\n    /**\n     * Constructs a new quaternion.\n     *\n     * @param {number} [x=0] - The x value of this quaternion.\n     * @param {number} [y=0] - The y value of this quaternion.\n     * @param {number} [z=0] - The z value of this quaternion.\n     * @param {number} [w=1] - The w value of this quaternion.\n     */\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      this.isQuaternion = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n    }\n    /**\n     * Interpolates between two quaternions via SLERP. This implementation assumes the\n     * quaternion data are managed  in flat arrays.\n     *\n     * @param {Array<number>} dst - The destination array.\n     * @param {number} dstOffset - An offset into the destination array.\n     * @param {Array<number>} src0 - The source array of the first quaternion.\n     * @param {number} srcOffset0 - An offset into the first source array.\n     * @param {Array<number>} src1 -  The source array of the second quaternion.\n     * @param {number} srcOffset1 - An offset into the second source array.\n     * @param {number} t - The interpolation factor in the range `[0,1]`.\n     * @see {@link Quaternion#slerp}\n     */\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        let s = 1 - t;\n        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n        if (sqrSin > Number.EPSILON) {\n          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n        const tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir;\n        if (s === 1 - t) {\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n    /**\n     * Multiplies two quaternions. This implementation assumes the quaternion data are managed\n     * in flat arrays.\n     *\n     * @param {Array<number>} dst - The destination array.\n     * @param {number} dstOffset - An offset into the destination array.\n     * @param {Array<number>} src0 - The source array of the first quaternion.\n     * @param {number} srcOffset0 - An offset into the first source array.\n     * @param {Array<number>} src1 -  The source array of the second quaternion.\n     * @param {number} srcOffset1 - An offset into the second source array.\n     * @return {Array<number>} The destination array.\n     * @see {@link Quaternion#multiplyQuaternions}.\n     */\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      const x0 = src0[srcOffset0];\n      const y0 = src0[srcOffset0 + 1];\n      const z0 = src0[srcOffset0 + 2];\n      const w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1];\n      const y1 = src1[srcOffset1 + 1];\n      const z1 = src1[srcOffset1 + 2];\n      const w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n    /**\n     * The x value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The y value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The z value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The w value of this quaternion.\n     *\n     * @type {number}\n     * @default 1\n     */\n    get w() {\n      return this._w;\n    }\n    set w(value) {\n      this._w = value;\n      this._onChangeCallback();\n    }\n    /**\n     * Sets the quaternion components.\n     *\n     * @param {number} x - The x value of this quaternion.\n     * @param {number} y - The y value of this quaternion.\n     * @param {number} z - The z value of this quaternion.\n     * @param {number} w - The w value of this quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    set(x2, y, z, w) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Returns a new quaternion with copied values from this instance.\n     *\n     * @return {Quaternion} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    /**\n     * Copies the values of the given quaternion to this instance.\n     *\n     * @param {Quaternion} quaternion - The quaternion to copy.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the rotation specified by the given\n     * Euler angles.\n     *\n     * @param {Euler} euler - The Euler angles.\n     * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromEuler(euler, update = true) {\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\n      const cos = Math.cos;\n      const sin = Math.sin;\n      const c1 = cos(x2 / 2);\n      const c2 = cos(y / 2);\n      const c3 = cos(z / 2);\n      const s1 = sin(x2 / 2);\n      const s2 = sin(y / 2);\n      const s3 = sin(z / 2);\n      switch (order) {\n        case "XYZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "YXZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "ZXY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "ZYX":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "YZX":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "XZY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        default:\n          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);\n      }\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the given axis and angle.\n     *\n     * @param {Vector3} axis - The normalized axis.\n     * @param {number} angle - The angle in radians.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromAxisAngle(axis, angle) {\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the given rotation matrix.\n     *\n     * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromRotationMatrix(m) {\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n      if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n        this._w = (m32 - m23) / s;\n        this._x = 0.25 * s;\n        this._y = (m12 + m21) / s;\n        this._z = (m13 + m31) / s;\n      } else if (m22 > m33) {\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n        this._w = (m13 - m31) / s;\n        this._x = (m12 + m21) / s;\n        this._y = 0.25 * s;\n        this._z = (m23 + m32) / s;\n      } else {\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n        this._w = (m21 - m12) / s;\n        this._x = (m13 + m31) / s;\n        this._y = (m23 + m32) / s;\n        this._z = 0.25 * s;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion to the rotation required to rotate the direction vector\n     * `vFrom` to the direction vector `vTo`.\n     *\n     * @param {Vector3} vFrom - The first (normalized) direction vector.\n     * @param {Vector3} vTo - The second (normalized) direction vector.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromUnitVectors(vFrom, vTo) {\n      let r = vFrom.dot(vTo) + 1;\n      if (r < 1e-8) {\n        r = 0;\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n      return this.normalize();\n    }\n    /**\n     * Returns the angle between this quaternion and the given one in radians.\n     *\n     * @param {Quaternion} q - The quaternion to compute the angle with.\n     * @return {number} The angle in radians.\n     */\n    angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n    /**\n     * Rotates this quaternion by a given angular step to the given quaternion.\n     * The method ensures that the final quaternion will not overshoot `q`.\n     *\n     * @param {Quaternion} q - The target quaternion.\n     * @param {number} step - The angular step in radians.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    rotateTowards(q, step) {\n      const angle = this.angleTo(q);\n      if (angle === 0) return this;\n      const t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n    /**\n     * Sets this quaternion to the identity quaternion; that is, to the\n     * quaternion that represents "no rotation".\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    identity() {\n      return this.set(0, 0, 0, 1);\n    }\n    /**\n     * Inverts this quaternion via {@link Quaternion#conjugate}. The\n     * quaternion is assumed to have unit length.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    invert() {\n      return this.conjugate();\n    }\n    /**\n     * Returns the rotational conjugate of this quaternion. The conjugate of a\n     * quaternion represents the same rotation in the opposite direction about\n     * the rotational axis.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Calculates the dot product of this quaternion and the given one.\n     *\n     * @param {Quaternion} v - The quaternion to compute the dot product with.\n     * @return {number} The result of the dot product.\n     */\n    dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n    /**\n     * Computes the squared Euclidean length (straight-line length) of this quaternion,\n     * considered as a 4 dimensional vector. This can be useful if you are comparing the\n     * lengths of two quaternions, as this is a slightly more efficient calculation than\n     * {@link Quaternion#length}.\n     *\n     * @return {number} The squared Euclidean length.\n     */\n    lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    /**\n     * Computes the Euclidean length (straight-line length) of this quaternion,\n     * considered as a 4 dimensional vector.\n     *\n     * @return {number} The Euclidean length.\n     */\n    length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n    /**\n     * Normalizes this quaternion - that is, calculated the quaternion that performs\n     * the same rotation as this one, but has a length equal to `1`.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    normalize() {\n      let l = this.length();\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Multiplies this quaternion by the given one.\n     *\n     * @param {Quaternion} q - The quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    /**\n     * Pre-multiplies this quaternion by the given one.\n     *\n     * @param {Quaternion} q - The quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    /**\n     * Multiplies the given quaternions and stores the result in this instance.\n     *\n     * @param {Quaternion} a - The first quaternion.\n     * @param {Quaternion} b - The second quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    multiplyQuaternions(a, b) {\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Performs a spherical linear interpolation between quaternions.\n     *\n     * @param {Quaternion} qb - The target quaternion.\n     * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      const x2 = this._x, y = this._y, z = this._z, w = this._w;\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n      if (cosHalfTheta >= 1) {\n        this._w = w;\n        this._x = x2;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        const s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x2 + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n        return this;\n      }\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x2 * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Performs a spherical linear interpolation between the given quaternions\n     * and stores the result in this quaternion.\n     *\n     * @param {Quaternion} qa - The source quaternion.\n     * @param {Quaternion} qb - The target quaternion.\n     * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n    /**\n     * Sets this quaternion to a uniformly random, normalized quaternion.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    random() {\n      const theta1 = 2 * Math.PI * Math.random();\n      const theta2 = 2 * Math.PI * Math.random();\n      const x0 = Math.random();\n      const r1 = Math.sqrt(1 - x0);\n      const r2 = Math.sqrt(x0);\n      return this.set(\n        r1 * Math.sin(theta1),\n        r1 * Math.cos(theta1),\n        r2 * Math.sin(theta2),\n        r2 * Math.cos(theta2)\n      );\n    }\n    /**\n     * Returns `true` if this quaternion is equal with the given one.\n     *\n     * @param {Quaternion} quaternion - The quaternion to test for equality.\n     * @return {boolean} Whether this quaternion is equal with the given one.\n     */\n    equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n    /**\n     * Sets this quaternion\'s components from the given array.\n     *\n     * @param {Array<number>} array - An array holding the quaternion component values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    fromArray(array, offset = 0) {\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Writes the components of this quaternion to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the quaternion components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The quaternion components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n    /**\n     * Sets the components of this quaternion from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.\n     * @param {number} index - The index into the attribute.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * This methods defines the serialization result of this class. Returns the\n     * numerical elements of this quaternion in an array of format `[x, y, z, w]`.\n     *\n     * @return {Array<number>} The serialized quaternion.\n     */\n    toJSON() {\n      return this.toArray();\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._w;\n    }\n  }\n  class Vector3 {\n    /**\n     * Constructs a new 3D vector.\n     *\n     * @param {number} [x=0] - The x value of this vector.\n     * @param {number} [y=0] - The y value of this vector.\n     * @param {number} [z=0] - The z value of this vector.\n     */\n    constructor(x2 = 0, y = 0, z = 0) {\n      Vector3.prototype.isVector3 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n    }\n    /**\n     * Sets the vector components.\n     *\n     * @param {number} x - The value of the x component.\n     * @param {number} y - The value of the y component.\n     * @param {number} z - The value of the z component.\n     * @return {Vector3} A reference to this vector.\n     */\n    set(x2, y, z) {\n      if (z === void 0) z = this.z;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    /**\n     * Sets the vector components to the same value.\n     *\n     * @param {number} scalar - The value to set for all vector components.\n     * @return {Vector3} A reference to this vector.\n     */\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n    /**\n     * Sets the vector\'s x component to the given value\n     *\n     * @param {number} x - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    /**\n     * Sets the vector\'s y component to the given value\n     *\n     * @param {number} y - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    /**\n     * Sets the vector\'s z component to the given value\n     *\n     * @param {number} z - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    /**\n     * Allows to set a vector component with an index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n     * @param {number} value - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    /**\n     * Returns the value of the vector component which matches the given index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n     * @return {number} A vector component value.\n     */\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    /**\n     * Returns a new vector with copied values from this instance.\n     *\n     * @return {Vector3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n    /**\n     * Copies the values of the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to copy.\n     * @return {Vector3} A reference to this vector.\n     */\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    /**\n     * Adds the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to add.\n     * @return {Vector3} A reference to this vector.\n     */\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    /**\n     * Adds the given scalar value to all components of this instance.\n     *\n     * @param {number} s - The scalar to add.\n     * @return {Vector3} A reference to this vector.\n     */\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    /**\n     * Adds the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    /**\n     * Adds the given vector scaled by the given factor to this instance.\n     *\n     * @param {Vector3|Vector4} v - The vector.\n     * @param {number} s - The factor that scales `v`.\n     * @return {Vector3} A reference to this vector.\n     */\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n    /**\n     * Subtracts the given vector from this instance.\n     *\n     * @param {Vector3} v - The vector to subtract.\n     * @return {Vector3} A reference to this vector.\n     */\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    /**\n     * Subtracts the given scalar value from all components of this instance.\n     *\n     * @param {number} s - The scalar to subtract.\n     * @return {Vector3} A reference to this vector.\n     */\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    /**\n     * Subtracts the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    /**\n     * Multiplies the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to multiply.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    /**\n     * Multiplies the given scalar value with all components of this instance.\n     *\n     * @param {number} scalar - The scalar to multiply.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n    /**\n     * Multiplies the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    /**\n     * Applies the given Euler rotation to this vector.\n     *\n     * @param {Euler} euler - The Euler angles.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyEuler(euler) {\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n    /**\n     * Applies a rotation specified by an axis and an angle to this vector.\n     *\n     * @param {Vector3} axis - A normalized vector representing the rotation axis.\n     * @param {number} angle - The angle in radians.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n    /**\n     * Multiplies this vector with the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The 3x3 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\n      return this;\n    }\n    /**\n     * Multiplies this vector by the given normal matrix and normalizes\n     * the result.\n     *\n     * @param {Matrix3} m - The normal matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n    /**\n     * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and\n     * divides by perspective.\n     *\n     * @param {Matrix4} m - The matrix to apply.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    /**\n     * Applies the given Quaternion to this vector.\n     *\n     * @param {Quaternion} q - The Quaternion.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyQuaternion(q) {\n      const vx = this.x, vy = this.y, vz = this.z;\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n      const tx = 2 * (qy * vz - qz * vy);\n      const ty = 2 * (qz * vx - qx * vz);\n      const tz = 2 * (qx * vy - qy * vx);\n      this.x = vx + qw * tx + qy * tz - qz * ty;\n      this.y = vy + qw * ty + qz * tx - qx * tz;\n      this.z = vz + qw * tz + qx * ty - qy * tx;\n      return this;\n    }\n    /**\n     * Projects this vector from world space into the camera\'s normalized\n     * device coordinate (NDC) space.\n     *\n     * @param {Camera} camera - The camera.\n     * @return {Vector3} A reference to this vector.\n     */\n    project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n    /**\n     * Unprojects this vector from the camera\'s normalized device coordinate (NDC)\n     * space into world space.\n     *\n     * @param {Camera} camera - The camera.\n     * @return {Vector3} A reference to this vector.\n     */\n    unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n    /**\n     * Transforms the direction of this vector by a matrix (the upper left 3 x 3\n     * subset of the given 4x4 matrix and then normalizes the result.\n     *\n     * @param {Matrix4} m - The matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    transformDirection(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    /**\n     * Divides this instance by the given vector.\n     *\n     * @param {Vector3} v - The vector to divide.\n     * @return {Vector3} A reference to this vector.\n     */\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    /**\n     * Divides this vector by the given scalar.\n     *\n     * @param {number} scalar - The scalar to divide.\n     * @return {Vector3} A reference to this vector.\n     */\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    /**\n     * If this vector\'s x, y or z value is greater than the given vector\'s x, y or z\n     * value, replace that value with the corresponding min value.\n     *\n     * @param {Vector3} v - The vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z value is less than the given vector\'s x, y or z\n     * value, replace that value with the corresponding max value.\n     *\n     * @param {Vector3} v - The vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z value is greater than the max vector\'s x, y or z\n     * value, it is replaced by the corresponding value.\n     * If this vector\'s x, y or z value is less than the min vector\'s x, y or z value,\n     * it is replaced by the corresponding value.\n     *\n     * @param {Vector3} min - The minimum x, y and z values.\n     * @param {Vector3} max - The maximum x, y and z values in the desired range.\n     * @return {Vector3} A reference to this vector.\n     */\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z values are greater than the max value, they are\n     * replaced by the max value.\n     * If this vector\'s x, y or z values are less than the min value, they are\n     * replaced by the min value.\n     *\n     * @param {number} minVal - The minimum value the components will be clamped to.\n     * @param {number} maxVal - The maximum value the components will be clamped to.\n     * @return {Vector3} A reference to this vector.\n     */\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      return this;\n    }\n    /**\n     * If this vector\'s length is greater than the max value, it is replaced by\n     * the max value.\n     * If this vector\'s length is less than the min value, it is replaced by the\n     * min value.\n     *\n     * @param {number} min - The minimum value the vector length will be clamped to.\n     * @param {number} max - The maximum value the vector length will be clamped to.\n     * @return {Vector3} A reference to this vector.\n     */\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    /**\n     * The components of this vector are rounded down to the nearest integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded up to the nearest integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded to the nearest integer value\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded towards zero (up if negative,\n     * down if positive) to an integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      return this;\n    }\n    /**\n     * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n    /**\n     * Calculates the dot product of the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to compute the dot product with.\n     * @return {number} The result of the dot product.\n     */\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    // TODO lengthSquared?\n    /**\n     * Computes the square of the Euclidean length (straight-line length) from\n     * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should\n     * compare the length squared instead as it is slightly more efficient to calculate.\n     *\n     * @return {number} The square length of this vector.\n     */\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    /**\n     * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).\n     *\n     * @return {number} The length of this vector.\n     */\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    /**\n     * Computes the Manhattan length of this vector.\n     *\n     * @return {number} The length of this vector.\n     */\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    /**\n     * Converts this vector to a unit vector - that is, sets it equal to a vector\n     * with the same direction as this one, but with a vector length of `1`.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    /**\n     * Sets this vector to a vector with the same direction as this one, but\n     * with the specified length.\n     *\n     * @param {number} length - The new length of this vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    /**\n     * Linearly interpolates between the given vector and this instance, where\n     * alpha is the percent distance along the line - alpha = 0 will be this\n     * vector, and alpha = 1 will be the given one.\n     *\n     * @param {Vector3} v - The vector to interpolate towards.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector3} A reference to this vector.\n     */\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates between the given vectors, where alpha is the percent\n     * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n     * be the second one. The result is stored in this instance.\n     *\n     * @param {Vector3} v1 - The first vector.\n     * @param {Vector3} v2 - The second vector.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector3} A reference to this vector.\n     */\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n    /**\n     * Calculates the cross product of the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to compute the cross product with.\n     * @return {Vector3} The result of the cross product.\n     */\n    cross(v) {\n      return this.crossVectors(this, v);\n    }\n    /**\n     * Calculates the cross product of the given vectors and stores the result\n     * in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    crossVectors(a, b) {\n      const ax = a.x, ay = a.y, az = a.z;\n      const bx = b.x, by = b.y, bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    /**\n     * Projects this vector onto the given one.\n     *\n     * @param {Vector3} v - The vector to project to.\n     * @return {Vector3} A reference to this vector.\n     */\n    projectOnVector(v) {\n      const denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      const scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n    /**\n     * Projects this vector onto a plane by subtracting this\n     * vector projected onto the plane\'s normal from this vector.\n     *\n     * @param {Vector3} planeNormal - The plane normal.\n     * @return {Vector3} A reference to this vector.\n     */\n    projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n      return this.sub(_vector$c);\n    }\n    /**\n     * Reflects this vector off a plane orthogonal to the given normal vector.\n     *\n     * @param {Vector3} normal - The (normalized) normal vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    reflect(normal) {\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    /**\n     * Returns the angle between the given vector and this instance in radians.\n     *\n     * @param {Vector3} v - The vector to compute the angle with.\n     * @return {number} The angle in radians.\n     */\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    /**\n     * Computes the distance from the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to compute the distance to.\n     * @return {number} The distance.\n     */\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    /**\n     * Computes the squared distance from the given vector to this instance.\n     * If you are just comparing the distance with another distance, you should compare\n     * the distance squared instead as it is slightly more efficient to calculate.\n     *\n     * @param {Vector3} v - The vector to compute the squared distance to.\n     * @return {number} The squared distance.\n     */\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    /**\n     * Computes the Manhattan distance from the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to compute the Manhattan distance to.\n     * @return {number} The Manhattan distance.\n     */\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    /**\n     * Sets the vector components from the given spherical coordinates.\n     *\n     * @param {Spherical} s - The spherical coordinates.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    /**\n     * Sets the vector components from the given spherical coordinates.\n     *\n     * @param {number} radius - The radius.\n     * @param {number} phi - The phi angle in radians.\n     * @param {number} theta - The theta angle in radians.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromSphericalCoords(radius, phi, theta) {\n      const sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    /**\n     * Sets the vector components from the given cylindrical coordinates.\n     *\n     * @param {Cylindrical} c - The cylindrical coordinates.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n    /**\n     * Sets the vector components from the given cylindrical coordinates.\n     *\n     * @param {number} radius - The radius.\n     * @param {number} theta - The theta angle in radians.\n     * @param {number} y - The y value.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n    /**\n     * Sets the vector components to the position elements of the\n     * given transformation matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    /**\n     * Sets the vector components to the scale elements of the\n     * given transformation matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixScale(m) {\n      const sx = this.setFromMatrixColumn(m, 0).length();\n      const sy = this.setFromMatrixColumn(m, 1).length();\n      const sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n    /**\n     * Sets the vector components from the specified matrix column.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @param {number} index - The column index.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n    /**\n     * Sets the vector components from the specified matrix column.\n     *\n     * @param {Matrix3} m - The 3x3 matrix.\n     * @param {number} index - The column index.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n    /**\n     * Sets the vector components from the given Euler angles.\n     *\n     * @param {Euler} e - The Euler angles to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n    /**\n     * Sets the vector components from the RGB components of the\n     * given color.\n     *\n     * @param {Color} c - The color to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromColor(c) {\n      this.x = c.r;\n      this.y = c.g;\n      this.z = c.b;\n      return this;\n    }\n    /**\n     * Returns `true` if this vector is equal with the given one.\n     *\n     * @param {Vector3} v - The vector to test for equality.\n     * @return {boolean} Whether this vector is equal with the given one.\n     */\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n    /**\n     * Sets this vector\'s x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`\n     * and z value to be `array[ offset + 2 ]`.\n     *\n     * @param {Array<number>} array - An array holding the vector component values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Vector3} A reference to this vector.\n     */\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    /**\n     * Writes the components of this vector to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the vector components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The vector components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    /**\n     * Sets the components of this vector from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n     * @param {number} index - The index into the attribute.\n     * @return {Vector3} A reference to this vector.\n     */\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n    /**\n     * Sets each component of this vector to a pseudo-random value between `0` and\n     * `1`, excluding `1`.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n    /**\n     * Sets this vector to a uniformly random point on a unit sphere.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    randomDirection() {\n      const theta = Math.random() * Math.PI * 2;\n      const u = Math.random() * 2 - 1;\n      const c = Math.sqrt(1 - u * u);\n      this.x = c * Math.cos(theta);\n      this.y = u;\n      this.z = c * Math.sin(theta);\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n    }\n  }\n  const _vector$c = /* @__PURE__ */ new Vector3();\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\n  class Matrix3 {\n    /**\n     * Constructs a new 3x3 matrix. The arguments are supposed to be\n     * in row-major order. If no arguments are provided, the constructor\n     * initializes the matrix as an identity matrix.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n13] - 1-3 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     * @param {number} [n23] - 2-3 matrix element.\n     * @param {number} [n31] - 3-1 matrix element.\n     * @param {number} [n32] - 3-2 matrix element.\n     * @param {number} [n33] - 3-3 matrix element.\n     */\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      Matrix3.prototype.isMatrix3 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n      }\n    }\n    /**\n     * Sets the elements of the matrix.The arguments are supposed to be\n     * in row-major order.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n13] - 1-3 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     * @param {number} [n23] - 2-3 matrix element.\n     * @param {number} [n31] - 3-1 matrix element.\n     * @param {number} [n32] - 3-2 matrix element.\n     * @param {number} [n33] - 3-3 matrix element.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      const te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n    /**\n     * Sets this matrix to the 3x3 identity matrix.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Copies the values of the given matrix to this instance.\n     *\n     * @param {Matrix3} m - The matrix to copy.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n    /**\n     * Extracts the basis of this matrix into the three axis vectors provided.\n     *\n     * @param {Vector3} xAxis - The basis\'s x axis.\n     * @param {Vector3} yAxis - The basis\'s y axis.\n     * @param {Vector3} zAxis - The basis\'s z axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n    /**\n     * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    setFromMatrix4(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[4],\n        me[8],\n        me[1],\n        me[5],\n        me[9],\n        me[2],\n        me[6],\n        me[10]\n      );\n      return this;\n    }\n    /**\n     * Post-multiplies this matrix by the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix to multiply with.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    /**\n     * Pre-multiplies this matrix by the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix to multiply with.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    /**\n     * Multiples the given 3x3 matrices and stores the result\n     * in this matrix.\n     *\n     * @param {Matrix3} a - The first matrix.\n     * @param {Matrix3} b - The second matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n      const b11 = be[0], b12 = be[3], b13 = be[6];\n      const b21 = be[1], b22 = be[4], b23 = be[7];\n      const b31 = be[2], b32 = be[5], b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    /**\n     * Multiplies every component of the matrix by the given scalar.\n     *\n     * @param {number} s - The scalar.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n    /**\n     * Computes and returns the determinant of this matrix.\n     *\n     * @return {number} The determinant.\n     */\n    determinant() {\n      const te = this.elements;\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\n    }\n    /**\n     * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\n     * You can not invert with a determinant of zero. If you attempt this, the method produces\n     * a zero matrix instead.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n    /**\n     * Transposes this matrix in place.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    transpose() {\n      let tmp;\n      const m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n    /**\n     * Computes the normal matrix which is the inverse transpose of the upper\n     * left 3x3 portion of the given 4x4 matrix.\n     *\n     * @param {Matrix4} matrix4 - The 4x4 matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n    /**\n     * Transposes this matrix into the supplied array, and returns itself unchanged.\n     *\n     * @param {Array<number>} r - An array to store the transposed matrix elements.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    transposeIntoArray(r) {\n      const m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n    /**\n     * Sets the UV transform matrix from offset, repeat, rotation, and center.\n     *\n     * @param {number} tx - Offset x.\n     * @param {number} ty - Offset y.\n     * @param {number} sx - Repeat x.\n     * @param {number} sy - Repeat y.\n     * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.\n     * @param {number} cx - Center x of rotation.\n     * @param {number} cy - Center y of rotation\n     * @return {Matrix3} A reference to this matrix.\n     */\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      const c = Math.cos(rotation);\n      const s = Math.sin(rotation);\n      this.set(\n        sx * c,\n        sx * s,\n        -sx * (c * cx + s * cy) + cx + tx,\n        -sy * s,\n        sy * c,\n        -sy * (-s * cx + c * cy) + cy + ty,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Scales this matrix with the given scalar values.\n     *\n     * @param {number} sx - The amount to scale in the X axis.\n     * @param {number} sy - The amount to scale in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    scale(sx, sy) {\n      this.premultiply(_m3.makeScale(sx, sy));\n      return this;\n    }\n    /**\n     * Rotates this matrix by the given angle.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    rotate(theta) {\n      this.premultiply(_m3.makeRotation(-theta));\n      return this;\n    }\n    /**\n     * Translates this matrix by the given scalar values.\n     *\n     * @param {number} tx - The amount to translate in the X axis.\n     * @param {number} ty - The amount to translate in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    translate(tx, ty) {\n      this.premultiply(_m3.makeTranslation(tx, ty));\n      return this;\n    }\n    // for 2D Transforms\n    /**\n     * Sets this matrix as a 2D translation transform.\n     *\n     * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.\n     * @param {number} y - The amount to translate in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeTranslation(x2, y) {\n      if (x2.isVector2) {\n        this.set(\n          1,\n          0,\n          x2.x,\n          0,\n          1,\n          x2.y,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          x2,\n          0,\n          1,\n          y,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    /**\n     * Sets this matrix as a 2D rotational transformation.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeRotation(theta) {\n      const c = Math.cos(theta);\n      const s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix as a 2D scale transform.\n     *\n     * @param {number} x - The amount to scale in the X axis.\n     * @param {number} y - The amount to scale in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeScale(x2, y) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Returns `true` if this matrix is equal with the given one.\n     *\n     * @param {Matrix3} matrix - The matrix to test for equality.\n     * @return {boolean} Whether this matrix is equal with the given one.\n     */\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 9; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    /**\n     * Sets the elements of the matrix from the given array.\n     *\n     * @param {Array<number>} array - The matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 9; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    /**\n     * Writes the elements of this matrix to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The matrix elements in column-major order.\n     */\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n    /**\n     * Returns a matrix with copied values from this instance.\n     *\n     * @return {Matrix3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }\n  const _m3 = /* @__PURE__ */ new Matrix3();\n  const _cache = {};\n  function warnOnce(message) {\n    if (message in _cache) return;\n    _cache[message] = true;\n    console.warn(message);\n  }\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n    0.4123908,\n    0.3575843,\n    0.1804808,\n    0.212639,\n    0.7151687,\n    0.0721923,\n    0.0193308,\n    0.1191948,\n    0.9505322\n  );\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n    3.2409699,\n    -1.5373832,\n    -0.4986108,\n    -0.9692436,\n    1.8759675,\n    0.0415551,\n    0.0556301,\n    -0.203977,\n    1.0569715\n  );\n  function createColorManagement() {\n    const ColorManagement2 = {\n      enabled: true,\n      workingColorSpace: LinearSRGBColorSpace,\n      /**\n       * Implementations of supported color spaces.\n       *\n       * Required:\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n       *\t- whitePoint: reference white [ x y ]\n       *\t- transfer: transfer function (pre-defined)\n       *\t- toXYZ: Matrix3 RGB to XYZ transform\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\n       *\t- luminanceCoefficients: RGB luminance coefficients\n       *\n       * Optional:\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n       *\n       * Reference:\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n       */\n      spaces: {},\n      convert: function(color, sourceColorSpace, targetColorSpace) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n          return color;\n        }\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n          color.r = SRGBToLinear(color.r);\n          color.g = SRGBToLinear(color.g);\n          color.b = SRGBToLinear(color.b);\n        }\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n        }\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n          color.r = LinearToSRGB(color.r);\n          color.g = LinearToSRGB(color.g);\n          color.b = LinearToSRGB(color.b);\n        }\n        return color;\n      },\n      workingToColorSpace: function(color, targetColorSpace) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n      },\n      colorSpaceToWorking: function(color, sourceColorSpace) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n      },\n      getPrimaries: function(colorSpace) {\n        return this.spaces[colorSpace].primaries;\n      },\n      getTransfer: function(colorSpace) {\n        if (colorSpace === NoColorSpace) return LinearTransfer;\n        return this.spaces[colorSpace].transfer;\n      },\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n      },\n      define: function(colorSpaces) {\n        Object.assign(this.spaces, colorSpaces);\n      },\n      // Internal APIs\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n      },\n      _getDrawingBufferColorSpace: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n      },\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n      },\n      // Deprecated\n      fromWorkingColorSpace: function(color, targetColorSpace) {\n        warnOnce("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().");\n        return ColorManagement2.workingToColorSpace(color, targetColorSpace);\n      },\n      toWorkingColorSpace: function(color, sourceColorSpace) {\n        warnOnce("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().");\n        return ColorManagement2.colorSpaceToWorking(color, sourceColorSpace);\n      }\n    };\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n    const D65 = [0.3127, 0.329];\n    ColorManagement2.define({\n      [LinearSRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: LinearTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      },\n      [SRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: SRGBTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      }\n    });\n    return ColorManagement2;\n  }\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\n  function SRGBToLinear(c) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  function LinearToSRGB(c) {\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n  }\n  class Box3 {\n    /**\n     * Constructs a new bounding box.\n     *\n     * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.\n     * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.\n     */\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n      this.isBox3 = true;\n      this.min = min;\n      this.max = max2;\n    }\n    /**\n     * Sets the lower and upper boundaries of this box.\n     * Please note that this method only copies the values from the given objects.\n     *\n     * @param {Vector3} min - The lower boundary of the box.\n     * @param {Vector3} max - The upper boundary of the box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    set(min, max2) {\n      this.min.copy(min);\n      this.max.copy(max2);\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given array.\n     *\n     * @param {Array<number>} array - An array holding 3D position data.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromArray(array) {\n      this.makeEmpty();\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\n        this.expandByPoint(_vector$b.fromArray(array, i2));\n      }\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromBufferAttribute(attribute) {\n      this.makeEmpty();\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\n      }\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given array.\n     *\n     * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromPoints(points) {\n      this.makeEmpty();\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        this.expandByPoint(points[i2]);\n      }\n      return this;\n    }\n    /**\n     * Centers this box on the given center vector and sets this box\'s width, height and\n     * depth to the given size values.\n     *\n     * @param {Vector3} center - The center of the box.\n     * @param {Vector3} size - The x, y and z dimensions of the box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromCenterAndSize(center, size) {\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n    /**\n     * Computes the world-axis-aligned bounding box for the given 3D object\n     * (including its children), accounting for the object\'s, and children\'s,\n     * world transforms. The function may result in a larger box than strictly necessary.\n     *\n     * @param {Object3D} object - The 3D object to compute the bounding box for.\n     * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest\n     * world-axis-aligned bounding box at the expense of more computation.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromObject(object, precise = false) {\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n    /**\n     * Returns a new box with copied values from this instance.\n     *\n     * @return {Box3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Copies the values of the given box to this instance.\n     *\n     * @param {Box3} box - The box to copy.\n     * @return {Box3} A reference to this bounding box.\n     */\n    copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n    /**\n     * Makes this box empty which means in encloses a zero space in 3D.\n     *\n     * @return {Box3} A reference to this bounding box.\n     */\n    makeEmpty() {\n      this.min.x = this.min.y = this.min.z = Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n    /**\n     * Returns true if this box includes zero points within its bounds.\n     * Note that a box with equal lower and upper bounds still includes one\n     * point, the one both bounds share.\n     *\n     * @return {boolean} Whether this box is empty or not.\n     */\n    isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n    /**\n     * Returns the center point of this box.\n     *\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The center point.\n     */\n    getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    /**\n     * Returns the dimensions of this box.\n     *\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The size.\n     */\n    getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n    /**\n     * Expands the boundaries of this box to include the given point.\n     *\n     * @param {Vector3} point - The point that should be included by the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    /**\n     * Expands this box equilaterally by the given vector. The width of this\n     * box will be expanded by the x component of the vector in both\n     * directions. The height of this box will be expanded by the y component of\n     * the vector in both directions. The depth of this box will be\n     * expanded by the z component of the vector in both directions.\n     *\n     * @param {Vector3} vector - The vector that should expand the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n    /**\n     * Expands each dimension of the box by the given scalar. If negative, the\n     * dimensions of the box will be contracted.\n     *\n     * @param {number} scalar - The scalar value that should expand the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n    /**\n     * Expands the boundaries of this box to include the given 3D object and\n     * its children, accounting for the object\'s, and children\'s, world\n     * transforms. The function may result in a larger box than strictly\n     * necessary (unless the precise parameter is set to true).\n     *\n     * @param {Object3D} object - The 3D object that should expand the bounding box.\n     * @param {boolean} precise - If set to `true`, the method expands the bounding box\n     * as little as necessary at the expense of more computation.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByObject(object, precise = false) {\n      object.updateWorldMatrix(false, false);\n      const geometry = object.geometry;\n      if (geometry !== void 0) {\n        const positionAttribute = geometry.getAttribute("position");\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\n            if (object.isMesh === true) {\n              object.getVertexPosition(i2, _vector$b);\n            } else {\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\n            }\n            _vector$b.applyMatrix4(object.matrixWorld);\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (object.boundingBox !== void 0) {\n            if (object.boundingBox === null) {\n              object.computeBoundingBox();\n            }\n            _box$4.copy(object.boundingBox);\n          } else {\n            if (geometry.boundingBox === null) {\n              geometry.computeBoundingBox();\n            }\n            _box$4.copy(geometry.boundingBox);\n          }\n          _box$4.applyMatrix4(object.matrixWorld);\n          this.union(_box$4);\n        }\n      }\n      const children = object.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        this.expandByObject(children[i2], precise);\n      }\n      return this;\n    }\n    /**\n     * Returns `true` if the given point lies within or on the boundaries of this box.\n     *\n     * @param {Vector3} point - The point to test.\n     * @return {boolean} Whether the bounding box contains the given point or not.\n     */\n    containsPoint(point) {\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n    }\n    /**\n     * Returns `true` if this bounding box includes the entirety of the given bounding box.\n     * If this box and the given one are identical, this function also returns `true`.\n     *\n     * @param {Box3} box - The bounding box to test.\n     * @return {boolean} Whether the bounding box contains the given bounding box or not.\n     */\n    containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n    /**\n     * Returns a point as a proportion of this box\'s width, height and depth.\n     *\n     * @param {Vector3} point - A point in 3D space.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} A point as a proportion of this box\'s width, height and depth.\n     */\n    getParameter(point, target) {\n      return target.set(\n        (point.x - this.min.x) / (this.max.x - this.min.x),\n        (point.y - this.min.y) / (this.max.y - this.min.y),\n        (point.z - this.min.z) / (this.max.z - this.min.z)\n      );\n    }\n    /**\n     * Returns `true` if the given bounding box intersects with this bounding box.\n     *\n     * @param {Box3} box - The bounding box to test.\n     * @return {boolean} Whether the given bounding box intersects with this bounding box.\n     */\n    intersectsBox(box) {\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n    }\n    /**\n     * Returns `true` if the given bounding sphere intersects with this bounding box.\n     *\n     * @param {Sphere} sphere - The bounding sphere to test.\n     * @return {boolean} Whether the given bounding sphere intersects with this bounding box.\n     */\n    intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, _vector$b);\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    /**\n     * Returns `true` if the given plane intersects with this bounding box.\n     *\n     * @param {Plane} plane - The plane to test.\n     * @return {boolean} Whether the given plane intersects with this bounding box.\n     */\n    intersectsPlane(plane) {\n      let min, max2;\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max2 = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max2 = plane.normal.x * this.min.x;\n      }\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max2 += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max2 += plane.normal.y * this.min.y;\n      }\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max2 += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max2 += plane.normal.z * this.min.z;\n      }\n      return min <= -plane.constant && max2 >= -plane.constant;\n    }\n    /**\n     * Returns `true` if the given triangle intersects with this bounding box.\n     *\n     * @param {Triangle} triangle - The triangle to test.\n     * @return {boolean} Whether the given triangle intersects with this bounding box.\n     */\n    intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      }\n      this.getCenter(_center);\n      _extents.subVectors(this.max, _center);\n      _v0$2.subVectors(triangle.a, _center);\n      _v1$7.subVectors(triangle.b, _center);\n      _v2$4.subVectors(triangle.c, _center);\n      _f0.subVectors(_v1$7, _v0$2);\n      _f1.subVectors(_v2$4, _v1$7);\n      _f2.subVectors(_v0$2, _v2$4);\n      let axes = [\n        0,\n        -_f0.z,\n        _f0.y,\n        0,\n        -_f1.z,\n        _f1.y,\n        0,\n        -_f2.z,\n        _f2.y,\n        _f0.z,\n        0,\n        -_f0.x,\n        _f1.z,\n        0,\n        -_f1.x,\n        _f2.z,\n        0,\n        -_f2.x,\n        -_f0.y,\n        _f0.x,\n        0,\n        -_f1.y,\n        _f1.x,\n        0,\n        -_f2.y,\n        _f2.x,\n        0\n      ];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      _triangleNormal.crossVectors(_f0, _f1);\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n    }\n    /**\n     * Clamps the given point within the bounds of this box.\n     *\n     * @param {Vector3} point - The point to clamp.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The clamped point.\n     */\n    clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n    /**\n     * Returns the euclidean distance from any edge of this box to the specified point. If\n     * the given point lies inside of this box, the distance will be `0`.\n     *\n     * @param {Vector3} point - The point to compute the distance to.\n     * @return {number} The euclidean distance.\n     */\n    distanceToPoint(point) {\n      return this.clampPoint(point, _vector$b).distanceTo(point);\n    }\n    /**\n     * Returns a bounding sphere that encloses this bounding box.\n     *\n     * @param {Sphere} target - The target sphere that is used to store the method\'s result.\n     * @return {Sphere} The bounding sphere that encloses this bounding box.\n     */\n    getBoundingSphere(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n      } else {\n        this.getCenter(target.center);\n        target.radius = this.getSize(_vector$b).length() * 0.5;\n      }\n      return target;\n    }\n    /**\n     * Computes the intersection of this bounding box and the given one, setting the upper\n     * bound of this box to the lesser of the two boxes\' upper bounds and the\n     * lower bound of this box to the greater of the two boxes\' lower bounds. If\n     * there\'s no overlap, makes this box empty.\n     *\n     * @param {Box3} box - The bounding box to intersect with.\n     * @return {Box3} A reference to this bounding box.\n     */\n    intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n    /**\n     * Computes the union of this box and another and the given one, setting the upper\n     * bound of this box to the greater of the two boxes\' upper bounds and the\n     * lower bound of this box to the lesser of the two boxes\' lower bounds.\n     *\n     * @param {Box3} box - The bounding box that will be unioned with this instance.\n     * @return {Box3} A reference to this bounding box.\n     */\n    union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n    /**\n     * Transforms this bounding box by the given 4x4 transformation matrix.\n     *\n     * @param {Matrix4} matrix - The transformation matrix.\n     * @return {Box3} A reference to this bounding box.\n     */\n    applyMatrix4(matrix) {\n      if (this.isEmpty()) return this;\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      this.setFromPoints(_points);\n      return this;\n    }\n    /**\n     * Adds the given offset to both the upper and lower bounds of this bounding box,\n     * effectively moving it in 3D space.\n     *\n     * @param {Vector3} offset - The offset that should be used to translate the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n    /**\n     * Returns `true` if this bounding box is equal with the given one.\n     *\n     * @param {Box3} box - The box to test for equality.\n     * @return {boolean} Whether this bounding box is equal with the given one.\n     */\n    equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n    /**\n     * Returns a serialized structure of the bounding box.\n     *\n     * @return {Object} Serialized structure with fields representing the object state.\n     */\n    toJSON() {\n      return {\n        min: this.min.toArray(),\n        max: this.max.toArray()\n      };\n    }\n    /**\n     * Returns a serialized structure of the bounding box.\n     *\n     * @param {Object} json - The serialized json to set the box from.\n     * @return {Box3} A reference to this bounding box.\n     */\n    fromJSON(json) {\n      this.min.fromArray(json.min);\n      this.max.fromArray(json.max);\n      return this;\n    }\n  }\n  const _points = [\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3()\n  ];\n  const _vector$b = /* @__PURE__ */ new Vector3();\n  const _box$4 = /* @__PURE__ */ new Box3();\n  const _v0$2 = /* @__PURE__ */ new Vector3();\n  const _v1$7 = /* @__PURE__ */ new Vector3();\n  const _v2$4 = /* @__PURE__ */ new Vector3();\n  const _f0 = /* @__PURE__ */ new Vector3();\n  const _f1 = /* @__PURE__ */ new Vector3();\n  const _f2 = /* @__PURE__ */ new Vector3();\n  const _center = /* @__PURE__ */ new Vector3();\n  const _extents = /* @__PURE__ */ new Vector3();\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\n  const _testAxis = /* @__PURE__ */ new Vector3();\n  function satForAxes(axes, v0, v1, v2, extents) {\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\n      _testAxis.fromArray(axes, i2);\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n      const p0 = v0.dot(_testAxis);\n      const p1 = v1.dot(_testAxis);\n      const p2 = v2.dot(_testAxis);\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const _colorKeywords = {\n    "aliceblue": 15792383,\n    "antiquewhite": 16444375,\n    "aqua": 65535,\n    "aquamarine": 8388564,\n    "azure": 15794175,\n    "beige": 16119260,\n    "bisque": 16770244,\n    "black": 0,\n    "blanchedalmond": 16772045,\n    "blue": 255,\n    "blueviolet": 9055202,\n    "brown": 10824234,\n    "burlywood": 14596231,\n    "cadetblue": 6266528,\n    "chartreuse": 8388352,\n    "chocolate": 13789470,\n    "coral": 16744272,\n    "cornflowerblue": 6591981,\n    "cornsilk": 16775388,\n    "crimson": 14423100,\n    "cyan": 65535,\n    "darkblue": 139,\n    "darkcyan": 35723,\n    "darkgoldenrod": 12092939,\n    "darkgray": 11119017,\n    "darkgreen": 25600,\n    "darkgrey": 11119017,\n    "darkkhaki": 12433259,\n    "darkmagenta": 9109643,\n    "darkolivegreen": 5597999,\n    "darkorange": 16747520,\n    "darkorchid": 10040012,\n    "darkred": 9109504,\n    "darksalmon": 15308410,\n    "darkseagreen": 9419919,\n    "darkslateblue": 4734347,\n    "darkslategray": 3100495,\n    "darkslategrey": 3100495,\n    "darkturquoise": 52945,\n    "darkviolet": 9699539,\n    "deeppink": 16716947,\n    "deepskyblue": 49151,\n    "dimgray": 6908265,\n    "dimgrey": 6908265,\n    "dodgerblue": 2003199,\n    "firebrick": 11674146,\n    "floralwhite": 16775920,\n    "forestgreen": 2263842,\n    "fuchsia": 16711935,\n    "gainsboro": 14474460,\n    "ghostwhite": 16316671,\n    "gold": 16766720,\n    "goldenrod": 14329120,\n    "gray": 8421504,\n    "green": 32768,\n    "greenyellow": 11403055,\n    "grey": 8421504,\n    "honeydew": 15794160,\n    "hotpink": 16738740,\n    "indianred": 13458524,\n    "indigo": 4915330,\n    "ivory": 16777200,\n    "khaki": 15787660,\n    "lavender": 15132410,\n    "lavenderblush": 16773365,\n    "lawngreen": 8190976,\n    "lemonchiffon": 16775885,\n    "lightblue": 11393254,\n    "lightcoral": 15761536,\n    "lightcyan": 14745599,\n    "lightgoldenrodyellow": 16448210,\n    "lightgray": 13882323,\n    "lightgreen": 9498256,\n    "lightgrey": 13882323,\n    "lightpink": 16758465,\n    "lightsalmon": 16752762,\n    "lightseagreen": 2142890,\n    "lightskyblue": 8900346,\n    "lightslategray": 7833753,\n    "lightslategrey": 7833753,\n    "lightsteelblue": 11584734,\n    "lightyellow": 16777184,\n    "lime": 65280,\n    "limegreen": 3329330,\n    "linen": 16445670,\n    "magenta": 16711935,\n    "maroon": 8388608,\n    "mediumaquamarine": 6737322,\n    "mediumblue": 205,\n    "mediumorchid": 12211667,\n    "mediumpurple": 9662683,\n    "mediumseagreen": 3978097,\n    "mediumslateblue": 8087790,\n    "mediumspringgreen": 64154,\n    "mediumturquoise": 4772300,\n    "mediumvioletred": 13047173,\n    "midnightblue": 1644912,\n    "mintcream": 16121850,\n    "mistyrose": 16770273,\n    "moccasin": 16770229,\n    "navajowhite": 16768685,\n    "navy": 128,\n    "oldlace": 16643558,\n    "olive": 8421376,\n    "olivedrab": 7048739,\n    "orange": 16753920,\n    "orangered": 16729344,\n    "orchid": 14315734,\n    "palegoldenrod": 15657130,\n    "palegreen": 10025880,\n    "paleturquoise": 11529966,\n    "palevioletred": 14381203,\n    "papayawhip": 16773077,\n    "peachpuff": 16767673,\n    "peru": 13468991,\n    "pink": 16761035,\n    "plum": 14524637,\n    "powderblue": 11591910,\n    "purple": 8388736,\n    "rebeccapurple": 6697881,\n    "red": 16711680,\n    "rosybrown": 12357519,\n    "royalblue": 4286945,\n    "saddlebrown": 9127187,\n    "salmon": 16416882,\n    "sandybrown": 16032864,\n    "seagreen": 3050327,\n    "seashell": 16774638,\n    "sienna": 10506797,\n    "silver": 12632256,\n    "skyblue": 8900331,\n    "slateblue": 6970061,\n    "slategray": 7372944,\n    "slategrey": 7372944,\n    "snow": 16775930,\n    "springgreen": 65407,\n    "steelblue": 4620980,\n    "tan": 13808780,\n    "teal": 32896,\n    "thistle": 14204888,\n    "tomato": 16737095,\n    "turquoise": 4251856,\n    "violet": 15631086,\n    "wheat": 16113331,\n    "white": 16777215,\n    "whitesmoke": 16119285,\n    "yellow": 16776960,\n    "yellowgreen": 10145074\n  };\n  const _hslA = { h: 0, s: 0, l: 0 };\n  const _hslB = { h: 0, s: 0, l: 0 };\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n  }\n  class Color {\n    /**\n     * Constructs a new color.\n     *\n     * Note that standard method of specifying color in three.js is with a hexadecimal triplet,\n     * and that method is used throughout the rest of the documentation.\n     *\n     * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are\n     * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.\n     * @param {number} [g] - The green component.\n     * @param {number} [b] - The blue component.\n     */\n    constructor(r, g, b) {\n      this.isColor = true;\n      this.r = 1;\n      this.g = 1;\n      this.b = 1;\n      return this.set(r, g, b);\n    }\n    /**\n     * Sets the colors\'s components from the given values.\n     *\n     * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are\n     * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.\n     * @param {number} [g] - The green component.\n     * @param {number} [b] - The blue component.\n     * @return {Color} A reference to this color.\n     */\n    set(r, g, b) {\n      if (g === void 0 && b === void 0) {\n        const value = r;\n        if (value && value.isColor) {\n          this.copy(value);\n        } else if (typeof value === "number") {\n          this.setHex(value);\n        } else if (typeof value === "string") {\n          this.setStyle(value);\n        }\n      } else {\n        this.setRGB(r, g, b);\n      }\n      return this;\n    }\n    /**\n     * Sets the colors\'s components to the given scalar value.\n     *\n     * @param {number} scalar - The scalar value.\n     * @return {Color} A reference to this color.\n     */\n    setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n    /**\n     * Sets this color from a hexadecimal value.\n     *\n     * @param {number} hex - The hexadecimal value.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setHex(hex, colorSpace = SRGBColorSpace) {\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from RGB values.\n     *\n     * @param {number} r - Red channel value between `0.0` and `1.0`.\n     * @param {number} g - Green channel value between `0.0` and `1.0`.\n     * @param {number} b - Blue channel value between `0.0` and `1.0`.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from RGB values.\n     *\n     * @param {number} h - Hue value between `0.0` and `1.0`.\n     * @param {number} s - Saturation value between `0.0` and `1.0`.\n     * @param {number} l - Lightness value between `0.0` and `1.0`.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        const q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,\n     * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or\n     * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -\n     * all 140 color names are supported).\n     *\n     * @param {string} style - Color as a CSS-style string.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setStyle(style, colorSpace = SRGBColorSpace) {\n      function handleAlpha(string) {\n        if (string === void 0) return;\n        if (parseFloat(string) < 1) {\n          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");\n        }\n      }\n      let m;\n      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n        let color;\n        const name = m[1];\n        const components = m[2];\n        switch (name) {\n          case "rgb":\n          case "rgba":\n            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(255, parseInt(color[1], 10)) / 255,\n                Math.min(255, parseInt(color[2], 10)) / 255,\n                Math.min(255, parseInt(color[3], 10)) / 255,\n                colorSpace\n              );\n            }\n            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(100, parseInt(color[1], 10)) / 100,\n                Math.min(100, parseInt(color[2], 10)) / 100,\n                Math.min(100, parseInt(color[3], 10)) / 100,\n                colorSpace\n              );\n            }\n            break;\n          case "hsl":\n          case "hsla":\n            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setHSL(\n                parseFloat(color[1]) / 360,\n                parseFloat(color[2]) / 100,\n                parseFloat(color[3]) / 100,\n                colorSpace\n              );\n            }\n            break;\n          default:\n            console.warn("THREE.Color: Unknown color model " + style);\n        }\n      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n        const hex = m[1];\n        const size = hex.length;\n        if (size === 3) {\n          return this.setRGB(\n            parseInt(hex.charAt(0), 16) / 15,\n            parseInt(hex.charAt(1), 16) / 15,\n            parseInt(hex.charAt(2), 16) / 15,\n            colorSpace\n          );\n        } else if (size === 6) {\n          return this.setHex(parseInt(hex, 16), colorSpace);\n        } else {\n          console.warn("THREE.Color: Invalid hex color " + style);\n        }\n      } else if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n      return this;\n    }\n    /**\n     * Sets this color from a color name. Faster than {@link Color#setStyle} if\n     * you don\'t need the other CSS-style formats.\n     *\n     * For convenience, the list of names is exposed in `Color.NAMES` as a hash.\n     * ```js\n     * Color.NAMES.aliceblue // returns 0xF0F8FF\n     * ```\n     *\n     * @param {string} style - The color name.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setColorName(style, colorSpace = SRGBColorSpace) {\n      const hex = _colorKeywords[style.toLowerCase()];\n      if (hex !== void 0) {\n        this.setHex(hex, colorSpace);\n      } else {\n        console.warn("THREE.Color: Unknown color " + style);\n      }\n      return this;\n    }\n    /**\n     * Returns a new color with copied values from this instance.\n     *\n     * @return {Color} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n    /**\n     * Copies the values of the given color to this instance.\n     *\n     * @param {Color} color - The color to copy.\n     * @return {Color} A reference to this color.\n     */\n    copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n    /**\n     * Copies the given color into this color, and then converts this color from\n     * `SRGBColorSpace` to `LinearSRGBColorSpace`.\n     *\n     * @param {Color} color - The color to copy/convert.\n     * @return {Color} A reference to this color.\n     */\n    copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n    /**\n     * Copies the given color into this color, and then converts this color from\n     * `LinearSRGBColorSpace` to `SRGBColorSpace`.\n     *\n     * @param {Color} color - The color to copy/convert.\n     * @return {Color} A reference to this color.\n     */\n    copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n    /**\n     * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.\n     *\n     * @return {Color} A reference to this color.\n     */\n    convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n    /**\n     * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.\n     *\n     * @return {Color} A reference to this color.\n     */\n    convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n    /**\n     * Returns the hexadecimal value of this color.\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {number} The hexadecimal value.\n     */\n    getHex(colorSpace = SRGBColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n    }\n    /**\n     * Returns the hexadecimal value of this color as a string (for example, \'FFFFFF\').\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {string} The hexadecimal value as a string.\n     */\n    getHexString(colorSpace = SRGBColorSpace) {\n      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n    /**\n     * Converts the colors RGB values into the HSL format and stores them into the\n     * given target object.\n     *\n     * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method\'s result.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {{h:number,s:number,l:number}} The HSL representation of this color.\n     */\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      const max2 = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let hue, saturation;\n      const lightness = (min + max2) / 2;\n      if (min === max2) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        const delta = max2 - min;\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n        switch (max2) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n        hue /= 6;\n      }\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n    /**\n     * Returns the RGB values of this color and stores them into the given target object.\n     *\n     * @param {Color} target - The target color that is used to store the method\'s result.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} The RGB representation of this color.\n     */\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      target.r = _color.r;\n      target.g = _color.g;\n      target.b = _color.b;\n      return target;\n    }\n    /**\n     * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {string} The CSS representation of this color.\n     */\n    getStyle(colorSpace = SRGBColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      if (colorSpace !== SRGBColorSpace) {\n        return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n      }\n      return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n    }\n    /**\n     * Adds the given HSL values to this color\'s values.\n     * Internally, this converts the color\'s RGB values to HSL, adds HSL\n     * and then converts the color back to RGB.\n     *\n     * @param {number} h - Hue value between `0.0` and `1.0`.\n     * @param {number} s - Saturation value between `0.0` and `1.0`.\n     * @param {number} l - Lightness value between `0.0` and `1.0`.\n     * @return {Color} A reference to this color.\n     */\n    offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n    }\n    /**\n     * Adds the RGB values of the given color to the RGB values of this color.\n     *\n     * @param {Color} color - The color to add.\n     * @return {Color} A reference to this color.\n     */\n    add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n    /**\n     * Adds the RGB values of the given colors and stores the result in this instance.\n     *\n     * @param {Color} color1 - The first color.\n     * @param {Color} color2 - The second color.\n     * @return {Color} A reference to this color.\n     */\n    addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n    /**\n     * Adds the given scalar value to the RGB values of this color.\n     *\n     * @param {number} s - The scalar to add.\n     * @return {Color} A reference to this color.\n     */\n    addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n    /**\n     * Subtracts the RGB values of the given color from the RGB values of this color.\n     *\n     * @param {Color} color - The color to subtract.\n     * @return {Color} A reference to this color.\n     */\n    sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n    /**\n     * Multiplies the RGB values of the given color with the RGB values of this color.\n     *\n     * @param {Color} color - The color to multiply.\n     * @return {Color} A reference to this color.\n     */\n    multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n    /**\n     * Multiplies the given scalar value with the RGB values of this color.\n     *\n     * @param {number} s - The scalar to multiply.\n     * @return {Color} A reference to this color.\n     */\n    multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n    /**\n     * Linearly interpolates this color\'s RGB values toward the RGB values of the\n     * given color. The alpha argument can be thought of as the ratio between\n     * the two colors, where `0.0` is this color and `1.0` is the first argument.\n     *\n     * @param {Color} color - The color to converge on.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates between the given colors and stores the result in this instance.\n     * The alpha argument can be thought of as the ratio between the two colors, where `0.0`\n     * is the first and `1.0` is the second color.\n     *\n     * @param {Color} color1 - The first color.\n     * @param {Color} color2 - The second color.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates this color\'s HSL values toward the HSL values of the\n     * given color. It differs from {@link Color#lerp} by not interpolating straight\n     * from one color to the other, but instead going through all the hues in between\n     * those two colors. The alpha argument can be thought of as the ratio between\n     * the two colors, where 0.0 is this color and 1.0 is the first argument.\n     *\n     * @param {Color} color - The color to converge on.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      const h = lerp(_hslA.h, _hslB.h, alpha);\n      const s = lerp(_hslA.s, _hslB.s, alpha);\n      const l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n    /**\n     * Sets the color\'s RGB components from the given 3D vector.\n     *\n     * @param {Vector3} v - The vector to set.\n     * @return {Color} A reference to this color.\n     */\n    setFromVector3(v) {\n      this.r = v.x;\n      this.g = v.y;\n      this.b = v.z;\n      return this;\n    }\n    /**\n     * Transforms this color with the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix.\n     * @return {Color} A reference to this color.\n     */\n    applyMatrix3(m) {\n      const r = this.r, g = this.g, b = this.b;\n      const e = m.elements;\n      this.r = e[0] * r + e[3] * g + e[6] * b;\n      this.g = e[1] * r + e[4] * g + e[7] * b;\n      this.b = e[2] * r + e[5] * g + e[8] * b;\n      return this;\n    }\n    /**\n     * Returns `true` if this color is equal with the given one.\n     *\n     * @param {Color} c - The color to test for equality.\n     * @return {boolean} Whether this bounding color is equal with the given one.\n     */\n    equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n    /**\n     * Sets this color\'s RGB components from the given array.\n     *\n     * @param {Array<number>} array - An array holding the RGB values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Color} A reference to this color.\n     */\n    fromArray(array, offset = 0) {\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n    /**\n     * Writes the RGB components of this color to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the color components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The color components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n    /**\n     * Sets the components of this color from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding color data.\n     * @param {number} index - The index into the attribute.\n     * @return {Color} A reference to this color.\n     */\n    fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n      return this;\n    }\n    /**\n     * This methods defines the serialization result of this class. Returns the color\n     * as a hexadecimal value.\n     *\n     * @return {number} The hexadecimal value.\n     */\n    toJSON() {\n      return this.getHex();\n    }\n    *[Symbol.iterator]() {\n      yield this.r;\n      yield this.g;\n      yield this.b;\n    }\n  }\n  const _color = /* @__PURE__ */ new Color();\n  Color.NAMES = _colorKeywords;\n  if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {\n      revision: REVISION\n    } }));\n  }\n  if (typeof window !== "undefined") {\n    if (window.__THREE__) {\n      console.warn("WARNING: Multiple instances of Three.js being imported.");\n    } else {\n      window.__THREE__ = REVISION;\n    }\n  }\n  const LN_SCALE_MIN = -12;\n  const LN_SCALE_MAX = 9;\n  const LN_SCALE_ZERO = -30;\n  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\n  const SPLAT_TEX_WIDTH_BITS = 11;\n  const SPLAT_TEX_HEIGHT_BITS = 11;\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\n  const SPLAT_TEX_MIN_HEIGHT = 1;\n  function unindentLines(s) {\n    var _a2;\n    let seenNonEmpty = false;\n    const lines = s.split("\\n").map((line) => {\n      const trimmedLine = line.trimEnd();\n      if (seenNonEmpty) {\n        return trimmedLine;\n      }\n      if (trimmedLine.length > 0) {\n        seenNonEmpty = true;\n        return trimmedLine;\n      }\n      return null;\n    }).filter((line) => line != null);\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n      lines.pop();\n    }\n    if (lines.length === 0) {\n      return [];\n    }\n    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];\n    if (!indent) {\n      return lines;\n    }\n    const regex = new RegExp(`^${indent}`);\n    return lines.map((line) => line.replace(regex, ""));\n  }\n  function unindent(s) {\n    return unindentLines(s).join("\\n");\n  }\n  const f32buffer = new Float32Array(1);\n  const u32buffer = new Uint32Array(f32buffer.buffer);\n  const supportsFloat16Array = "Float16Array" in globalThis;\n  const f16buffer = supportsFloat16Array ? new globalThis["Float16Array"](1) : null;\n  const u16buffer = new Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);\n  function normalize(vec) {\n    const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * v, 0));\n    return vec.map((v) => v / norm);\n  }\n  const toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;\n  const fromHalf = supportsFloat16Array ? fromHalfNative : fromHalfJS;\n  function toHalfNative(f) {\n    f16buffer[0] = f;\n    return u16buffer[0];\n  }\n  function toHalfJS(f) {\n    f32buffer[0] = f;\n    const bits2 = u32buffer[0];\n    const sign = bits2 >> 31 & 1;\n    const exp = bits2 >> 23 & 255;\n    const frac = bits2 & 8388607;\n    const halfSign = sign << 15;\n    if (exp === 255) {\n      if (frac !== 0) {\n        return halfSign | 32767;\n      }\n      return halfSign | 31744;\n    }\n    const newExp = exp - 127 + 15;\n    if (newExp >= 31) {\n      return halfSign | 31744;\n    }\n    if (newExp <= 0) {\n      if (newExp < -10) {\n        return halfSign;\n      }\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n      return halfSign | subFrac;\n    }\n    const halfFrac = frac >> 13;\n    return halfSign | newExp << 10 | halfFrac;\n  }\n  function fromHalfNative(u) {\n    u16buffer[0] = u;\n    return f16buffer[0];\n  }\n  function fromHalfJS(h) {\n    const sign = h >> 15 & 1;\n    const exp = h >> 10 & 31;\n    const frac = h & 1023;\n    let f32bits;\n    if (exp === 0) {\n      if (frac === 0) {\n        f32bits = sign << 31;\n      } else {\n        let mant = frac;\n        let e = -14;\n        while ((mant & 1024) === 0) {\n          mant <<= 1;\n          e--;\n        }\n        mant &= 1023;\n        const newExp = e + 127;\n        const newFrac = mant << 13;\n        f32bits = sign << 31 | newExp << 23 | newFrac;\n      }\n    } else if (exp === 31) {\n      if (frac === 0) {\n        f32bits = sign << 31 | 2139095040;\n      } else {\n        f32bits = sign << 31 | 2143289344;\n      }\n    } else {\n      const newExp = exp - 15 + 127;\n      const newFrac = frac << 13;\n      f32bits = sign << 31 | newExp << 23 | newFrac;\n    }\n    u32buffer[0] = f32bits;\n    return f32buffer[0];\n  }\n  function floatToUint8(v) {\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === "object" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const uA = floatToUint8(opacity);\n    const uQuat = encodeQuatOctXy88R8(\n      tempQuaternion.set(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n  }\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n  }\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const i4 = index * 4;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n  }\n  const tempQuaternion = new Quaternion();\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n    const uQuat = encodeQuatOctXy88R8(\n      tempQuaternion.set(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const i4 = index * 4;\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n  }\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const uA = floatToUint8(a);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  }\n  function setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n  }\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\n    const uA = floatToUint8(opacity);\n    const i4 = index * 4;\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n  }\n  new Vector3();\n  new Vector3();\n  new Color();\n  function getTextureSize(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    const maxSplats = width * height * depth;\n    return { width, height, depth, maxSplats };\n  }\n  function computeMaxSplats(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    return width * height * depth;\n  }\n  unindent(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\n  const tempNormalizedQuaternion = new Quaternion();\n  const tempAxis = new Vector3();\n  function encodeQuatOctXy88R8(q) {\n    const qnorm = tempNormalizedQuaternion.copy(q).normalize();\n    if (qnorm.w < 0) {\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n    }\n    const theta = 2 * Math.acos(qnorm.w);\n    const xyz_norm = Math.sqrt(\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n    );\n    const axis = xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n    let p_x = axis.x / sum;\n    let p_y = axis.y / sum;\n    if (axis.z < 0) {\n      const tmp = p_x;\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n    }\n    const u_f = p_x * 0.5 + 0.5;\n    const v_f = p_y * 0.5 + 0.5;\n    const quantU = Math.round(u_f * 255);\n    const quantV = Math.round(v_f * 255);\n    const angleInt = Math.round(theta * (255 / Math.PI));\n    return angleInt << 16 | quantV << 8 | quantU;\n  }\n  function packSint8Bytes(b0, b1, b22, b3) {\n    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\n    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\n    const clampedB2 = Math.max(-127, Math.min(127, b22 * 127));\n    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n  }\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {\n    const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;\n    const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;\n    const sh1Mid = 0.5 * (sh1Min + sh1Max);\n    const sh1Scale = 126 / (sh1Max - sh1Min);\n    const base = index * 2;\n    for (let i2 = 0; i2 < 9; ++i2) {\n      const s = (sh1Rgb[i2] - sh1Mid) * sh1Scale;\n      const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;\n      const bitStart = i2 * 7;\n      const bitEnd = bitStart + 7;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh1Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh1Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {\n    const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;\n    const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;\n    const sh2Mid = 0.5 * (sh2Min + sh2Max);\n    const sh2Scale = 2 / (sh2Max - sh2Min);\n    sh2Array[index * 4 + 0] = packSint8Bytes(\n      (sh2Rgb[0] - sh2Mid) * sh2Scale,\n      (sh2Rgb[1] - sh2Mid) * sh2Scale,\n      (sh2Rgb[2] - sh2Mid) * sh2Scale,\n      (sh2Rgb[3] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 1] = packSint8Bytes(\n      (sh2Rgb[4] - sh2Mid) * sh2Scale,\n      (sh2Rgb[5] - sh2Mid) * sh2Scale,\n      (sh2Rgb[6] - sh2Mid) * sh2Scale,\n      (sh2Rgb[7] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 2] = packSint8Bytes(\n      (sh2Rgb[8] - sh2Mid) * sh2Scale,\n      (sh2Rgb[9] - sh2Mid) * sh2Scale,\n      (sh2Rgb[10] - sh2Mid) * sh2Scale,\n      (sh2Rgb[11] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 3] = packSint8Bytes(\n      (sh2Rgb[12] - sh2Mid) * sh2Scale,\n      (sh2Rgb[13] - sh2Mid) * sh2Scale,\n      (sh2Rgb[14] - sh2Mid) * sh2Scale,\n      0\n    );\n  }\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\n    const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\n    const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\n    const sh3Mid = 0.5 * (sh3Min + sh3Max);\n    const sh3Scale = 62 / (sh3Max - sh3Min);\n    const base = index * 4;\n    for (let i2 = 0; i2 < 21; ++i2) {\n      const s = (sh3Rgb[i2] - sh3Mid) * sh3Scale;\n      const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;\n      const bitStart = i2 * 6;\n      const bitEnd = bitStart + 6;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh3Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh3Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function decompressPartialGzip(fileBytes, numBytes) {\n    const chunks = [];\n    let totalBytes = 0;\n    let result = null;\n    const gunzip = new Gunzip((data, final) => {\n      chunks.push(data);\n      totalBytes += data.length;\n      if (final || totalBytes >= numBytes) {\n        const allBytes = new Uint8Array(totalBytes);\n        let offset2 = 0;\n        for (const chunk of chunks) {\n          allBytes.set(chunk, offset2);\n          offset2 += chunk.length;\n        }\n        result = allBytes.slice(0, numBytes);\n      }\n    });\n    const CHUNK_SIZE = 1024;\n    let offset = 0;\n    while (result == null && offset < fileBytes.length) {\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n      gunzip.push(chunk, false);\n      offset += CHUNK_SIZE;\n    }\n    if (result == null) {\n      gunzip.push(new Uint8Array(), true);\n      if (result == null) {\n        throw new Error("Failed to decompress partial gzip");\n      }\n    }\n    return result;\n  }\n  class GunzipReader {\n    constructor({\n      fileBytes,\n      chunkBytes = 64 * 1024\n    }) {\n      this.fileBytes = fileBytes;\n      this.chunkBytes = chunkBytes;\n      this.chunks = [];\n      this.totalBytes = 0;\n      const ds = new DecompressionStream("gzip");\n      const decompressionStream = new Blob([fileBytes]).stream().pipeThrough(ds);\n      this.reader = decompressionStream.getReader();\n    }\n    async read(numBytes) {\n      while (this.totalBytes < numBytes) {\n        const { value: chunk, done: readerDone } = await this.reader.read();\n        if (readerDone) {\n          break;\n        }\n        this.chunks.push(chunk);\n        this.totalBytes += chunk.length;\n      }\n      if (this.totalBytes < numBytes) {\n        throw new Error(\n          `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n        );\n      }\n      const allBytes = new Uint8Array(this.totalBytes);\n      let outOffset = 0;\n      for (const chunk of this.chunks) {\n        allBytes.set(chunk, outOffset);\n        outOffset += chunk.length;\n      }\n      const result = allBytes.subarray(0, numBytes);\n      this.chunks = [allBytes.subarray(numBytes)];\n      this.totalBytes -= numBytes;\n      return result;\n    }\n  }\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n    const numSplats = Math.floor(fileBytes.length / 32);\n    if (numSplats * 32 !== fileBytes.length) {\n      throw new Error("Invalid .splat file size");\n    }\n    initNumSplats(numSplats);\n    const f32 = new Float32Array(fileBytes.buffer);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i322 = i2 * 32;\n      const i8 = i2 * 8;\n      const x2 = f32[i8 + 0];\n      const y = f32[i8 + 1];\n      const z = f32[i8 + 2];\n      const scaleX = f32[i8 + 3];\n      const scaleY = f32[i8 + 4];\n      const scaleZ = f32[i8 + 5];\n      const r = fileBytes[i322 + 24] / 255;\n      const g = fileBytes[i322 + 25] / 255;\n      const b = fileBytes[i322 + 26] / 255;\n      const opacity = fileBytes[i322 + 27] / 255;\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n      splatCallback(\n        i2,\n        x2,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n    }\n  }\n  function unpackAntiSplat(fileBytes, splatEncoding) {\n    let numSplats = 0;\n    let maxSplats = 0;\n    let packedArray = new Uint32Array(0);\n    decodeAntiSplat(\n      fileBytes,\n      (cbNumSplats) => {\n        numSplats = cbNumSplats;\n        maxSplats = computeMaxSplats(numSplats);\n        packedArray = new Uint32Array(maxSplats * 4);\n      },\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n      }\n    );\n    return { packedArray, numSplats };\n  }\n  const KSPLAT_COMPRESSION = {\n    0: {\n      bytesPerCenter: 12,\n      bytesPerScale: 12,\n      bytesPerRotation: 16,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 4,\n      scaleOffsetBytes: 12,\n      rotationOffsetBytes: 24,\n      colorOffsetBytes: 40,\n      sphericalHarmonicsOffsetBytes: 44,\n      scaleRange: 1\n    },\n    1: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 2,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    },\n    2: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 1,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    }\n  };\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        splatCallback(\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\n          for (const [i22, key] of sh1Index.entries()) {\n            sh1[i22] = getSh(splatOffset, key);\n          }\n          if (sh2) {\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n          }\n          if (sh3) {\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n  }\n  function unpackKsplat(fileBytes, splatEncoding) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    const splatCount = header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    const numSplats = splatCount;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        setPackedSplat(\n          packedArray,\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n        if (sphericalHarmonicsDegree >= 1) {\n          if (sh1) {\n            if (!extra.sh1) {\n              extra.sh1 = new Uint32Array(numSplats * 2);\n            }\n            for (const [i22, key] of sh1Index.entries()) {\n              sh1[i22] = getSh(splatOffset, key);\n            }\n            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\n          }\n          if (sh2) {\n            if (!extra.sh2) {\n              extra.sh2 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\n          }\n          if (sh3) {\n            if (!extra.sh3) {\n              extra.sh3 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\n          }\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n    return { packedArray, numSplats, extra };\n  }\n  const PLY_PROPERTY_TYPES = [\n    "char",\n    "uchar",\n    "short",\n    "ushort",\n    "int",\n    "uint",\n    "float",\n    "double"\n  ];\n  const _PlyReader = class _PlyReader {\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n    constructor({ fileBytes }) {\n      this.header = "";\n      this.littleEndian = true;\n      this.elements = {};\n      this.comments = [];\n      this.data = null;\n      this.numSplats = 0;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    }\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\n    // this.elements will contain all the elements in the file, typically\n    // "vertex" contains the Gsplat data.\n    async parseHeader() {\n      const bufferStream = new ReadableStream({\n        start: (controller) => {\n          controller.enqueue(this.fileBytes.slice(0, 65536));\n          controller.close();\n        }\n      });\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n      this.header = "";\n      const headerTerminator = "end_header\\n";\n      while (true) {\n        const { value, done } = await decoder.read();\n        if (done) {\n          throw new Error("Failed to read header");\n        }\n        this.header += value;\n        const endHeader = this.header.indexOf(headerTerminator);\n        if (endHeader >= 0) {\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\n          break;\n        }\n      }\n      const headerLen = new TextEncoder().encode(this.header).length;\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\n      this.elements = {};\n      let curElement = null;\n      this.comments = [];\n      this.header.trim().split("\\n").forEach((line, lineIndex) => {\n        const trimmedLine = line.trim();\n        if (lineIndex === 0) {\n          if (trimmedLine !== "ply") {\n            throw new Error("Invalid PLY header");\n          }\n          return;\n        }\n        if (trimmedLine.length === 0) {\n          return;\n        }\n        const fields = trimmedLine.split(" ");\n        switch (fields[0]) {\n          case "format":\n            if (fields[1] === "binary_little_endian") {\n              this.littleEndian = true;\n            } else if (fields[1] === "binary_big_endian") {\n              this.littleEndian = false;\n            } else {\n              throw new Error(`Unsupported PLY format: ${fields[1]}`);\n            }\n            if (fields[2] !== "1.0") {\n              throw new Error(`Unsupported PLY version: ${fields[2]}`);\n            }\n            break;\n          case "end_header":\n            break;\n          case "comment":\n            this.comments.push(trimmedLine.slice("comment ".length));\n            break;\n          case "element": {\n            const name = fields[1];\n            curElement = {\n              name,\n              count: Number.parseInt(fields[2]),\n              properties: {}\n            };\n            this.elements[name] = curElement;\n            break;\n          }\n          case "property":\n            if (curElement == null) {\n              throw new Error("Property must be inside an element");\n            }\n            if (fields[1] === "list") {\n              curElement.properties[fields[4]] = {\n                isList: true,\n                type: fields[3],\n                countType: fields[2]\n              };\n            } else {\n              curElement.properties[fields[2]] = {\n                isList: false,\n                type: fields[1]\n              };\n            }\n            break;\n        }\n      });\n      if (this.elements.vertex) {\n        this.numSplats = this.elements.vertex.count;\n      }\n    }\n    parseData(elementCallback) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No data to parse");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const item = createEmptyItem(properties);\n        const parseFn = createParseFn(properties, this.littleEndian);\n        const callback = elementCallback(element) ?? (() => {\n        });\n        for (let index = 0; index < count; index++) {\n          offset = parseFn(data, offset, item);\n          callback(index, item);\n        }\n      }\n    }\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\n    // callbacks for each Gsplat.\n    parseSplats(splatCallback, shCallback) {\n      if (this.elements.vertex == null) {\n        throw new Error("No vertex element found");\n      }\n      let isSuperSplat = false;\n      const ssChunks = [];\n      let numSh = 0;\n      let sh1Props = [];\n      let sh2Props = [];\n      let sh3Props = [];\n      let sh1 = void 0;\n      let sh2 = void 0;\n      let sh3 = void 0;\n      function prepareSh() {\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n        sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * num_f_rest / 3));\n        sh2Props = new Array(5).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)\n        );\n        sh3Props = new Array(7).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => 8 + k + d * num_f_rest / 3)\n        );\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n      }\n      function ssShCallback(index, item) {\n        if (!sh1) {\n          throw new Error("Missing sh1");\n        }\n        const sh = item.f_rest;\n        for (let i2 = 0; i2 < sh1Props.length; i2++) {\n          sh1[i2] = sh[sh1Props[i2]] * 8 / 255 - 4;\n        }\n        if (sh2) {\n          for (let i2 = 0; i2 < sh2Props.length; i2++) {\n            sh2[i2] = sh[sh2Props[i2]] * 8 / 255 - 4;\n          }\n        }\n        if (sh3) {\n          for (let i2 = 0; i2 < sh3Props.length; i2++) {\n            sh3[i2] = sh[sh3Props[i2]] * 8 / 255 - 4;\n          }\n        }\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n      }\n      function initSuperSplat(element) {\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z\n        } = element.properties;\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {\n          throw new Error("Missing PLY chunk properties");\n        }\n        isSuperSplat = true;\n        return (index, item) => {\n          const {\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = item;\n          ssChunks.push({\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          });\n        };\n      }\n      function decodeSuperSplat(element) {\n        if (shCallback && element.name === "sh") {\n          numSh = getNumSh(element.properties);\n          prepareSh();\n          return ssShCallback;\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n          throw new Error(\n            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"\n          );\n        }\n        const SQRT2 = Math.sqrt(2);\n        return (index, item) => {\n          const chunk = ssChunks[index >>> 8];\n          if (chunk == null) {\n            throw new Error("Missing PLY chunk");\n          }\n          const {\n            min_x,\n            min_y,\n            min_z,\n            max_x,\n            max_y,\n            max_z,\n            min_scale_x,\n            min_scale_y,\n            min_scale_z,\n            max_scale_x,\n            max_scale_y,\n            max_scale_z,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = chunk;\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = packed_rotation2 >>> 30;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          const scaleX = Math.exp(\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n          );\n          const scaleY = Math.exp(\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n          );\n          const scaleZ = Math.exp(\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n          );\n          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);\n          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\n          const opacity = (packed_color2 & 255) / 255;\n          splatCallback(\n            index,\n            x2,\n            y,\n            z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            opacity,\n            r,\n            g,\n            b\n          );\n        };\n      }\n      const elementCallback = (element) => {\n        if (element.name === "chunk") {\n          return initSuperSplat(element);\n        }\n        if (isSuperSplat) {\n          return decodeSuperSplat(element);\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const {\n          x: x2,\n          y,\n          z,\n          scale_0,\n          scale_1,\n          scale_2,\n          rot_0,\n          rot_1,\n          rot_2,\n          rot_3,\n          opacity,\n          f_dc_0,\n          f_dc_1,\n          f_dc_2,\n          red,\n          green,\n          blue,\n          alpha\n        } = element.properties;\n        if (!x2 || !y || !z) {\n          throw new Error("Missing PLY properties: x, y, z");\n        }\n        const hasScales = scale_0 && scale_1 && scale_2;\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return (index, item) => {\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n          const quatX = hasRots ? item.rot_1 : 0;\n          const quatY = hasRots ? item.rot_2 : 0;\n          const quatZ = hasRots ? item.rot_3 : 0;\n          const quatW = hasRots ? item.rot_0 : 1;\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n          splatCallback(\n            index,\n            item.x,\n            item.y,\n            item.z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            op,\n            r,\n            g,\n            b\n          );\n          if (shCallback && sh1) {\n            const sh = item.f_rest;\n            if (sh1) {\n              for (let i2 = 0; i2 < sh1Props.length; i2++) {\n                sh1[i2] = sh[sh1Props[i2]];\n              }\n            }\n            if (sh2) {\n              for (let i2 = 0; i2 < sh2Props.length; i2++) {\n                sh2[i2] = sh[sh2Props[i2]];\n              }\n            }\n            if (sh3) {\n              for (let i2 = 0; i2 < sh3Props.length; i2++) {\n                sh3[i2] = sh[sh3Props[i2]];\n              }\n            }\n            shCallback(index, sh1, sh2, sh3);\n          }\n        };\n      };\n      this.parseData(elementCallback);\n    }\n    // Inject RGBA values into original PLY file, which can be used to modify\n    // the color/opacity of the Gsplats and write out the modified PLY file.\n    injectRgba(rgba) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No parsed data");\n      }\n      if (rgba.length !== this.numSplats * 4) {\n        throw new Error("Invalid RGBA array length");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const parsers = [];\n        let rgbaOffset = 0;\n        const isVertex = elementName === "vertex";\n        if (isVertex) {\n          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {\n            if (!properties[name] || properties[name].type !== "float") {\n              throw new Error(`Can\'t injectRgba due to property: ${name}`);\n            }\n          }\n        }\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            if (isVertex) {\n              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {\n                const component = Number.parseInt(\n                  propertyName.slice("f_dc_".length)\n                );\n                parsers.push(() => {\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              } else if (propertyName === "opacity") {\n                parsers.push(() => {\n                  const value = Math.max(\n                    -100,\n                    Math.min(\n                      100,\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                    )\n                  );\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              }\n            }\n            parsers.push(() => {\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            parsers.push(() => {\n              const length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              offset += length * FIELD_BYTES[property.type];\n            });\n          }\n        }\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          if (isVertex) {\n            rgbaOffset += 4;\n          }\n        }\n      }\n    }\n  };\n  _PlyReader.defaultPointScale = 1e-3;\n  let PlyReader = _PlyReader;\n  const SH_C0$1 = 0.28209479177387814;\n  const PARSE_FIELD = {\n    char: (data, offset, littleEndian) => {\n      return data.getInt8(offset);\n    },\n    uchar: (data, offset, littleEndian) => {\n      return data.getUint8(offset);\n    },\n    short: (data, offset, littleEndian) => {\n      return data.getInt16(offset, littleEndian);\n    },\n    ushort: (data, offset, littleEndian) => {\n      return data.getUint16(offset, littleEndian);\n    },\n    int: (data, offset, littleEndian) => {\n      return data.getInt32(offset, littleEndian);\n    },\n    uint: (data, offset, littleEndian) => {\n      return data.getUint32(offset, littleEndian);\n    },\n    float: (data, offset, littleEndian) => {\n      return data.getFloat32(offset, littleEndian);\n    },\n    double: (data, offset, littleEndian) => {\n      return data.getFloat64(offset, littleEndian);\n    }\n  };\n  const SET_FIELD = {\n    char: (data, offset, littleEndian, value) => {\n      data.setInt8(offset, value);\n    },\n    uchar: (data, offset, littleEndian, value) => {\n      data.setUint8(offset, value);\n    },\n    short: (data, offset, littleEndian, value) => {\n      data.setInt16(offset, value, littleEndian);\n    },\n    ushort: (data, offset, littleEndian, value) => {\n      data.setUint16(offset, value, littleEndian);\n    },\n    int: (data, offset, littleEndian, value) => {\n      data.setInt32(offset, value, littleEndian);\n    },\n    uint: (data, offset, littleEndian, value) => {\n      data.setUint32(offset, value, littleEndian);\n    },\n    float: (data, offset, littleEndian, value) => {\n      data.setFloat32(offset, value, littleEndian);\n    },\n    double: (data, offset, littleEndian, value) => {\n      data.setFloat64(offset, value, littleEndian);\n    }\n  };\n  const FIELD_BYTES = {\n    char: 1,\n    uchar: 1,\n    short: 2,\n    ushort: 2,\n    int: 4,\n    uint: 4,\n    float: 4,\n    double: 8\n  };\n  const FIELD_SCALE = {\n    char: 127,\n    uchar: 255,\n    short: 32767,\n    ushort: 65535,\n    int: 2147483647,\n    uint: 4294967295,\n    float: 1,\n    double: 1\n  };\n  const NUM_F_REST_TO_NUM_SH = {\n    0: 0,\n    9: 1,\n    24: 2,\n    45: 3\n  };\n  const NUM_SH_TO_NUM_F_REST = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;\n  function createEmptyItem(properties) {\n    const item = {};\n    for (const [propertyName, property] of Object.entries(properties)) {\n      if (F_REST_REGEX.test(propertyName)) {\n        item.f_rest = new Array(getNumSh(properties));\n      } else {\n        item[propertyName] = property.isList ? [] : 0;\n      }\n    }\n    return item;\n  }\n  function createParseFn(properties, littleEndian) {\n    if (safeToCompile(properties)) {\n      return createCompiledParserFn(properties, littleEndian);\n    }\n    return createDynamicParserFn(properties, littleEndian);\n  }\n  const UNSAFE_EVAL_ALLOWED = (() => {\n    try {\n      new Function("return 42;");\n    } catch (e) {\n      return false;\n    }\n    return true;\n  })();\n  const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;\n  function safeToCompile(properties) {\n    if (!UNSAFE_EVAL_ALLOWED) {\n      return false;\n    }\n    for (const [propertyName, property] of Object.entries(properties)) {\n      if (!PROPERTY_NAME_REGEX.test(propertyName)) {\n        return false;\n      }\n      if (property.isList && !PLY_PROPERTY_TYPES.includes(property.countType)) {\n        return false;\n      }\n      if (!PLY_PROPERTY_TYPES.includes(property.type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function createCompiledParserFn(properties, littleEndian) {\n    const parserSrc = ["let list;"];\n    for (const [propertyName, property] of Object.entries(properties)) {\n      const fRestMatch = propertyName.match(F_REST_REGEX);\n      if (fRestMatch) {\n        const fRestIndex = +fRestMatch[1];\n        parserSrc.push(\n          /*js*/\n          `\n        item.f_rest[${fRestIndex}] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.type]};\n      `\n        );\n      } else if (!property.isList) {\n        parserSrc.push(\n          /*js*/\n          `\n        item[\'${propertyName}\'] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.type]};\n      `\n        );\n      } else {\n        parserSrc.push(\n          /*js*/\n          `\n        list = item[\'${propertyName}\'];\n        list.length = PARSE_FIELD[\'${property.countType}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.countType]};\n        for (let i = 0; i < list.length; i++) {\n          list[i] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n          offset += ${FIELD_BYTES[property.type]};\n        }\n      `\n        );\n      }\n    }\n    parserSrc.push("return offset;");\n    const fn = new Function(\n      "data",\n      "offset",\n      "item",\n      "PARSE_FIELD",\n      parserSrc.join("\\n")\n    );\n    return (data, offset, item) => fn(data, offset, item, PARSE_FIELD);\n  }\n  function createDynamicParserFn(properties, littleEndian) {\n    const parsers = [];\n    for (const [propertyName, property] of Object.entries(properties)) {\n      const fRestMatch = propertyName.match(F_REST_REGEX);\n      if (fRestMatch) {\n        const fRestIndex = +fRestMatch[1];\n        parsers.push(\n          (data, offset, item) => {\n            item.f_rest[fRestIndex] = PARSE_FIELD[property.type](\n              data,\n              offset,\n              littleEndian\n            );\n            return offset + FIELD_BYTES[property.type];\n          }\n        );\n      } else if (!property.isList) {\n        parsers.push(\n          (data, offset, item) => {\n            item[propertyName] = PARSE_FIELD[property.type](\n              data,\n              offset,\n              littleEndian\n            );\n            return offset + FIELD_BYTES[property.type];\n          }\n        );\n      } else {\n        parsers.push(\n          (data, offset, item) => {\n            const list = item[propertyName];\n            list.length = PARSE_FIELD[property.countType](\n              data,\n              offset,\n              littleEndian\n            );\n            let currentOffset = offset + FIELD_BYTES[property.countType];\n            for (let i2 = 0; i2 < list.length; i2++) {\n              list[i2] = PARSE_FIELD[property.type](\n                data,\n                currentOffset,\n                littleEndian\n              );\n              currentOffset += FIELD_BYTES[property.type];\n            }\n            return currentOffset;\n          }\n        );\n      }\n    }\n    return (data, offset, item) => {\n      let currentOffset = offset;\n      for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {\n        currentOffset = parsers[parserIndex](data, currentOffset, item);\n      }\n      return currentOffset;\n    };\n  }\n  function getNumSh(properties) {\n    let num_f_rest = 0;\n    while (properties[`f_rest_${num_f_rest}`]) {\n      num_f_rest += 1;\n    }\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n    if (numSh == null) {\n      throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\n    }\n    return numSh;\n  }\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n    SplatFileType2["PLY"] = "ply";\n    SplatFileType2["SPZ"] = "spz";\n    SplatFileType2["SPLAT"] = "splat";\n    SplatFileType2["KSPLAT"] = "ksplat";\n    SplatFileType2["PCSOGS"] = "pcsogs";\n    SplatFileType2["PCSOGSZIP"] = "pcsogszip";\n    return SplatFileType2;\n  })(SplatFileType || {});\n  function getSplatFileType(fileBytes) {\n    const view = new DataView(fileBytes.buffer);\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\n      return "ply";\n    }\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\n      const header = decompressPartialGzip(fileBytes, 4);\n      const gView = new DataView(header.buffer);\n      if (gView.getUint32(0, true) === 1347635022) {\n        return "spz";\n      }\n      return void 0;\n    }\n    if (view.getUint32(0, true) === 67324752) {\n      if (tryPcSogsZip(fileBytes)) {\n        return "pcsogszip";\n      }\n      return void 0;\n    }\n    return void 0;\n  }\n  function getFileExtension(pathOrUrl) {\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n    const lastSlash = Math.max(\n      noTrailing.lastIndexOf("/"),\n      noTrailing.lastIndexOf("\\\\")\n    );\n    const filename = noTrailing.slice(lastSlash + 1);\n    const lastDot = filename.lastIndexOf(".");\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\n      return "";\n    }\n    return filename.slice(lastDot + 1).toLowerCase();\n  }\n  function getSplatFileTypeFromPath(pathOrUrl) {\n    const extension = getFileExtension(pathOrUrl);\n    if (extension === "ply") {\n      return "ply";\n    }\n    if (extension === "spz") {\n      return "spz";\n    }\n    if (extension === "splat") {\n      return "splat";\n    }\n    if (extension === "ksplat") {\n      return "ksplat";\n    }\n    if (extension === "sog") {\n      return "pcsogszip";\n    }\n    return void 0;\n  }\n  function tryPcSogs(input) {\n    try {\n      let text;\n      if (typeof input === "string") {\n        text = input;\n      } else {\n        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n        if (fileBytes.length > 65536) {\n          return void 0;\n        }\n        text = new TextDecoder().decode(fileBytes);\n      }\n      const json = JSON.parse(text);\n      if (!json || typeof json !== "object" || Array.isArray(json)) {\n        return void 0;\n      }\n      const isVersion2 = json.version === 2;\n      for (const key of ["means", "scales", "quats", "sh0"]) {\n        if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {\n          return void 0;\n        }\n        if (isVersion2) {\n          if (!json[key].files) {\n            return void 0;\n          }\n          if ((key === "scales" || key === "sh0") && !json[key].codebook) {\n            return void 0;\n          }\n          if (key === "means" && (!json[key].mins || !json[key].maxs)) {\n            return void 0;\n          }\n        } else {\n          if (!json[key].shape || !json[key].files) {\n            return void 0;\n          }\n          if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {\n            return void 0;\n          }\n        }\n      }\n      return json;\n    } catch {\n      return void 0;\n    }\n  }\n  function tryPcSogsZip(input) {\n    try {\n      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n      let metaFilename = null;\n      const unzipped = unzipSync(fileBytes, {\n        filter: ({ name }) => {\n          const filename = name.split(/[\\\\/]/).pop();\n          if (filename === "meta.json") {\n            metaFilename = name;\n            return true;\n          }\n          return false;\n        }\n      });\n      if (!metaFilename) {\n        return void 0;\n      }\n      const json = tryPcSogs(unzipped[metaFilename]);\n      if (!json) {\n        return void 0;\n      }\n      return { name: metaFilename, json };\n    } catch {\n      return void 0;\n    }\n  }\n  class SplatData {\n    constructor({ maxSplats = 1 } = {}) {\n      this.numSplats = 0;\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\n      this.centers = new Float32Array(this.maxSplats * 3);\n      this.scales = new Float32Array(this.maxSplats * 3);\n      this.quaternions = new Float32Array(this.maxSplats * 4);\n      this.opacities = new Float32Array(this.maxSplats);\n      this.colors = new Float32Array(this.maxSplats * 3);\n    }\n    pushSplat() {\n      const index = this.numSplats;\n      this.ensureIndex(index);\n      this.numSplats += 1;\n      return index;\n    }\n    unpushSplat(index) {\n      if (index === this.numSplats - 1) {\n        this.numSplats -= 1;\n      } else {\n        throw new Error("Cannot unpush splat from non-last position");\n      }\n    }\n    ensureCapacity(numSplats) {\n      if (numSplats > this.maxSplats) {\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n        const newCenters = new Float32Array(targetSplats * 3);\n        const newScales = new Float32Array(targetSplats * 3);\n        const newQuaternions = new Float32Array(targetSplats * 4);\n        const newOpacities = new Float32Array(targetSplats);\n        const newColors = new Float32Array(targetSplats * 3);\n        newCenters.set(this.centers);\n        newScales.set(this.scales);\n        newQuaternions.set(this.quaternions);\n        newOpacities.set(this.opacities);\n        newColors.set(this.colors);\n        this.centers = newCenters;\n        this.scales = newScales;\n        this.quaternions = newQuaternions;\n        this.opacities = newOpacities;\n        this.colors = newColors;\n        if (this.sh1) {\n          const newSh1 = new Float32Array(targetSplats * 9);\n          newSh1.set(this.sh1);\n          this.sh1 = newSh1;\n        }\n        if (this.sh2) {\n          const newSh2 = new Float32Array(targetSplats * 15);\n          newSh2.set(this.sh2);\n          this.sh2 = newSh2;\n        }\n        if (this.sh3) {\n          const newSh3 = new Float32Array(targetSplats * 21);\n          newSh3.set(this.sh3);\n          this.sh3 = newSh3;\n        }\n        this.maxSplats = targetSplats;\n      }\n    }\n    ensureIndex(index) {\n      this.ensureCapacity(index + 1);\n    }\n    setCenter(index, x2, y, z) {\n      this.centers[index * 3] = x2;\n      this.centers[index * 3 + 1] = y;\n      this.centers[index * 3 + 2] = z;\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      this.scales[index * 3] = scaleX;\n      this.scales[index * 3 + 1] = scaleY;\n      this.scales[index * 3 + 2] = scaleZ;\n    }\n    setQuaternion(index, x2, y, z, w) {\n      this.quaternions[index * 4] = x2;\n      this.quaternions[index * 4 + 1] = y;\n      this.quaternions[index * 4 + 2] = z;\n      this.quaternions[index * 4 + 3] = w;\n    }\n    setOpacity(index, opacity) {\n      this.opacities[index] = opacity;\n    }\n    setColor(index, r, g, b) {\n      this.colors[index * 3] = r;\n      this.colors[index * 3 + 1] = g;\n      this.colors[index * 3 + 2] = b;\n    }\n    setSh1(index, sh1) {\n      if (!this.sh1) {\n        this.sh1 = new Float32Array(this.maxSplats * 9);\n      }\n      for (let j = 0; j < 9; ++j) {\n        this.sh1[index * 9 + j] = sh1[j];\n      }\n    }\n    setSh2(index, sh2) {\n      if (!this.sh2) {\n        this.sh2 = new Float32Array(this.maxSplats * 15);\n      }\n      for (let j = 0; j < 15; ++j) {\n        this.sh2[index * 15 + j] = sh2[j];\n      }\n    }\n    setSh3(index, sh3) {\n      if (!this.sh3) {\n        this.sh3 = new Float32Array(this.maxSplats * 21);\n      }\n      for (let j = 0; j < 21; ++j) {\n        this.sh3[index * 21 + j] = sh3[j];\n      }\n    }\n  }\n  async function unpackPcSogs(json, extraFiles, splatEncoding) {\n    const isVersion2 = "version" in json;\n    if (!isVersion2 && json.quats.encoding !== "quaternion_packed") {\n      throw new Error("Unsupported quaternion encoding");\n    }\n    const numSplats = isVersion2 ? json.count : json.means.shape[0];\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    const meansPromise = Promise.all([\n      decodeImageRgba(extraFiles[json.means.files[0]]),\n      decodeImageRgba(extraFiles[json.means.files[1]])\n    ]).then((means) => {\n      for (let i2 = 0; i2 < numSplats; ++i2) {\n        const i4 = i2 * 4;\n        const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;\n        const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;\n        const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;\n        let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;\n        let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;\n        let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\n        x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\n        y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\n        z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);\n        setPackedSplatCenter(packedArray, i2, x2, y, z);\n      }\n    });\n    const scalesPromise = decodeImageRgba(extraFiles[json.scales.files[0]]).then(\n      (scales) => {\n        let xLookup;\n        let yLookup;\n        let zLookup;\n        if (isVersion2) {\n          xLookup = yLookup = zLookup = json.scales.codebook.map((x2) => Math.exp(x2));\n        } else {\n          xLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n          yLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n          zLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n        }\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          setPackedSplatScales(\n            packedArray,\n            i2,\n            xLookup[scales[i4 + 0]],\n            yLookup[scales[i4 + 1]],\n            zLookup[scales[i4 + 2]],\n            splatEncoding\n          );\n        }\n      }\n    );\n    const quatsPromise = decodeImageRgba(extraFiles[json.quats.files[0]]).then(\n      (quats) => {\n        const SQRT2 = Math.sqrt(2);\n        const lookup = new Array(256).fill(0).map((_, i2) => (i2 / 255 - 0.5) * SQRT2);\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          const r0 = lookup[quats[i4 + 0]];\n          const r1 = lookup[quats[i4 + 1]];\n          const r2 = lookup[quats[i4 + 2]];\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = quats[i4 + 3] - 252;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n    );\n    const sh0Promise = decodeImageRgba(extraFiles[json.sh0.files[0]]).then(\n      (sh0) => {\n        const SH_C02 = 0.28209479177387814;\n        let rLookup;\n        let gLookup;\n        let bLookup;\n        let aLookup;\n        if (isVersion2) {\n          rLookup = gLookup = bLookup = json.sh0.codebook.map((x2) => SH_C02 * x2 + 0.5);\n          aLookup = new Array(256).fill(0).map((_, i2) => i2 / 255);\n        } else {\n          rLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          gLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          bLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          aLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * (i2 / 255)\n          ).map((x2) => 1 / (1 + Math.exp(-x2)));\n        }\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          setPackedSplatRgba(\n            packedArray,\n            i2,\n            rLookup[sh0[i4 + 0]],\n            gLookup[sh0[i4 + 1]],\n            bLookup[sh0[i4 + 2]],\n            aLookup[sh0[i4 + 3]],\n            splatEncoding\n          );\n        }\n      }\n    );\n    const promises = [meansPromise, scalesPromise, quatsPromise, sh0Promise];\n    if (json.shN) {\n      const useSH3 = isVersion2 ? json.shN.bands >= 3 : json.shN.shape[1] >= 48 - 3;\n      const useSH2 = isVersion2 ? json.shN.bands >= 2 : json.shN.shape[1] >= 27 - 3;\n      const useSH1 = isVersion2 ? json.shN.bands >= 1 : json.shN.shape[1] >= 12 - 3;\n      if (useSH1) extra.sh1 = new Uint32Array(numSplats * 2);\n      if (useSH2) extra.sh2 = new Uint32Array(numSplats * 4);\n      if (useSH3) extra.sh3 = new Uint32Array(numSplats * 4);\n      const sh1 = new Float32Array(9);\n      const sh2 = new Float32Array(15);\n      const sh3 = new Float32Array(21);\n      const shN = json.shN;\n      const shNPromise = Promise.all([\n        decodeImage(extraFiles[json.shN.files[0]]),\n        decodeImage(extraFiles[json.shN.files[1]])\n      ]).then(([centroids, labels]) => {\n        const lookup = "codebook" in shN ? shN.codebook : new Array(256).fill(0).map((_, i2) => shN.mins + (shN.maxs - shN.mins) * (i2 / 255));\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);\n          const col = (label & 63) * 15;\n          const row = label >>> 6;\n          const offset = row * centroids.width + col;\n          for (let d = 0; d < 3; ++d) {\n            if (useSH1) {\n              for (let k = 0; k < 3; ++k) {\n                sh1[k * 3 + d] = lookup[centroids.rgba[(offset + k) * 4 + d]];\n              }\n            }\n            if (useSH2) {\n              for (let k = 0; k < 5; ++k) {\n                sh2[k * 3 + d] = lookup[centroids.rgba[(offset + 3 + k) * 4 + d]];\n              }\n            }\n            if (useSH3) {\n              for (let k = 0; k < 7; ++k) {\n                sh3[k * 3 + d] = lookup[centroids.rgba[(offset + 8 + k) * 4 + d]];\n              }\n            }\n          }\n          if (useSH1)\n            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\n          if (useSH2)\n            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\n          if (useSH3)\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\n        }\n      });\n      promises.push(shNPromise);\n    }\n    await Promise.all(promises);\n    return { packedArray, numSplats, extra };\n  }\n  let offscreenGlContext = null;\n  async function decodeImage(fileBytes) {\n    if (!offscreenGlContext) {\n      const canvas = new OffscreenCanvas(1, 1);\n      offscreenGlContext = canvas.getContext("webgl2");\n      if (!offscreenGlContext) {\n        throw new Error("Failed to create WebGL2 context");\n      }\n    }\n    const imageBlob = new Blob([fileBytes]);\n    const bitmap = await createImageBitmap(imageBlob, {\n      premultiplyAlpha: "none"\n    });\n    const gl = offscreenGlContext;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    const data = new Uint8Array(bitmap.width * bitmap.height * 4);\n    gl.readPixels(\n      0,\n      0,\n      bitmap.width,\n      bitmap.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      data\n    );\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(framebuffer);\n    return { rgba: data, width: bitmap.width, height: bitmap.height };\n  }\n  async function decodeImageRgba(fileBytes) {\n    const { rgba } = await decodeImage(fileBytes);\n    return rgba;\n  }\n  async function unpackPcSogsZip(fileBytes, splatEncoding) {\n    var _a2;\n    const nameJson = tryPcSogsZip(fileBytes);\n    if (!nameJson) {\n      throw new Error("Invalid PC SOGS zip file");\n    }\n    const { name, json } = nameJson;\n    const lastSlash = name.lastIndexOf("/");\n    const lastBackslash = name.lastIndexOf("\\\\");\n    const prefix = name.slice(0, Math.max(lastSlash, lastBackslash) + 1);\n    const fileMap = /* @__PURE__ */ new Map();\n    const refFiles = [\n      ...json.means.files,\n      ...json.scales.files,\n      ...json.quats.files,\n      ...json.sh0.files,\n      ...((_a2 = json.shN) == null ? void 0 : _a2.files) ?? []\n    ];\n    for (const file of refFiles) {\n      fileMap.set(prefix + file, file);\n    }\n    const unzipped = await new Promise(\n      (resolve, reject) => {\n        unzip(\n          fileBytes,\n          {\n            filter: ({ name: name2 }) => {\n              return fileMap.has(name2);\n            }\n          },\n          (err2, files) => {\n            if (err2) {\n              reject(err2);\n            } else {\n              resolve(files);\n            }\n          }\n        );\n      }\n    );\n    const extraFiles = {};\n    for (const [full, name2] of fileMap.entries()) {\n      extraFiles[name2] = unzipped[full];\n    }\n    return await unpackPcSogs(json, extraFiles, splatEncoding);\n  }\n  class SpzReader {\n    constructor({ fileBytes }) {\n      this.version = -1;\n      this.numSplats = 0;\n      this.shDegree = 0;\n      this.fractionalBits = 0;\n      this.flags = 0;\n      this.flagAntiAlias = false;\n      this.reserved = 0;\n      this.headerParsed = false;\n      this.parsed = false;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n      this.reader = new GunzipReader({ fileBytes: this.fileBytes });\n    }\n    async parseHeader() {\n      if (this.headerParsed) {\n        throw new Error("SPZ file header already parsed");\n      }\n      const header = new DataView((await this.reader.read(16)).buffer);\n      if (header.getUint32(0, true) !== 1347635022) {\n        throw new Error("Invalid SPZ file");\n      }\n      this.version = header.getUint32(4, true);\n      if (this.version < 1 || this.version > 3) {\n        throw new Error(`Unsupported SPZ version: ${this.version}`);\n      }\n      this.numSplats = header.getUint32(8, true);\n      this.shDegree = header.getUint8(12);\n      this.fractionalBits = header.getUint8(13);\n      this.flags = header.getUint8(14);\n      this.flagAntiAlias = (this.flags & 1) !== 0;\n      this.reserved = header.getUint8(15);\n      this.headerParsed = true;\n      this.parsed = false;\n    }\n    async parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\n      if (!this.headerParsed) {\n        throw new Error("SPZ file header must be parsed first");\n      }\n      if (this.parsed) {\n        throw new Error("SPZ file already parsed");\n      }\n      this.parsed = true;\n      if (this.version === 1) {\n        const centerBytes = await this.reader.read(this.numSplats * 3 * 2);\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const x2 = fromHalf(centerUint16[i3]);\n          const y = fromHalf(centerUint16[i3 + 1]);\n          const z = fromHalf(centerUint16[i3 + 2]);\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else if (this.version === 2 || this.version === 3) {\n        const fixed = 1 << this.fractionalBits;\n        const centerBytes = await this.reader.read(this.numSplats * 3 * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i9 = i2 * 9;\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else {\n        throw new Error("Unreachable");\n      }\n      {\n        const bytes = await this.reader.read(this.numSplats);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\n        }\n      }\n      {\n        const rgbBytes = await this.reader.read(this.numSplats * 3);\n        const scale = SH_C0 / 0.15;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\n        }\n      }\n      {\n        const scalesBytes = await this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\n        }\n      }\n      if (this.version === 3) {\n        const maxValue = 1 / Math.sqrt(2);\n        const quatBytes = await this.reader.read(this.numSplats * 4);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 4;\n          const quaternion = [0, 0, 0, 0];\n          const values = [\n            quatBytes[i3],\n            quatBytes[i3 + 1],\n            quatBytes[i3 + 2],\n            quatBytes[i3 + 3]\n          ];\n          const combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);\n          const valueMask = (1 << 9) - 1;\n          const largestIndex = combinedValues >>> 30;\n          let remainingValues = combinedValues;\n          let sumSquares = 0;\n          for (let i22 = 3; i22 >= 0; --i22) {\n            if (i22 !== largestIndex) {\n              const value = remainingValues & valueMask;\n              const sign = remainingValues >>> 9 & 1;\n              remainingValues = remainingValues >>> 10;\n              quaternion[i22] = maxValue * (value / valueMask);\n              quaternion[i22] = sign === 0 ? quaternion[i22] : -quaternion[i22];\n              sumSquares += quaternion[i22] * quaternion[i22];\n            }\n          }\n          const square = 1 - sumSquares;\n          quaternion[largestIndex] = Math.sqrt(Math.max(square, 0));\n          quatCallback == null ? void 0 : quatCallback(\n            i2,\n            quaternion[0],\n            quaternion[1],\n            quaternion[2],\n            quaternion[3]\n          );\n        }\n      } else {\n        const quatBytes = await this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const quatX = quatBytes[i3] / 127.5 - 1;\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n          const quatW = Math.sqrt(\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n          );\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n      if (shCallback && this.shDegree >= 1) {\n        const sh1 = new Float32Array(3 * 3);\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n        const shBytes = await this.reader.read(\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n        );\n        let offset = 0;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          for (let j = 0; j < 9; ++j) {\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 9;\n          if (sh2) {\n            for (let j = 0; j < 15; ++j) {\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 15;\n          }\n          if (sh3) {\n            for (let j = 0; j < 21; ++j) {\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 21;\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n    }\n  }\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\n  const SH_C0 = 0.28209479177387814;\n  const SPZ_MAGIC = 1347635022;\n  const SPZ_VERSION = 3;\n  const FLAG_ANTIALIASED = 1;\n  class SpzWriter {\n    constructor({\n      numSplats,\n      shDegree,\n      fractionalBits = 12,\n      flagAntiAlias = true\n    }) {\n      this.clippedCount = 0;\n      const splatSize = 9 + // Position\n      1 + // Opacity\n      3 + // Scale\n      3 + // DC-rgb\n      4 + // Rotation\n      (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n      const bufferSize = 16 + numSplats * splatSize;\n      this.buffer = new ArrayBuffer(bufferSize);\n      this.view = new DataView(this.buffer);\n      this.view.setUint32(0, SPZ_MAGIC, true);\n      this.view.setUint32(4, SPZ_VERSION, true);\n      this.view.setUint32(8, numSplats, true);\n      this.view.setUint8(12, shDegree);\n      this.view.setUint8(13, fractionalBits);\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n      this.view.setUint8(15, 0);\n      this.numSplats = numSplats;\n      this.shDegree = shDegree;\n      this.fractionalBits = fractionalBits;\n      this.fraction = 1 << fractionalBits;\n      this.flagAntiAlias = flagAntiAlias;\n    }\n    setCenter(index, x2, y, z) {\n      const xRounded = Math.round(x2 * this.fraction);\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n      const yRounded = Math.round(y * this.fraction);\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n      const zRounded = Math.round(z * this.fraction);\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n      if (clipped) {\n        this.clippedCount += 1;\n      }\n      const i9 = index * 9;\n      const base = 16 + i9;\n      this.view.setUint8(base, xInt & 255);\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\n      this.view.setUint8(base + 3, yInt & 255);\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\n      this.view.setUint8(base + 6, zInt & 255);\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\n    }\n    setAlpha(index, alpha) {\n      const base = 16 + this.numSplats * 9 + index;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\n      );\n    }\n    static scaleRgb(r) {\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n      return Math.max(0, Math.min(255, Math.round(v)));\n    }\n    setRgb(index, r, g, b) {\n      const base = 16 + this.numSplats * 10 + index * 3;\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      const base = 16 + this.numSplats * 13 + index * 3;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n      );\n    }\n    setQuat(index, ...q) {\n      const base = 16 + this.numSplats * 16 + index * 4;\n      const quat = normalize(q);\n      let iLargest = 0;\n      for (let i2 = 1; i2 < 4; ++i2) {\n        if (Math.abs(quat[i2]) > Math.abs(quat[iLargest])) {\n          iLargest = i2;\n        }\n      }\n      const negate = quat[iLargest] < 0 ? 1 : 0;\n      let comp = iLargest;\n      for (let i2 = 0; i2 < 4; ++i2) {\n        if (i2 !== iLargest) {\n          const negbit = (quat[i2] < 0 ? 1 : 0) ^ negate;\n          const mag = Math.floor(\n            ((1 << 9) - 1) * (Math.abs(quat[i2]) / Math.SQRT1_2) + 0.5\n          );\n          comp = comp << 10 | negbit << 9 | mag;\n        }\n      }\n      this.view.setUint8(base, comp & 255);\n      this.view.setUint8(base + 1, comp >> 8 & 255);\n      this.view.setUint8(base + 2, comp >> 16 & 255);\n      this.view.setUint8(base + 3, comp >>> 24 & 255);\n    }\n    static quantizeSh(sh, bits2) {\n      const value = Math.round(sh * 128) + 128;\n      const bucketSize = 1 << 8 - bits2;\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n      return Math.max(0, Math.min(255, quantized));\n    }\n    setSh(index, sh1, sh2, sh3) {\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n      const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;\n      for (let j = 0; j < 9; ++j) {\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n      }\n      if (sh2) {\n        const base2 = base1 + 9;\n        for (let j = 0; j < 15; ++j) {\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n        }\n        if (sh3) {\n          const base3 = base2 + 15;\n          for (let j = 0; j < 21; ++j) {\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n          }\n        }\n      }\n    }\n    async finalize() {\n      const input = new Uint8Array(this.buffer);\n      const stream = new ReadableStream({\n        async start(controller) {\n          controller.enqueue(input);\n          controller.close();\n        }\n      });\n      const compressed = stream.pipeThrough(new CompressionStream("gzip"));\n      const response = new Response(compressed);\n      const buffer = await response.arrayBuffer();\n      console.log(\n        "Compressed",\n        input.length,\n        "bytes to",\n        buffer.byteLength,\n        "bytes"\n      );\n      return new Uint8Array(buffer);\n    }\n  }\n  async function transcodeSpz(input) {\n    var _a2, _b2, _c;\n    const splats = new SplatData();\n    const {\n      inputs,\n      clipXyz,\n      maxSh,\n      fractionalBits = 12,\n      opacityThreshold\n    } = input;\n    for (const input2 of inputs) {\n      let transformPos = function(pos) {\n        pos.multiplyScalar(scale);\n        pos.applyQuaternion(quaternion);\n        pos.add(translate);\n        return pos;\n      }, transformScales = function(scales) {\n        scales.multiplyScalar(scale);\n        return scales;\n      }, transformQuaternion = function(quat) {\n        quat.premultiply(quaternion);\n        return quat;\n      }, withinClip = function(p) {\n        return !clip || clip.containsPoint(p);\n      }, withinOpacity = function(opacity) {\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n      };\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n      const quaternion = new Quaternion().fromArray(\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n      );\n      const translate = new Vector3().fromArray(\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n      );\n      const clip = clipXyz ? new Box3(\n        new Vector3().fromArray(clipXyz.min),\n        new Vector3().fromArray(clipXyz.max)\n      ) : void 0;\n      let fileType = input2.fileType;\n      if (!fileType) {\n        fileType = getSplatFileType(input2.fileBytes);\n        if (!fileType && input2.pathOrUrl) {\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n        }\n      }\n      switch (fileType) {\n        case SplatFileType.PLY: {\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\n          await ply.parseHeader();\n          let lastIndex = null;\n          ply.parseSplats(\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (sh1 && lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n              }\n              if (sh2 && lastIndex !== null) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3 && lastIndex !== null) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPZ: {\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n          await spz2.parseHeader();\n          const mapping = new Int32Array(spz2.numSplats);\n          mapping.fill(-1);\n          const centers = new Float32Array(spz2.numSplats * 3);\n          const center = new Vector3();\n          spz2.parseSplats(\n            (index, x2, y, z) => {\n              const center2 = transformPos(new Vector3(x2, y, z));\n              centers[index * 3] = center2.x;\n              centers[index * 3 + 1] = center2.y;\n              centers[index * 3 + 2] = center2.z;\n            },\n            (index, alpha) => {\n              center.fromArray(centers, index * 3);\n              if (withinClip(center) && withinOpacity(alpha)) {\n                mapping[index] = splats.pushSplat();\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\n                splats.setOpacity(mapping[index], alpha);\n              }\n            },\n            (index, r, g, b) => {\n              if (mapping[index] >= 0) {\n                splats.setColor(mapping[index], r, g, b);\n              }\n            },\n            (index, scaleX, scaleY, scaleZ) => {\n              if (mapping[index] >= 0) {\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n              }\n            },\n            (index, quatX, quatY, quatZ, quatW) => {\n              if (mapping[index] >= 0) {\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  mapping[index],\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (mapping[index] >= 0) {\n                splats.setSh1(mapping[index], sh1);\n                if (sh2) {\n                  splats.setSh2(mapping[index], sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(mapping[index], sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPLAT:\n          decodeAntiSplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                const index2 = splats.pushSplat();\n                splats.setCenter(index2, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(index2, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  index2,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(index2, opacity);\n                splats.setColor(index2, r, g, b);\n              }\n            }\n          );\n          break;\n        case SplatFileType.KSPLAT: {\n          let lastIndex = null;\n          decodeKsplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n                if (sh2) {\n                  splats.setSh2(lastIndex, sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(lastIndex, sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        default:\n          throw new Error(`transcodeSpz not implemented for ${fileType}`);\n      }\n    }\n    const shDegree = Math.min(\n      maxSh ?? 3,\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n    );\n    const spz = new SpzWriter({\n      numSplats: splats.numSplats,\n      shDegree,\n      fractionalBits,\n      flagAntiAlias: true\n    });\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\n      const i3 = i2 * 3;\n      const i4 = i2 * 4;\n      spz.setCenter(\n        i2,\n        splats.centers[i3],\n        splats.centers[i3 + 1],\n        splats.centers[i3 + 2]\n      );\n      spz.setScale(\n        i2,\n        splats.scales[i3],\n        splats.scales[i3 + 1],\n        splats.scales[i3 + 2]\n      );\n      spz.setQuat(\n        i2,\n        splats.quaternions[i4],\n        splats.quaternions[i4 + 1],\n        splats.quaternions[i4 + 2],\n        splats.quaternions[i4 + 3]\n      );\n      spz.setAlpha(i2, splats.opacities[i2]);\n      spz.setRgb(\n        i2,\n        splats.colors[i3],\n        splats.colors[i3 + 1],\n        splats.colors[i3 + 2]\n      );\n      if (splats.sh1 && shDegree >= 1) {\n        spz.setSh(\n          i2,\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\n        );\n      }\n    }\n    const spzBytes = await spz.finalize();\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n  }\n  async function onMessage(event) {\n    const { name, args, id } = event.data;\n    let result = void 0;\n    let error = void 0;\n    try {\n      switch (name) {\n        case "unpackPly": {\n          const { packedArray, fileBytes, splatEncoding } = args;\n          const decoded = await unpackPly({\n            packedArray,\n            fileBytes,\n            splatEncoding\n          });\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeSpz": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = await unpackSpz(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeAntiSplat": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = unpackAntiSplat(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray\n          };\n          break;\n        }\n        case "decodeKsplat": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = unpackKsplat(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogs": {\n          const { fileBytes, extraFiles, splatEncoding } = args;\n          const json = JSON.parse(\n            new TextDecoder().decode(fileBytes)\n          );\n          const decoded = await unpackPcSogs(json, extraFiles, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogsZip": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = await unpackPcSogsZip(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "sortSplats": {\n          const { totalSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ...sortSplats({ totalSplats, readback, ordering })\n          };\n          break;\n        }\n        case "sortDoubleSplats": {\n          const { numSplats, readback, ordering } = args;\n          {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "sort32Splats": {\n          const { numSplats, readback, ordering } = args;\n          {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort32_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "transcodeSpz": {\n          const input = args;\n          const spzBytes = await transcodeSpz(input);\n          result = {\n            id,\n            fileBytes: spzBytes,\n            input\n          };\n          break;\n        }\n        default: {\n          throw new Error(`Unknown name: ${name}`);\n        }\n      }\n    } catch (e) {\n      error = e;\n      console.error(error);\n    }\n    self.postMessage(\n      { id, result, error },\n      { transfer: getArrayBuffers(result) }\n    );\n  }\n  async function unpackPly({\n    packedArray,\n    fileBytes,\n    splatEncoding\n  }) {\n    const ply = new PlyReader({ fileBytes });\n    await ply.parseHeader();\n    const numSplats = ply.numSplats;\n    const extra = {};\n    ply.parseSplats(\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  async function unpackSpz(fileBytes, splatEncoding) {\n    const spz = new SpzReader({ fileBytes });\n    await spz.parseHeader();\n    const numSplats = spz.numSplats;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    await spz.parseSplats(\n      (index, x2, y, z) => {\n        setPackedSplatCenter(packedArray, index, x2, y, z);\n      },\n      (index, alpha) => {\n        setPackedSplatOpacity(packedArray, index, alpha);\n      },\n      (index, r, g, b) => {\n        setPackedSplatRgb(packedArray, index, r, g, b, splatEncoding);\n      },\n      (index, scaleX, scaleY, scaleZ) => {\n        setPackedSplatScales(\n          packedArray,\n          index,\n          scaleX,\n          scaleY,\n          scaleZ,\n          splatEncoding\n        );\n      },\n      (index, quatX, quatY, quatZ, quatW) => {\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  const DEPTH_INFINITY_F16 = 31744;\n  const DEPTH_SIZE_16 = DEPTH_INFINITY_F16 + 1;\n  let depthArray16 = null;\n  function sortSplats({\n    totalSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray16) {\n      depthArray16 = new Uint32Array(DEPTH_SIZE_16);\n    }\n    depthArray16.fill(0);\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\n    const layerSize = readbackUint32[0].length;\n    const numLayers = Math.ceil(totalSplats / layerSize);\n    let layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY_F16) {\n          depthArray16[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    let activeSplats = 0;\n    for (let j = 0; j < DEPTH_SIZE_16; ++j) {\n      const nextIndex = activeSplats + depthArray16[j];\n      depthArray16[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY_F16) {\n          ordering[depthArray16[pri]] = layerBase + i2;\n          depthArray16[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    if (depthArray16[DEPTH_SIZE_16 - 1] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray16[DEPTH_SIZE_16 - 1]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  const messageBuffer = [];\n  function bufferMessage(event) {\n    messageBuffer.push(event);\n  }\n  async function initialize() {\n    self.addEventListener("message", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener("message", bufferMessage);\n    self.addEventListener("message", onMessage);\n    for (const event of messageBuffer) {\n      onMessage(event);\n    }\n    messageBuffer.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=worker-CVv1zjxY.js.map\n',Qi="undefined"!=typeof self&&self.Blob&&new Blob([mi],{type:"text/javascript;charset=utf-8"});function yi(n){let t;try{if(t=Qi&&(self.URL||self.webkitURL).createObjectURL(Qi),!t)throw"";const e=new Worker(t,{name:null==n?void 0:n.name});return e.addEventListener("error",(()=>{(self.URL||self.webkitURL).revokeObjectURL(t)})),e}catch(t){return new Worker("data:text/javascript;charset=utf-8,"+encodeURIComponent(mi),{name:null==n?void 0:n.name})}finally{t&&(self.URL||self.webkitURL).revokeObjectURL(t)}}class xi{constructor(){this.messages={},this.messageIdNext=0,this.worker=new yi,this.worker.onmessage=n=>this.onMessage(n)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const n=this.makeMessageId(),t=new Promise(((t,e)=>{this.messages[n]={resolve:t,reject:e}}));return{id:n,promise:t}}onMessage(n){const{id:t,result:e,error:A}=n.data,s=this.messages[t];s&&(delete this.messages[t],A?s.reject(A):s.resolve(e))}async call(n,t){const{id:e,promise:A}=this.makeMessagePromiseId();return this.worker.postMessage({name:n,args:t,id:e},{transfer:xe(t)}),A}}let wi=4,bi=0;const vi=[],Si=[];async function Di(n){const t=await async function(){const n=vi.shift();if(n)return n;if(bi<wi){const n=new xi;return bi+=1,n}return new Promise((n=>{Si.push(n)}))}();try{return await n(t)}finally{!function(n){if(bi>wi)return void(bi-=1);const t=Si.shift();t?t(n):vi.push(n)}(t)}}class Mi extends a{constructor(n){super(n),this.fileLoader=new r(n)}load(n,t,e,A){const s=this.manager.resolveURL((this.path??"")+(n??"")),a=new Headers(this.requestHeader),r=this.withCredentials?"include":"same-origin",i=new Request(s,{headers:a,credentials:r});let o=this.fileType;this.manager.itemStart(s),ki(i,e).then((async n=>{var A;const i=[new ProgressEvent("progress",{lengthComputable:!0,loaded:n.byteLength,total:n.byteLength})];function c(){if(e){const n=i.every((n=>n.lengthComputable||0===n.loaded&&0===n.total)),t=i.reduce(((n,t)=>n+t.loaded),0),A=i.reduce(((n,t)=>n+t.total),0);e(new ProgressEvent("progress",{lengthComputable:n,loaded:t,total:A}))}}const l={},u=[],g=Fi(n);if("pcsogs"===o&&void 0===g)throw new Error("Invalid PC SOGS file");if(void 0!==g){o="pcsogs";for(const n of["means","scales","quats","sh0","shN"]){const t=g[n];if(t)for(const n of t.files){const t=new URL(n,s).toString(),e=i.length;i.push(new ProgressEvent("progress")),this.manager.itemStart(t);const A=ki(new Request(t,{headers:a,credentials:r}),(n=>{i[e]=n,c()})).then((t=>{l[n]=t})).catch((n=>{throw this.manager.itemError(t),n})).finally((()=>{this.manager.itemEnd(t)}));u.push(A)}}}if(await Promise.all(u),t){const e=(null==(A=this.packedSplats)?void 0:A.splatEncoding)??Ri,a=await Ni({input:n,extraFiles:l,fileType:o,pathOrUrl:s,splatEncoding:e});this.packedSplats?(this.packedSplats.initialize(a),t(this.packedSplats)):t(new Ui(a))}})).catch((n=>{this.manager.itemError(s),null==A||A(n)})).finally((()=>{this.manager.itemEnd(s)}))}async loadAsync(n,t){return new Promise(((e,A)=>{this.load(n,(n=>{e(n)}),t,A)}))}parse(n){return new Wr({packedSplats:n})}}async function ki(n,t){const e=await fetch(n);if(!e.ok)throw new Error(`${e.status} "${e.statusText}" fetching URL: ${n.url}`);if(!e.body)throw new Error(`Response body is null for URL: ${n.url}`);const A=e.body.getReader(),s=Number.parseInt(e.headers.get("Content-Length")||"0"),a=Number.isNaN(s)?0:s;let r=0;const i=[];for(;;){const{done:n,value:e}=await A.read();if(n)break;i.push(e),r+=e.length,t&&t(new ProgressEvent("progress",{lengthComputable:0!==a,loaded:r,total:a}))}const o=new Uint8Array(r);let c=0;for(const n of i)o.set(n,c),c+=n.length;return o.buffer}function _i(n){const t=new DataView(n.buffer);if(7957616==(16777215&t.getUint32(0,!0)))return"ply";if(559903==(16777215&t.getUint32(0,!0))){const t=Je(n,4);return 1347635022===new DataView(t.buffer).getUint32(0,!0)?"spz":void 0}return 67324752===t.getUint32(0,!0)&&function(n){try{const t=n instanceof ArrayBuffer?new Uint8Array(n):n;let e=null;const A=function(n,t){for(var e={},A=n.length-22;101010256!=J(n,A);--A)(!A||n.length-A>65558)&&Y(13);var s=L(n,A+8);if(!s)return{};var a=J(n,A+16),r=4294967295==a||65535==s;if(r){var i=J(n,A-12);(r=101075792==J(n,i))&&(s=J(n,i+32),a=J(n,i+48))}for(var o=t&&t.filter,c=0;c<s;++c){var l=O(n,a,r),u=l[0],g=l[1],h=l[2],I=l[3],d=l[4],C=l[5],B=X(n,C);a=d,o&&!o({name:I,size:g,originalSize:h,compression:u})||(u?8==u?e[I]=V(n.subarray(B,B+g),{out:new p(h)}):Y(14,"unknown compression type "+u):e[I]=G(n,B,B+g))}return e}(t,{filter:({name:n})=>"meta.json"===n.split(/[\\/]/).pop()&&(e=n,!0)});if(!e)return;const s=Fi(A[e]);if(!s)return;return{name:e,json:s}}catch{return}}(n)?"pcsogszip":void 0}function Ti(n){const t=function(n){const t=n.split(/[?#]/,1)[0],e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\")),A=t.slice(e+1),s=A.lastIndexOf(".");return s<=0||s===A.length-1?"":A.slice(s+1).toLowerCase()}(n);return"ply"===t?"ply":"spz"===t?"spz":"splat"===t?"splat":"ksplat"===t?"ksplat":"sog"===t?"pcsogszip":void 0}function Fi(n){try{let t;if("string"==typeof n)t=n;else{const e=n instanceof ArrayBuffer?new Uint8Array(n):n;if(e.length>65536)return;t=(new TextDecoder).decode(e)}const e=JSON.parse(t);if(!e||"object"!=typeof e||Array.isArray(e))return;const A=2===e.version;for(const n of["means","scales","quats","sh0"]){if(!e[n]||"object"!=typeof e[n]||Array.isArray(e[n]))return;if(A){if(!e[n].files)return;if(("scales"===n||"sh0"===n)&&!e[n].codebook)return;if(!("means"!==n||e[n].mins&&e[n].maxs))return}else{if(!e[n].shape||!e[n].files)return;if(!("quats"===n||e[n].mins&&e[n].maxs))return}}return e}catch{return}}async function Ni({input:n,extraFiles:t,fileType:e,pathOrUrl:A,splatEncoding:s}){const a=n instanceof ArrayBuffer?new Uint8Array(n):n;let r=e;switch(e||(r=_i(a),!r&&A&&(r=Ti(A))),r){case"ply":{const n=new ii({fileBytes:a});await n.parseHeader();const t=Me(n.numSplats).maxSplats,e={fileBytes:a,packedArray:new Uint32Array(4*t),splatEncoding:s};return await Di((async n=>{const{packedArray:t,numSplats:A,extra:s}=await n.call("unpackPly",e);return{packedArray:t,numSplats:A,extra:s}}))}case"spz":return await Di((async n=>{const{packedArray:t,numSplats:e,extra:A}=await n.call("decodeSpz",{fileBytes:a,splatEncoding:s});return{packedArray:t,numSplats:e,extra:A}}));case"splat":return await Di((async n=>{const{packedArray:t,numSplats:e}=await n.call("decodeAntiSplat",{fileBytes:a,splatEncoding:s});return{packedArray:t,numSplats:e}}));case"ksplat":return await Di((async n=>{const{packedArray:t,numSplats:e,extra:A}=await n.call("decodeKsplat",{fileBytes:a,splatEncoding:s});return{packedArray:t,numSplats:e,extra:A}}));case"pcsogs":return await Di((async n=>{const{packedArray:e,numSplats:A,extra:r}=await n.call("decodePcSogs",{fileBytes:a,extraFiles:t,splatEncoding:s});return{packedArray:e,numSplats:A,extra:r}}));case"pcsogszip":return await Di((async n=>{const{packedArray:t,numSplats:e,extra:A}=await n.call("decodePcSogsZip",{fileBytes:a,splatEncoding:s});return{packedArray:t,numSplats:e,extra:A}}));default:throw new Error(`Unknown splat file type: ${r}`)}}const Ri={rgbMin:0,rgbMax:1,lnScaleMin:sn,lnScaleMax:9,sh1Min:-1,sh1Max:1,sh2Min:-1,sh2Max:1,sh3Min:-1,sh3Max:1},Gi=class t{constructor(t={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new Yi({packedSplats:this}),this.dynoRgbMinMaxLnScaleMinMax=new qt({key:"rgbMinMaxLnScaleMinMax",value:new n.Vector4(0,1,sn,9),update:n=>{var t,e,A,s;return n.set((null==(t=this.splatEncoding)?void 0:t.rgbMin)??0,(null==(e=this.splatEncoding)?void 0:e.rgbMax)??1,(null==(A=this.splatEncoding)?void 0:A.lnScaleMin)??sn,(null==(s=this.splatEncoding)?void 0:s.lnScaleMax)??9),n}}),this.dynoSh1MinMax=new _t({key:"sh1MinMax",value:new n.Vector2(-1,1),update:n=>{var t,e;return n.set((null==(t=this.splatEncoding)?void 0:t.sh1Min)??-1,(null==(e=this.splatEncoding)?void 0:e.sh1Max)??1),n}}),this.dynoSh2MinMax=new _t({key:"sh2MinMax",value:new n.Vector2(-1,1),update:n=>{var t,e;return n.set((null==(t=this.splatEncoding)?void 0:t.sh2Min)??-1,(null==(e=this.splatEncoding)?void 0:e.sh2Max)??1),n}}),this.dynoSh3MinMax=new _t({key:"sh3MinMax",value:new n.Vector2(-1,1),update:n=>{var t,e;return n.set((null==(t=this.splatEncoding)?void 0:t.sh3Min)??-1,(null==(e=this.splatEncoding)?void 0:e.sh3Max)??1),n}}),this.initialized=Promise.resolve(this),this.reinitialize(t)}reinitialize(n){this.isInitialized=!1,this.extra={},this.splatEncoding=n.splatEncoding,n.url||n.fileBytes||n.construct?this.initialized=this.asyncInitialize(n).then((()=>(this.isInitialized=!0,this))):(this.initialize(n),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(n){n.packedArray?(this.packedArray=n.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/cn)*cn,this.numSplats=Math.min(this.maxSplats,n.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=n.maxSplats??0,this.numSplats=0),this.extra=n.extra??{}}async asyncInitialize(n){const{url:t,fileBytes:e,construct:A}=n;if(t){const n=new Mi;n.packedSplats=this,await n.loadAsync(t)}else if(e){const A=await Ni({input:e,fileType:n.fileType,pathOrUrl:n.fileName??t,splatEncoding:n.splatEncoding??Ri});this.initialize(A)}if(A){const n=A(this);n instanceof Promise&&await n}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(n){const t=n<=this.maxSplats?this.maxSplats:Math.max(n,2*this.maxSplats),e=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||t>e){this.maxSplats=Me(t).maxSplats;const n=new Uint32Array(4*this.maxSplats);this.packedArray&&n.set(this.packedArray),this.packedArray=n}return this.packedArray}ensureSplatsSh(n,t){let e,A;if(0===n)return this.ensureSplats(t);if(1===n)e=2,A="sh1";else if(2===n)e=4,A="sh2";else{if(3!==n)throw new Error(`Invalid level: ${n}`);e=4,A="sh3"}let s=this.extra[A]?this.extra[A].length/e:0;const a=t<=s?s:Math.max(t,2*s);if(!this.extra[A]||a>s){s=Me(a).maxSplats;const n=new Uint32Array(s*e);this.extra[A]&&n.set(this.extra[A]),this.extra[A]=n}return this.extra[A]}getSplat(n){if(!this.packedArray||n>=this.numSplats)throw new Error("Invalid index");return De(this.packedArray,n,this.splatEncoding)}setSplat(n,t,e,A,s,a){be(this.ensureSplats(n+1),n,t.x,t.y,t.z,e.x,e.y,e.z,A.x,A.y,A.z,A.w,s,a.r,a.g,a.b),this.numSplats=Math.max(this.numSplats,n+1)}pushSplat(n,t,e,A,s){be(this.ensureSplats(this.numSplats+1),this.numSplats,n.x,n.y,n.z,t.x,t.y,t.z,e.x,e.y,e.z,e.w,A,s.r,s.g,s.b),++this.numSplats}forEachSplat(n){if(this.packedArray&&this.numSplats)for(let t=0;t<this.numSplats;++t){const e=De(this.packedArray,t,this.splatEncoding);n(t,e.center,e.scales,e.quaternion,e.opacity,e.color)}}ensureGenerate(t){if(this.target&&(t??1)<=this.maxSplats)return!1;this.dispose();const e=Me(t??1),{width:A,height:s,depth:a}=e;return this.maxSplats=e.maxSplats,this.target=new n.WebGLArrayRenderTarget(A,s,a,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:n.NearestFilter,minFilter:n.NearestFilter}),this.target.texture.format=n.RGBAIntegerFormat,this.target.texture.type=n.UnsignedIntType,this.target.texture.internalFormat="RGBA32UI",this.target.scissorTest=!0,!0}generateMapping(n){let t=0;const e=n.map((n=>{const e=t,A=Math.ceil(n/cn)*cn;return t+=A,{base:e,count:n}}));return{maxSplats:t,mapping:e}}getTexture(){if(this.target)return this.target.texture;if(this.source||this.packedArray){return this.maybeUpdateSource()}return t.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:n,height:t,depth:e}=this.source.image;this.maxSplats!==n*t*e&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:t,height:e,depth:A}=Me(this.maxSplats);this.source=new n.DataArrayTexture(this.packedArray,t,e,A),this.source.format=n.RGBAIntegerFormat,this.source.type=n.UnsignedIntType,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!t.emptySource){const{width:e,height:A,depth:s,maxSplats:a}=Me(1),r=new Uint32Array(4*a);t.emptySource=new n.DataArrayTexture(r,e,A,s),t.emptySource.format=n.RGBAIntegerFormat,t.emptySource.type=n.UnsignedIntType,t.emptySource.internalFormat="RGBA32UI",t.emptySource.needsUpdate=!0}return t.emptySource}prepareProgramMaterial(n){let e=t.generatorProgram.get(n);if(!e){const A=Vn({index:"int"},{output:"uvec4"},(({index:t})=>{n.inputs.index=t;const e=n.outputs.gsplat;return{output:ft(e,this.dynoRgbMinMaxLnScaleMinMax)}}));t.programTemplate||(t.programTemplate=new Ve("precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}")),e=new Ke({graph:A,inputs:{index:"index"},outputs:{output:"target"},template:t.programTemplate}),Object.assign(e.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),t.generatorProgram.set(n,e)}const A=e.prepareMaterial();return t.fullScreenQuad.material=A,{program:e,material:A}}saveRenderState(n){return{xrEnabled:n.xr.enabled,autoClear:n.autoClear}}resetRenderState(n,t){n.setRenderTarget(null),n.xr.enabled=t.xrEnabled,n.autoClear=t.autoClear}generate({generator:n,base:e,count:A,renderer:s}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(e+A>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:a,material:r}=this.prepareProgramMaterial(n);a.update();const i=this.saveRenderState(s),o=Math.ceil((e+A)/cn)*cn,c=cn*ln;for(r.uniforms.targetBase.value=e,r.uniforms.targetCount.value=A;e<o;){const n=Math.floor(e/c);r.uniforms.targetLayer.value=n;const A=n*c,a=Math.floor((e-A)/cn),i=Math.min(ln,Math.ceil((o-A)/cn));this.target.scissor.set(0,a,cn,i-a),s.setRenderTarget(this.target,n),s.xr.enabled=!1,s.autoClear=!1,t.fullScreenQuad.render(s),e+=cn*(i-a)}return this.resetRenderState(s,i),{nextBase:o}}};Gi.emptySource=null,Gi.programTemplate=null,Gi.generatorProgram=new Map,Gi.fullScreenQuad=new h(new n.RawShaderMaterial({visible:!1}));let Ui=Gi;class Yi extends xt{constructor({packedSplats:t}={}){super({key:"packedSplats",type:tt,globals:()=>[ct],value:{texture:Ui.getEmpty(),numSplats:0,rgbMinMaxLnScaleMinMax:new n.Vector4(0,1,sn,9)},update:n=>{var t,e,A,s,a,r,i,o,c,l;return n.texture=(null==(t=this.packedSplats)?void 0:t.getTexture())??Ui.getEmpty(),n.numSplats=(null==(e=this.packedSplats)?void 0:e.numSplats)??0,n.rgbMinMaxLnScaleMinMax.set((null==(s=null==(A=this.packedSplats)?void 0:A.splatEncoding)?void 0:s.rgbMin)??0,(null==(r=null==(a=this.packedSplats)?void 0:a.splatEncoding)?void 0:r.rgbMax)??1,(null==(o=null==(i=this.packedSplats)?void 0:i.splatEncoding)?void 0:o.lnScaleMin)??sn,(null==(l=null==(c=this.packedSplats)?void 0:c.splatEncoding)?void 0:l.lnScaleMax)??9),n}}),this.packedSplats=t}}class qi extends n.InstancedBufferGeometry{constructor(t,e){super(),this.ordering=t,this.setAttribute("position",new n.BufferAttribute(zi,3)),this.setIndex(new n.BufferAttribute(Li,1)),this._maxInstanceCount=t.length,this.instanceCount=e,this.attribute=new n.InstancedBufferAttribute(t,1,!1,1),this.attribute.setUsage(n.DynamicDrawUsage),this.setAttribute("splatIndex",this.attribute)}update(n,t){this.ordering=n,this.attribute.array=n,this.instanceCount=t,this.attribute.addUpdateRange(0,t),this.attribute.needsUpdate=!0}}const zi=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0]),Li=new Uint16Array([0,1,2,0,2,3]),Ji=class t{constructor(t){if(this.lastTime=null,this.encodeLinear=!1,this.superXY=1,this.display=null,this.sorting=null,this.pending=null,this.sortingCheck=!1,this.readback16=new Uint16Array(0),this.readback32=new Uint32Array(0),this.spark=t.spark,this.camera=t.camera,this.viewToWorld=t.viewToWorld??new n.Matrix4,t.target){const{width:e,height:A,doubleBuffer:s}=t.target,a=Math.max(1,Math.min(4,t.target.superXY??1));if(this.superXY=a,e*a>8192||A*a>8192)throw new Error("Target size too large");this.target=new n.WebGLRenderTarget(e*a,A*a,{format:n.RGBAFormat,type:n.UnsignedByteType,colorSpace:n.SRGBColorSpace}),s&&(this.back=new n.WebGLRenderTarget(e*a,A*a,{format:n.RGBAFormat,type:n.UnsignedByteType,colorSpace:n.SRGBColorSpace})),this.encodeLinear=!0}this.onTextureUpdated=t.onTextureUpdated,this.sortRadial=t.sortRadial??!0,this.sortDistance=t.sortDistance,this.sortCoorient=t.sortCoorient,this.depthBias=t.depthBias,this.sort360=t.sort360,this.sort32=t.sort32,this.stochastic=t.stochastic??!1,this.orderingFreelist=new we({allocate:n=>new Uint32Array(n),valid:(n,t)=>n.length===t}),this.autoUpdate=!1,this.setAutoUpdate(t.autoUpdate??!1)}dispose(){var n;this.setAutoUpdate(!1),this.target&&(this.target.dispose(),this.target=void 0),this.back&&(this.back.dispose(),this.back=void 0),this.display&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.geometry.dispose(),this.display=null),(null==(n=this.pending)?void 0:n.accumulator)&&(this.spark.releaseAccumulator(this.pending.accumulator),this.pending=null)}setAutoUpdate(n){!this.autoUpdate&&n?this.spark.autoViewpoints.push(this):this.autoUpdate&&!n&&(this.spark.autoViewpoints=this.spark.autoViewpoints.filter((n=>n!==this))),this.autoUpdate=n}async prepare({scene:n,camera:t,viewToWorld:e,update:A,forceOrigin:s}){var a;for(e?this.viewToWorld=e:(this.camera=t??this.camera,this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone()));A??1;){const t=s?this.viewToWorld:void 0;if(this.spark.updateInternal({scene:n,originToWorld:t}))break;await new Promise((n=>setTimeout(n,10)))}const r=this.spark.active;r!==(null==(a=this.display)?void 0:a.accumulator)&&(this.spark.active.refCount+=1),await this.sortUpdate({accumulator:r,viewToWorld:this.viewToWorld})}renderTarget({scene:t,camera:e}){var A;const s=this.back??this.target;if(!s)throw new Error("Must initialize SparkViewpoint with target");if(!(e=e??this.camera))throw new Error("Must provide camera");if(e instanceof n.PerspectiveCamera){const t=(new n.PerspectiveCamera).copy(e,!1);t.aspect=s.width/s.height,t.updateProjectionMatrix(),e=t}this.viewToWorld=e.matrixWorld.clone();try{this.spark.renderer.setRenderTarget(s),this.spark.prepareViewpoint(this),this.spark.renderer.render(t,e)}finally{this.spark.prepareViewpoint(this.spark.defaultView),this.spark.renderer.setRenderTarget(null)}s!==this.target&&([this.target,this.back]=[this.back,this.target]),null==(A=this.onTextureUpdated)||A.call(this,s.texture)}async readTarget(){if(!this.target)throw new Error("Must initialize SparkViewpoint with target");const{width:n,height:t}=this.target,e=n*t*4;(!this.superPixels||this.superPixels.length<e)&&(this.superPixels=new Uint8Array(e)),await this.spark.renderer.readRenderTargetPixelsAsync(this.target,0,0,n,t,this.superPixels);const{superXY:A}=this;if(1===A)return this.superPixels;const s=n/A,a=t/A,r=s*a*4;(!this.pixels||this.pixels.length<r)&&(this.pixels=new Uint8Array(r));const{superPixels:i,pixels:o}=this,c=A*A;for(let n=0;n<a;n++){const t=n*s;for(let e=0;e<s;e++){const s=e*A;let a=0,r=0,l=0,u=0;for(let t=0;t<A;t++){const e=(n*A+t)*this.target.width;for(let n=0;n<A;n++){const t=4*(e+s+n);a+=i[t],r+=i[t+1],l+=i[t+2],u+=i[t+3]}}const g=4*(t+e);o[g]=a/c,o[g+1]=r/c,o[g+2]=l/c,o[g+3]=u/c}}return o}async prepareRenderPixels({scene:n,camera:t,viewToWorld:e,update:A,forceOrigin:s}){return await this.prepare({scene:n,camera:t,viewToWorld:e,update:A,forceOrigin:s}),this.renderTarget({scene:n,camera:t}),this.readTarget()}autoPoll({accumulator:n}){var t,e,A,s;this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone());let a=!1,r=!1;if(this.display){if(n){a=!0;const{mappingVersion:t}=this.display.accumulator;n.mappingVersion===t&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=n,r=!0)}}else a=!0;const i=(null==(t=this.sorting)?void 0:t.viewToWorld)??(null==(e=this.display)?void 0:e.viewToWorld);i&&!Ge({matrix1:this.viewToWorld,matrix2:i,maxDistance:this.sortDistance??.01,minCoorient:this.sortCoorient??this.sortRadial?.99:.999})&&(a=!0),a&&(n&&(n.refCount+=1),n&&(null==(A=this.pending)?void 0:A.accumulator)&&this.pending.accumulator!==(null==(s=this.display)?void 0:s.accumulator)&&this.spark.releaseAccumulator(this.pending.accumulator),this.pending={accumulator:n,viewToWorld:this.viewToWorld,displayed:r},this.driveSort())}async driveSort(){for(var n;;){if(this.sorting||!this.pending)return;const{viewToWorld:t,displayed:e}=this.pending;let A=this.pending.accumulator??(null==(n=this.display)?void 0:n.accumulator);if(A||(A=this.spark.active,A.refCount+=1),this.pending=null,!A)throw new Error("No accumulator to sort");this.sorting={viewToWorld:t},await this.sortUpdate({accumulator:A,viewToWorld:t,displayed:e}),this.sorting=null}}async sortUpdate({accumulator:n,viewToWorld:e,displayed:A=!1}){if(this.sortingCheck)throw new Error("Only one sort at a time");this.sortingCheck=!0,n=n??this.spark.active;const{numSplats:s,maxSplats:a}=n.splats;let r=0,i=this.orderingFreelist.alloc(a);if(this.stochastic){r=s;for(let n=0;n<s;++n)i[n]=n}else if(s>0){const{reader:A,doubleSortReader:o,sort32Reader:c,dynoSortRadial:l,dynoOrigin:u,dynoDirection:g,dynoDepthBias:h,dynoSort360:p,dynoSplats:I}=t.makeSorter(),d=this.sort32??!1;let C;if(d)this.readback32=A.ensureBuffer(a,this.readback32),C=this.readback32;else{const n=Math.ceil(a/2);this.readback16=A.ensureBuffer(n,this.readback16),C=this.readback16}const B=n.toWorld.clone().invert(),f=e.clone().premultiply(B);l.value=!!this.sort360||this.sortRadial,u.value.set(0,0,0).applyMatrix4(f),g.value.set(0,0,-1).applyMatrix4(f).sub(u.value).normalize(),h.value=this.depthBias??1,p.value=this.sort360??!1,I.packedSplats=n.splats;const E=d?c:o,m=d?s:Math.ceil(s/2);await A.renderReadback({renderer:this.spark.renderer,reader:E,count:m,readback:C});const Q=await Di((async n=>{const t=d?"sort32Splats":"sortDoubleSplats";return n.call(t,{maxSplats:a,numSplats:s,readback:C,ordering:i})}));d?this.readback32=Q.readback:this.readback16=Q.readback,i=Q.ordering,r=Q.activeSplats}this.updateDisplay({accumulator:n,viewToWorld:e,ordering:i,activeSplats:r,displayed:A}),this.sortingCheck=!1}updateDisplay({accumulator:n,viewToWorld:t,ordering:e,activeSplats:A,displayed:s=!1}){if(this.display){s||n===this.display.accumulator||(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=n),this.display.viewToWorld=t;const a=this.display.geometry.ordering;a.length===e.length?this.display.geometry.update(e,A):(this.display.geometry.dispose(),this.display.geometry=new qi(e,A)),this.orderingFreelist.free(a)}else this.display={accumulator:n,viewToWorld:t,geometry:new qi(e,A)};this.spark.viewpoint===this&&this.spark.prepareViewpoint(this)}static makeSorter(){if(!t.dynos){const e=new wt({value:!0}),A=new Rt({value:new n.Vector3}),s=new Rt({value:new n.Vector3}),a=new St({value:1}),r=new wt({value:!1}),i=new Yi,o=new Fr,c=Vn({index:"int"},{rgba8:"vec4"},(({index:n})=>{if(!n)throw new Error("No index");const t={sortRadial:e,sortOrigin:A,sortDirection:s,sortDepthBias:a,sort360:r},o=bA(n,qn("int",2)),c=Vi({gsplat:et(i,o),...t}),l=Vi({gsplat:et(i,xA(o,qn("int",1))),...t}),u=Ba({vectorType:"vec2",x:c,y:l});return{rgba8:Gs(Rs(u))}})),l=Vn({index:"int"},{rgba8:"vec4"},(({index:n})=>{if(!n)throw new Error("No index");const t={sortRadial:e,sortOrigin:A,sortDirection:s,sortDepthBias:a,sort360:r},o=Vi({gsplat:et(i,n),...t});return{rgba8:Gs(Ns(o))}}));t.dynos={dynoSortRadial:e,dynoOrigin:A,dynoDirection:s,dynoDepthBias:a,dynoSort360:r,dynoSplats:i,reader:o,doubleSortReader:c,sort32Reader:l}}return t.dynos}};Ji.EMPTY_TEXTURE=new n.Texture,Ji.dynos=null;let Hi=Ji;const Ki=Xn("\n  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {\n    if (!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) {\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : biasedDepth;\n  }\n");function Vi({gsplat:n,sortRadial:t,sortOrigin:e,sortDirection:A,sortDepthBias:s,sort360:a}){return $n({inTypes:{gsplat:nt,sortRadial:"bool",sortOrigin:"vec3",sortDirection:"vec3",sortDepthBias:"float",sort360:"bool"},outTypes:{metric:"float"},globals:()=>[ot,Ki],inputs:{gsplat:n,sortRadial:t,sortOrigin:e,sortDirection:A,sortDepthBias:s,sort360:a},statements:({inputs:n,outputs:t})=>{const{gsplat:e,sortRadial:A,sortOrigin:s,sortDirection:a,sortDepthBias:r,sort360:i}=n;return Zn(`\n        ${t.metric} = computeSort(${e}, ${A}, ${s}, ${a}, ${r}, ${i});\n      `)}}).outputs.metric}class $i{constructor(){this.splats=new Ui,this.toWorld=new n.Matrix4,this.mapping=[],this.refCount=0,this.splatsVersion=-1,this.mappingVersion=-1}ensureGenerate(n){this.splats.ensureGenerate(n)&&(this.mapping=[])}generateSplats({renderer:n,modifier:t,generators:e,forceUpdate:A,originToWorld:s}){const a=this.mapping.reduce(((n,t)=>(n.set(t.node,t),n)),new Map);let r=0,i=0;for(const{node:s,generator:o,version:c,base:l,count:u}of e){const e=a.get(s);if((A||o!==(null==e?void 0:e.generator)||c!==(null==e?void 0:e.version)||l!==(null==e?void 0:e.base)||u!==(null==e?void 0:e.count))&&o&&u>0){const e=t.apply(o);try{this.splats.generate({generator:e,base:l,count:u,renderer:n})}catch(n){s.generator=void 0,s.generatorError=n}r+=1}i=Math.max(i,l+u)}return this.splats.numSplats=i,this.toWorld=s,this.mapping=e,0!==r}hasCorrespondence(n){return this.mapping.length===n.mapping.length&&this.mapping.every((({node:t,base:e,count:A},s)=>{const{node:a,base:r,count:i}=n.mapping[s];return t===a&&e===r&&A===i}))}}let ji=null;const Zi=class t extends n.Mesh{constructor(e){const A=t.makeUniforms(),s=(ji||(n.ShaderChunk.splatDefines="const float LN_SCALE_MIN = -12.0;\nconst float LN_SCALE_MAX = 9.0;\n\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\n\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\n\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\n\nconst uint F16_INF = 0x7c00u;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst float INFINITY = 1.0 / 0.0;\nconst float NEG_INFINITY = -INFINITY;\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n    return x2 * x2;\n}\n\nfloat pow8(float x) {\n    float x4 = pow4(x);\n    return x4 * x4;\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    return pow(rgb, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 rgb) {\n    return pow(rgb, vec3(1.0 / 2.2));\n}\n\nuint encodeQuatOctXy88R8(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float theta = 2.0 * acos(q.w);\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\n    \n    \n    return (angleInt << 16u) | (quantV << 8u) | quantU;\n}\n\nvec4 decodeQuatOctXy88R8(uint encoded) {\n    \n    uint quantU = encoded & uint(0xFFu);               \n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \n    uint angleInt = encoded >> 16u;                      \n\n    \n    float u_f = float(quantU) / 255.0;\n    float v_f = float(quantV) / 255.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\nuvec4 packSplatEncoding(\n    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax\n) {\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\n    vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);\n    uvec4 uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));\n\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\n    \n    \n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\n\n    \n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\n    float lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);\n    uvec3 uScales = uvec3(\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u\n    );\n\n    \n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\n    uint word1 = packHalf2x16(center.xy);\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\n    return uvec4(word0, word1, word2, word3);\n}\n\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\n    return packSplatEncoding(center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\n}\n\nvoid unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\n\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\n    rgba = (vec4(uRgba) / 255.0);\n    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) + rgbMin;\n\n    center = vec4(\n        unpackHalf2x16(word1),\n        unpackHalf2x16(word2 & 0xffffu)\n    ).xyz;\n\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\n    float lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;\n    scales = vec3(\n        (uScales.x == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),\n        (uScales.y == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),\n        (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * lnScaleScale)\n    );\n\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\n    quaternion = decodeQuatOctXy88R8(uQuat);\n    \n    \n}\n\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\n}\n\nvec3 quatVec(vec4 q, vec3 v) {\n    \n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 quatQuat(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\n    \n    return mat3(\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\n    );\n}\n\nvec4 slerp(vec4 q1, vec4 q2, float t) {\n    \n    float cosHalfTheta = dot(q1, q2);\n\n    \n    if (abs(cosHalfTheta) >= 0.999) {\n        return q1;\n    }\n    \n    \n    \n    if (cosHalfTheta < 0.0) {\n        q2 = -q2;\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    \n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    \n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    \n    return q1 * ratioA + q2 * ratioB;\n}\n\nivec3 splatTexCoord(int index) {\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\n    return ivec3(x, y, z);\n}",ji={splatVertex:"precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n\nattribute uint splatIndex;\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\nflat out uint vSplatIndex;\n\nuniform vec2 renderSize;\nuniform uint numSplats;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float minPixelRadius;\nuniform float maxPixelRadius;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform float minAlpha;\nuniform bool stochastic;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float focalDistance;\nuniform float apertureAngle;\nuniform float clipXY;\nuniform float focalAdjustment;\n\nuniform usampler2DArray packedSplats;\nuniform vec4 rgbMinMaxLnScaleMinMax;\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    if (uint(gl_InstanceID) >= numSplats) {\n        return;\n    }\n\n    ivec3 texCoord;\n    if (stochastic) {\n        texCoord = ivec3(\n            uint(gl_InstanceID) & SPLAT_TEX_WIDTH_MASK,\n            (uint(gl_InstanceID) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n            (uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)\n        );\n    } else {\n        if (splatIndex == 0xffffffffu) {\n            \n            return;\n        }\n        texCoord = ivec3(\n            splatIndex & SPLAT_TEX_WIDTH_MASK,\n            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n            splatIndex >> SPLAT_TEX_LAYER_BITS\n        );\n    }\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\n\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, rgbMinMaxLnScaleMinMax);\n\n    if (rgba.a < minAlpha) {\n        return;\n    }\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vSplatIndex = splatIndex;\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 scaledRenderSize = renderSize * focalAdjustment;\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n\n    mat3 J;\n    if(isOrthographic) {\n        J = mat3(\n            focal.x, 0.0, 0.0,\n            0.0, focal.y, 0.0,\n            0.0, 0.0, 0.0\n        );\n    } else {\n        float invZ = 1.0 / viewCenter.z;\n        vec2 J1 = focal * invZ;\n        vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n        J = mat3(\n            J1.x, 0.0, J2.x,\n            0.0, J1.y, J2.y,\n            0.0, 0.0, 0.0\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    float fullBlurAmount = blurAmount;\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\n        float focusRadius = maxPixelRadius;\n        if (viewCenter.z < 0.0) {\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\n            focusRadius = focusBlur * apertureRadius;\n        }\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));\n    }\n\n    \n    float detOrig = a * d - b * b;\n    a += fullBlurAmount;\n    d += fullBlurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < minAlpha) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = min(maxPixelRadius, maxStdDev * sqrt(eigen1));\n    float scale2 = min(maxPixelRadius, maxStdDev * sqrt(eigen2));\n    if (scale1 < minPixelRadius && scale2 < minPixelRadius) {\n        return;\n    }\n\n    \n    vec2 pixelOffset = position.x * eigenVec1 * scale1 + position.y * eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n}",splatFragment:"precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n\nuniform float near;\nuniform float far;\nuniform bool encodeLinear;\nuniform float time;\nuniform bool debugFlag;\nuniform float maxStdDev;\nuniform float minAlpha;\nuniform bool stochastic;\nuniform bool disableFalloff;\nuniform float falloff;\n\nuniform bool splatTexEnable;\nuniform sampler3D splatTexture;\nuniform mat2 splatTexMul;\nuniform vec2 splatTexAdd;\nuniform float splatTexNear;\nuniform float splatTexFar;\nuniform float splatTexMid;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\nflat in uint vSplatIndex;\n\nvoid main() {\n    vec4 rgba = vRgba;\n\n    float z = dot(vSplatUv, vSplatUv);\n    if (!splatTexEnable) {\n        if (z > (maxStdDev * maxStdDev)) {\n            discard;\n        }\n    } else {\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\n        float ndcZ = vNdc.z;\n        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));\n        float clampedFar = max(splatTexFar, splatTexNear);\n        float clampedDepth = clamp(depth, splatTexNear, clampedFar);\n        float logDepth = log2(clampedDepth + 1.0);\n        float logNear = log2(splatTexNear + 1.0);\n        float logFar = log2(clampedFar + 1.0);\n\n        float texZ;\n        if (splatTexMid > 0.0) {\n            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);\n            float logMid = log2(clampedMid + 1.0);\n            texZ = (clampedDepth <= clampedMid) ?\n                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :\n                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);\n        } else {\n            texZ = (logDepth - logNear) / (logFar - logNear);\n        }\n\n        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\n        rgba *= modulate;\n    }\n\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\n\n    if (rgba.a < minAlpha) {\n        discard;\n    }\n    if (encodeLinear) {\n        rgba.rgb = srgbToLinear(rgba.rgb);\n    }\n\n    if (stochastic) {\n        const bool STEADY = false;\n        uint uTime = STEADY ? 0u : floatBitsToUint(time);\n        uvec2 coord = uvec2(gl_FragCoord.xy);\n        uint state = uTime + 0x9e3779b9u * coord.x + 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);\n        state = state * 747796405u + 2891336453u;\n        uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n        hash = (hash >> 22u) ^ hash;\n        float rand = float(hash) / 4294967296.0;\n        if (rand < rgba.a) {\n            fragColor = vec4(rgba.rgb, 1.0);\n        } else {\n            discard;\n        }\n    } else {\n        #ifdef PREMULTIPLIED_ALPHA\n            fragColor = vec4(rgba.rgb * rgba.a, rgba.a);\n        #else\n            fragColor = rgba;\n        #endif\n    }\n}"}),ji),a=e.premultipliedAlpha??!0,r=new n.ShaderMaterial({glslVersion:n.GLSL3,vertexShader:s.splatVertex,fragmentShader:s.splatFragment,uniforms:A,premultipliedAlpha:a,transparent:!0,depthTest:!0,depthWrite:!1,side:n.DoubleSide});super(Oi,r),this.splatTexture=null,this.autoViewpoints=[],this.rotateToAccumulator=new qt({value:new n.Quaternion}),this.translateToAccumulator=new Rt({value:new n.Vector3}),this.lastFrame=-1,this.lastUpdateTime=null,this.defaultCameras=[],this.lastStochastic=null,this.pendingUpdate={scene:null,originToWorld:new n.Matrix4,timeoutId:-1},this.envViewpoint=null,this.frustumCulled=!1,this.renderer=e.renderer,this.material=r,this.uniforms=A;const i=Vn({gsplat:nt},{gsplat:nt},(({gsplat:n})=>{if(!n)throw new Error("gsplat not defined");return{gsplat:n=it(n,{rotate:this.rotateToAccumulator,translate:this.translateToAccumulator})}}));this.modifier=new Zr(i),this.premultipliedAlpha=a,this.autoUpdate=e.autoUpdate??!0,this.preUpdate=e.preUpdate??!1,this.needsUpdate=!1,this.originDistance=e.originDistance??1,this.maxStdDev=e.maxStdDev??Math.sqrt(8),this.minPixelRadius=e.minPixelRadius??0,this.maxPixelRadius=e.maxPixelRadius??512,this.minAlpha=e.minAlpha??1/255*.5,this.enable2DGS=e.enable2DGS??!1,this.preBlurAmount=e.preBlurAmount??0,this.blurAmount=e.blurAmount??.3,this.focalDistance=e.focalDistance??0,this.apertureAngle=e.apertureAngle??0,this.falloff=e.falloff??1,this.clipXY=e.clipXY??1.4,this.focalAdjustment=e.focalAdjustment??1,this.splatEncoding=e.splatEncoding??{...Ri},this.active=new $i,this.accumulatorCount=1,this.freeAccumulators=[];for(let n=0;n<1;++n)this.freeAccumulators.push(new $i),this.accumulatorCount+=1;this.defaultView=new Hi({...e.view,autoUpdate:!0,spark:this}),this.viewpoint=this.defaultView,this.prepareViewpoint(this.viewpoint),this.clock=e.clock?ke(e.clock):new n.Clock}static makeUniforms(){return{renderSize:{value:new n.Vector2},near:{value:.1},far:{value:1e3},numSplats:{value:0},renderToViewQuat:{value:new n.Quaternion},renderToViewPos:{value:new n.Vector3},maxStdDev:{value:1},minPixelRadius:{value:0},maxPixelRadius:{value:512},minAlpha:{value:1/255*.5},stochastic:{value:!1},enable2DGS:{value:!1},preBlurAmount:{value:0},blurAmount:{value:.3},focalDistance:{value:0},apertureAngle:{value:0},falloff:{value:1},clipXY:{value:1.4},focalAdjustment:{value:1},splatTexEnable:{value:!1},splatTexture:{type:"t",value:t.EMPTY_SPLAT_TEXTURE},splatTexMul:{value:new n.Matrix2},splatTexAdd:{value:new n.Vector2},splatTexNear:{value:.1},splatTexFar:{value:1e3},splatTexMid:{value:0},packedSplats:{type:"t",value:Ui.getEmpty()},rgbMinMaxLnScaleMinMax:{value:new n.Vector4},time:{value:0},deltaTime:{value:0},encodeLinear:{value:!1},debugFlag:{value:!1}}}canAllocAccumulator(){return this.freeAccumulators.length>0||this.accumulatorCount<5}maybeAllocAccumulator(){let n=this.freeAccumulators.pop();if(void 0===n){if(this.accumulatorCount>=5)return null;n=new $i,this.accumulatorCount+=1}return n.refCount=1,n}releaseAccumulator(n){n.refCount-=1,0===n.refCount&&this.freeAccumulators.push(n)}newViewpoint(n){return new Hi({...n,spark:this})}onBeforeRender(e,A,s){var a,r;const i=this.time??this.clock.getElapsedTime(),o=i-(this.viewpoint.lastTime??i);this.viewpoint.lastTime=i;const c=e.info.render.frame,l=c!==this.lastFrame;this.lastFrame=c;const u=this.viewpoint;if(u===this.defaultView){if(l)if(e.xr.isPresenting){const t=e.xr.getCamera().cameras;this.defaultCameras=t.map((n=>n.matrixWorld)),this.defaultView.viewToWorld=function(t){if(0===t.length)return null;const e=new n.Vector3,A=new n.Quaternion,s=new n.Vector3,a=[],r=[];for(const n of t)n.decompose(e,A,s),a.push(e),r.push(A);return(new n.Matrix4).compose(Te(a),Fe(r),new n.Vector3(1,1,1))}(this.defaultCameras)??new n.Matrix4}else this.defaultView.viewToWorld=s.matrixWorld.clone(),this.defaultCameras=[this.defaultView.viewToWorld];this.autoUpdate&&this.update({scene:A,viewToWorld:this.defaultView.viewToWorld})}if(l&&(this.material.premultipliedAlpha!==this.premultipliedAlpha&&(this.material.premultipliedAlpha=this.premultipliedAlpha,this.material.needsUpdate=!0),this.uniforms.time.value=i,this.uniforms.deltaTime.value=o,this.uniforms.debugFlag.value=performance.now()/1e3%2<1,u.display&&u.stochastic&&(this.geometry.instanceCount=this.uniforms.numSplats.value)),u.target)this.uniforms.renderSize.value.set(u.target.width,u.target.height);else{const n=e.getDrawingBufferSize(this.uniforms.renderSize.value);if(1===n.x&&1===n.y){const t=null==(a=e.xr.getSession())?void 0:a.renderState.baseLayer;t&&(n.x=t.framebufferWidth,n.y=t.framebufferHeight)}}const g=s;if(this.uniforms.near.value=g.near,this.uniforms.far.value=g.far,this.uniforms.encodeLinear.value=u.encodeLinear,this.uniforms.maxStdDev.value=this.maxStdDev,this.uniforms.minPixelRadius.value=this.minPixelRadius,this.uniforms.maxPixelRadius.value=this.maxPixelRadius,this.uniforms.minAlpha.value=this.minAlpha,this.uniforms.stochastic.value=u.stochastic,this.uniforms.enable2DGS.value=this.enable2DGS,this.uniforms.preBlurAmount.value=this.preBlurAmount,this.uniforms.blurAmount.value=this.blurAmount,this.uniforms.focalDistance.value=this.focalDistance,this.uniforms.apertureAngle.value=this.apertureAngle,this.uniforms.falloff.value=this.falloff,this.uniforms.clipXY.value=this.clipXY,this.uniforms.focalAdjustment.value=this.focalAdjustment,this.lastStochastic!==!u.stochastic&&(this.lastStochastic=!u.stochastic,this.material.transparent=!u.stochastic,this.material.depthWrite=u.stochastic,this.material.needsUpdate=!0),this.splatTexture){const{enable:n,texture:e,multiply:A,add:s,near:a,far:r,mid:i}=this.splatTexture;n&&e?(this.uniforms.splatTexEnable.value=!0,this.uniforms.splatTexture.value=e,A?this.uniforms.splatTexMul.value.fromArray(A.elements):this.uniforms.splatTexMul.value.set(.5/this.maxStdDev,0,0,.5/this.maxStdDev),this.uniforms.splatTexAdd.value.set((null==s?void 0:s.x)??.5,(null==s?void 0:s.y)??.5),this.uniforms.splatTexNear.value=a??this.uniforms.near.value,this.uniforms.splatTexFar.value=r??this.uniforms.far.value,this.uniforms.splatTexMid.value=i??0):(this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=t.EMPTY_SPLAT_TEXTURE)}else this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=t.EMPTY_SPLAT_TEXTURE;const h=(null==(r=u.display)?void 0:r.accumulator.toWorld)??new n.Matrix4,p=s.matrixWorld.clone().invert();h.clone().premultiply(p).decompose(this.uniforms.renderToViewPos.value,this.uniforms.renderToViewQuat.value,new n.Vector3)}prepareViewpoint(n){var t,e,A,s;if(this.viewpoint=n??this.viewpoint,this.viewpoint.display){const{accumulator:n,geometry:a}=this.viewpoint.display;this.uniforms.numSplats.value=n.splats.numSplats,this.uniforms.packedSplats.value=n.splats.getTexture(),this.uniforms.rgbMinMaxLnScaleMinMax.value.set((null==(t=n.splats.splatEncoding)?void 0:t.rgbMin)??0,(null==(e=n.splats.splatEncoding)?void 0:e.rgbMax)??1,(null==(A=n.splats.splatEncoding)?void 0:A.lnScaleMin)??sn,(null==(s=n.splats.splatEncoding)?void 0:s.lnScaleMax)??9),this.geometry=a,this.material.transparent=!this.viewpoint.stochastic,this.material.depthWrite=this.viewpoint.stochastic,this.material.needsUpdate=!0}else this.uniforms.numSplats.value=0,this.uniforms.packedSplats.value=Ui.getEmpty(),this.geometry=Oi}update({scene:n,viewToWorld:t}){const e=this.matrixWorld;this.preUpdate?this.updateInternal({scene:n,originToWorld:e.clone(),viewToWorld:t}):(this.pendingUpdate.scene=n,this.pendingUpdate.originToWorld.copy(e),-1===this.pendingUpdate.timeoutId&&(this.pendingUpdate.timeoutId=setTimeout((()=>{const{scene:n,originToWorld:e}=this.pendingUpdate;this.pendingUpdate.scene=null,this.pendingUpdate.timeoutId=-1;if(this.updateInternal({scene:n,originToWorld:e,viewToWorld:t})){this.renderer.getContext().flush()}}),1)))}updateInternal({scene:t,originToWorld:e,viewToWorld:A}){var s;if(!this.canAllocAccumulator())return!1;e||(e=this.active.toWorld),A=A??e.clone();const a=this.time??this.clock.getElapsedTime(),r=a-(this.lastUpdateTime??a);this.lastUpdateTime=a;const i=this.active.mapping.reduce(((n,t)=>(n.set(t.node,t),n)),new Map),{generators:o,visibleGenerators:c,globalEdits:l}=this.compileScene(t);for(const n of o)null==(s=n.frameUpdate)||s.call(n,{object:n,time:a,deltaTime:r,viewToWorld:A,globalEdits:l});const u=new Set(c.map((n=>n.uuid)));for(const n of o){const t=i.get(n),e=n.generator&&u.has(n.uuid)?n.numSplats:0;(this.needsUpdate||n.generator!==(null==t?void 0:t.generator)||e!==(null==t?void 0:t.count))&&n.updateVersion()}const g=!Ge({matrix1:e,matrix2:this.active.toWorld,maxDistance:this.originDistance}),h=this.needsUpdate||g||o.length!==i.size||o.some((n=>{var t;return n.version!==(null==(t=i.get(n))?void 0:t.version)}));this.needsUpdate=!1;let p=null;if(h){if(p=this.maybeAllocAccumulator(),!p)throw new Error("Unreachable");const t=!Ge({matrix1:e,matrix2:this.active.toWorld,maxDistance:1e-5,minCoorient:.99999}),A=c.map(((n,t)=>{const e=i.get(n);return e?[n.version-e.version,e.base,n]:[Number.POSITIVE_INFINITY,n.version,n]})).sort(((n,t)=>n[0]!==t[0]?n[0]-t[0]:n[1]-t[1])).map((([n,t,e])=>e)),s=A.map((n=>n.numSplats)),{maxSplats:a,mapping:r}=p.splats.generateMapping(s),o=A.map(((n,t)=>{const{base:e,count:A}=r[t];return{node:n,generator:n.generator,version:n.version,base:e,count:A}}));e.clone().invert().decompose(this.translateToAccumulator.value,this.rotateToAccumulator.value,new n.Vector3),p.ensureGenerate(a),p.splats.splatEncoding={...this.splatEncoding},p.generateSplats({renderer:this.renderer,modifier:this.modifier,generators:o,forceUpdate:t,originToWorld:e}),p.splatsVersion=this.active.splatsVersion+1;const l=p.hasCorrespondence(this.active);p.mappingVersion=this.active.mappingVersion+(l?0:1),this.releaseAccumulator(this.active),this.active=p,this.prepareViewpoint()}return setTimeout((()=>{for(const n of this.autoViewpoints)n.autoPoll({accumulator:p??void 0})}),1),!0}compileScene(n){const t=[];n.traverse((n=>{n instanceof Or&&t.push(n)}));const e=[];n.traverseVisible((n=>{n instanceof Or&&e.push(n)}));const A=new Set;return n.traverseVisible((n=>{if(n instanceof Jr){let t=n.parent;for(;null!=t&&!(t instanceof Wr);)t=t.parent;null==t&&A.add(n)}})),{generators:t,visibleGenerators:e,globalEdits:Array.from(A)}}async renderEnvMap({renderer:e,scene:A,worldCenter:s,size:a=256,near:r=.1,far:i=1e3,hideObjects:o=[],update:c=!1}){var l,u;if(this.envViewpoint||(this.envViewpoint=this.newViewpoint({sort360:!0})),!t.cubeRender||t.cubeRender.target.width!==a||t.cubeRender.near!==r||t.cubeRender.far!==i){t.cubeRender&&t.cubeRender.target.dispose();const e=new n.WebGLCubeRenderTarget(a,{format:n.RGBAFormat,generateMipmaps:!0,minFilter:n.LinearMipMapLinearFilter}),A=new n.CubeCamera(r,i,e);t.cubeRender={target:e,camera:A,near:r,far:i}}t.pmrem||(t.pmrem=new n.PMREMGenerator(e??this.renderer));const g=(new n.Matrix4).setPosition(s);await(null==(l=this.envViewpoint)?void 0:l.prepare({scene:A,viewToWorld:g,update:c}));const{target:h,camera:p}=t.cubeRender;p.position.copy(s);const I=new Map;for(const n of o)I.set(n,n.visible),n.visible=!1;this.prepareViewpoint(this.envViewpoint),p.update(e??this.renderer,A),this.prepareViewpoint(this.defaultView);for(const[n,t]of I.entries())n.visible=t;return null==(u=t.pmrem)?void 0:u.fromCubemap(h.texture).texture}recurseSetEnvMap(t,e){t.traverse((t=>{if(t instanceof n.Mesh)if(Array.isArray(t.material))for(const A of t.material)A instanceof n.MeshStandardMaterial&&(A.envMap=e);else t.material instanceof n.MeshStandardMaterial&&(t.material.envMap=e)}))}getRgba({generator:n,rgba:t}){const e=this.active.mapping.find((({node:t})=>t===n));if(!e)throw new Error("Generator not found");return(t=t??new Rr).fromPackedSplats({packedSplats:this.active.splats,base:e.base,count:e.count,renderer:this.renderer}),t}async readRgba({generator:n,rgba:t}){return(t=this.getRgba({generator:n,rgba:t})).read()}};Zi.cubeRender=null,Zi.pmrem=null,Zi.EMPTY_SPLAT_TEXTURE=new n.Data3DTexture;let Xi=Zi;const Oi=new qi(new Uint32Array(1),0);Vn({packedSplats:tt,index:"int"},{gsplat:nt},(({packedSplats:n,index:t})=>{if(!n||!t)throw new Error("Invalid input");return{gsplat:et(n,t)}}));Xn("\n  struct GsplatSkinning {\n    int numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    sampler2D boneTexture;\n  };\n"),Xn("\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n    usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || (splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & 0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x >> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = (skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) {\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if (boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the opposite direction\n          boneQuat = -boneQuat;\n          boneDual = -boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual += weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, quaternion);\n  }\n");const Pi={box:new n.Box3(new n.Vector3(-1,-1,-1),new n.Vector3(1,1,1)),density:100,fallDirection:new n.Vector3(-1,-3,1).normalize(),fallVelocity:.02,wanderScale:.04,wanderVariance:2,color1:new n.Color(1,1,1),color2:new n.Color(.5,.5,1),minScale:.001,maxScale:.005,anisoScale:new n.Vector3(1,1,1)},Wi={box:new n.Box3(new n.Vector3(-2,-1,-2),new n.Vector3(2,5,2)),density:10,fallDirection:new n.Vector3(0,-1,0),fallVelocity:2,wanderScale:.1,wanderVariance:1,color1:new n.Color(1,1,1),color2:new n.Color(.25,.25,.5),minScale:.005,maxScale:.01,anisoScale:new n.Vector3(.1,1,.1)};Symbol.toStringTag;function no(n){return Vn({gsplat:nt},{gsplat:nt},(({gsplat:t})=>{if(!t)throw new Error("No gsplat input");let e=rt(t);const A=n.applyGsplat(t),s=st(A).outputs.center,a=rt(A),r=Ia(s,a),i=us(r,qn("float",0));e=gs(i,MA(e),e);const o=xA(bA(e,qn("float",.5)),qn("float",.5));return{gsplat:t=at({gsplat:t,rgb:o})}}))}function to(n,t,e,A){return Vn({gsplat:nt},{gsplat:nt},(({gsplat:s})=>{if(!s)throw new Error("No gsplat input");let{center:a}=st(s).outputs;a=n.apply(a);const{z:r}=Ca(a).outputs;let i=Va(MA(r),t,e);return i=gs(A,wA(qn("float",1),i),i),{gsplat:s=at({gsplat:s,r:i,g:i,b:i})}}))}Symbol.toStringTag;const eo=class n{static createButton(t,e={}){const A=navigator.xr;if(!A)return null;const s=A,a=document.createElement("button");function r(){a.style.display="none",a.style.cursor="auto",a.style.left="calc(50% - 75px)",a.style.width="150px",a.onmouseenter=null,a.onmouseleave=null,a.onclick=null}var i;return t.xr.enabled=!0,t.xr.setReferenceSpaceType("local"),a.id="VRButton",a.style.display="none",(i=a).style.position="absolute",i.style.bottom="20px",i.style.padding="12px 6px",i.style.border="1px solid #fff",i.style.borderRadius="4px",i.style.background="rgba(0,0,0,0.1)",i.style.color="#fff",i.style.font="normal 13px sans-serif",i.style.textAlign="center",i.style.opacity="0.5",i.style.outline="none",i.style.zIndex="999",s.isSessionSupported("immersive-vr").then((A=>{A?function(){let n=null;async function A(e){console.log("onSessionStarted"),e.addEventListener("end",r),await t.xr.setSession(e),a.textContent="EXIT VR",n=e}function r(){console.log("onSessionEnded"),null==n||n.removeEventListener("end",r),a.textContent="ENTER VR",n=null}a.style.display="",a.style.cursor="pointer",a.style.left="calc(50% - 100px)",a.style.width="200px",a.style.height="100px",a.textContent="ENTER VR";const i={...e,optionalFeatures:[...e.optionalFeatures||[]]};a.onmouseenter=()=>{a.style.opacity="1.0"},a.onmouseleave=()=>{a.style.opacity="0.5"},a.onclick=()=>{null===n?(console.log("requesting session"),s.requestSession("immersive-vr",i).then(A)):(console.log("ending session"),n.end())}}():(r(),a.textContent="VR NOT SUPPORTED"),A&&n.xrSessionIsGranted&&a.click()})).catch((function(n){r(),console.warn("Exception when trying to call xr.isSessionSupported",n),a.textContent="VR NOT ALLOWED"})),a}static registerSessionGrantedListener(){const t=navigator.xr;if(!t)return null;const e=t;/WebXRViewer\//i.test(navigator.userAgent)||e.addEventListener("sessiongranted",(()=>{n.xrSessionIsGranted=!0}))}};eo.xrSessionIsGranted=!1,eo.registerSessionGrantedListener();var Ao=(n=>(n.w="wrist",n.t0="thumb-metacarpal",n.t1="thumb-phalanx-proximal",n.t2="thumb-phalanx-distal",n.t3="thumb-tip",n.i0="index-finger-metacarpal",n.i1="index-finger-phalanx-proximal",n.i2="index-finger-phalanx-intermediate",n.i3="index-finger-phalanx-distal",n.i4="index-finger-tip",n.m0="middle-finger-metacarpal",n.m1="middle-finger-phalanx-proximal",n.m2="middle-finger-phalanx-intermediate",n.m3="middle-finger-phalanx-distal",n.m4="middle-finger-tip",n.r0="ring-finger-metacarpal",n.r1="ring-finger-phalanx-proximal",n.r2="ring-finger-phalanx-intermediate",n.r3="ring-finger-phalanx-distal",n.r4="ring-finger-tip",n.p0="pinky-finger-metacarpal",n.p1="pinky-finger-phalanx-proximal",n.p2="pinky-finger-phalanx-intermediate",n.p3="pinky-finger-phalanx-distal",n.p4="pinky-finger-tip",n))(Ao||{});const so=Object.keys(Ao);so.length;var ao=(n=>(n.left="left",n.right="right",n))(ao||{});Object.keys(ao);new n.Vector3(0,0,-1),new n.Vector3(0,0,1),new n.Vector3(-1,0,0),new n.Vector3(1,0,0),new n.Vector3(0,1,0),new n.Vector3(0,-1,0),new n.Vector3(0,0,-1),new n.Vector3(0,0,1),new n.Vector3(-1,0,0),new n.Vector3(1,0,0),new n.Vector3(0,1,0),new n.Vector3(0,-1,0),new n.Vector3(0,0,1),new n.Vector3(0,0,-1),new n.Vector3(0,-1,0),new n.Vector3(0,1,0),new n.Vector3(-1,0,0),new n.Vector3(1,0,0);return Wr};let SplatMesh;core.SplatMesh=async(n,t)=>{if("Packed"!=await interpretate(n[1],t))throw"SplatMesh must be packed";const e=await interpretate(n[2],t);if(!(e instanceof ArrayBuffer))throw"SplatMesh does not have ByteArray";SplatMesh||(SplatMesh=await loadSplat());const A=new Deferred,s=new SplatMesh({fileBytes:e,onLoad:()=>A.resolve()});await A.promise;s.rotateX(Math.PI/2.0);s.rotateY(-Math.PI/2.0);const a=interpretate.shared.THREE.THREE,r=s.getBoundingBox(),i=new a.Box3Helper(r,16776960);return i.material.opacity=0,i.material.visible=!1,t.local.splat=s,t.local.helper=i,t.mesh.add(i),t.mesh.add(s),s},core.SplatMesh.destroy=(n,t)=>{t.local.splat.dispose(),t.local.helper.dispose()},core.SplatMesh.update=async(n,t)=>{throw"Updates of SplatMesh are not supported"},core.SplatMesh.virtual=!0,core["CoffeeLiqueur`Workshop`SplatMesh`"]=core.SplatMesh;